<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jungle</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-20T05:06:19.528Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jungle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>版本号的正确打开方式</title>
    <link href="http://example.com/2021/12/20/version-range/"/>
    <id>http://example.com/2021/12/20/version-range/</id>
    <published>2021-12-20T03:26:44.000Z</published>
    <updated>2021-12-20T05:06:19.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本号的正确打开方式"><a href="#版本号的正确打开方式" class="headerlink" title="版本号的正确打开方式"></a>版本号的正确打开方式</h1><p>版本号广泛运用于开发的各种场景：NPM 包的版本定义、对 NPM 包的特定版本的依赖指定、git 的 daily 版本号分支……</p><p>面对如此多的场景，版本号的命名却存在很大问题。举些例子：</p><ul><li><p>开始写一个新项目 / 模块时，不管三七二十一，都从 <code>0.0.1</code> 起版本，直到项目不再维护时，版本还停留在 <code>0.0.48</code>，前两位永远都是 0。</p></li><li><p>API 变化巨大，而版本号雷打不动一步一个脚印。一个二方包从 <code>0.0.8</code> 升级到 <code>0.0.9</code>就引起了整个项目的崩溃。</p></li><li><p>依赖二方 / 三方包时，不知道该依赖哪个版本，有时随便指定了一个，有时则直接依赖了 <code>*</code>。</p></li></ul><h2 id="版本号的命名"><a href="#版本号的命名" class="headerlink" title="版本号的命名"></a>版本号的命名</h2><h3 id="SemVer"><a href="#SemVer" class="headerlink" title="SemVer"></a>SemVer</h3><p>根据国际主流的惯例，我们使用「语义化版本（Semantic Versioning）」的命名方式，有时简称 SemVer。</p><p>语义化版本号（以下简称「版本号」）的格式是：<code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>。即使用三位非负整数，以点号 <code>.</code> 连接。</p><p>如：<code>1.4.15</code>、<code>6.2.0</code>。</p><h3 id="每一位版本号的含义"><a href="#每一位版本号的含义" class="headerlink" title="每一位版本号的含义"></a>每一位版本号的含义</h3><ol><li><code>&lt;major&gt;</code> 即主版本号，俗称大版本升级。改动到主版本号时，标志着 API 发生了巨大变化，包括但不限于新增特性、修改机制、删除功能， <strong>一般不兼容上一个主版本号</strong>。</li><li><code>&lt;minor&gt;</code> 即次版本号，俗称小版本升级。当我们进行常规的新增或修改功能时，改动次版本号，但是 <strong>必须是向前兼容的</strong>。这也意味着我们 <strong>不能直接删除某个功能</strong>。如若必要，我们可以在 changelog 中标记某项功能为「即将删除（Deprecated）」，然后在下一个大版本中将其彻底删除。</li><li><code>&lt;patch&gt;</code> 即修订号，俗称 bug 修复。顾名思义，如果仅仅为了修复或调整一些小问题，我们就只改动修订号。</li></ol><p>所以，当我们明确了每一位的含义和作用后，就不会陷入「每次只改最末位」的尴尬中了。</p><p>那如何判断一个修改应该是改动修订号还是次版本号呢？视情况而定。比如对于「修改了 app 图标」这件事来说，如果只是调整了图标的间距位置，那么可以认作问题修复；如果把整个图标换了，配上了不同的标语，那么这应该是一次功能改动。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>版本号前不要加 <code>v</code>。</li><li>不要在数字前补 <code>0</code>。错误示例：<code>01.12.03</code>。</li><li>每一位版本号按照 +1 的速度递增，不要在版本号之间跳跃。</li><li>主版本号停留在 <code>0</code> 的版本号，即 <code>0.x.x</code> 应当视作还在内部开发阶段的代码。如果代码有公共 API，此时不宜对外公开。</li><li><code>1.0.0</code> 的版本号用于界定公共 API 的形成。</li><li>当次版本号递增时，修订号归零；当主版本号递增时，次版本号、修订号归零。</li><li>进行新的开发时，版本号从 <code>0.1.0</code> 开始。</li><li>如果不小心把一个不兼容的改版当成了次版本号发行，应当发行一个新的次版本号来更正这个问题并且恢复向下兼容。注意 <strong>不能去修改已发行的版本</strong>。</li></ul><h3 id="一个典型的版本号发展示例"><a href="#一个典型的版本号发展示例" class="headerlink" title="一个典型的版本号发展示例"></a>一个典型的版本号发展示例</h3><ol><li><code>0.1.0</code></li><li><code>0.1.1</code></li><li><code>0.1.2</code></li><li><code>0.2.0</code></li><li><code>1.0.0</code></li><li><code>1.1.0</code></li><li><code>1.1.1</code></li><li>……</li></ol><h3 id="快速修改版本号"><a href="#快速修改版本号" class="headerlink" title="快速修改版本号"></a>快速修改版本号</h3><p>如果一个包发布在 NPM / TNPM 中，可以快速修改其版本号。会自动触发一个 git 提交。</p><table><thead><tr><th></th><th><code># 递增一个修订号npm version patch# 递增一个次版本号npm version minor# 递增一个主版本号npm version major</code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="预发版本号"><a href="#预发版本号" class="headerlink" title="预发版本号"></a>预发版本号</h2><p>在常规的版本号命名之上还有一个特殊类别，叫做预发版本号（prerelease version）。它表示当前版本是一个不稳定的版本，使用它时需要注意风险。</p><p>预发版本号的格式是 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;tag&gt;</code>，即前半部分和常规版本号相同，然后跟上连接符 <code>-</code>，后面再跟上字母数字点号连接符（[0-9A-Za-z-.]）。</p><p>一个典型的预发版本号形如 <code>1.0.0-beta.1</code>。建议使用这种 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;stage&gt;.&lt;num&gt;</code> 的形式。其中 <code>&lt;stage&gt;</code> 一般选用：<code>alpha</code>、<code>beta</code>、<code>rc</code>。</p><p>预发版本号是常规版本号的附属，因此在版本的大小比较上，仍然先比较常规版本号部分；对于预发标记部分的比较，则是根据 ASCII 字母表中的顺序来进行。</p><h3 id="一个典型的预发版本号发展示例"><a href="#一个典型的预发版本号发展示例" class="headerlink" title="一个典型的预发版本号发展示例"></a>一个典型的预发版本号发展示例</h3><ol><li><code>0.9.0</code></li><li><code>1.0.0-alpha.1</code></li><li><code>1.0.0-alpha.2</code></li><li><code>1.0.0-beta.1</code></li><li><code>1.0.0-rc.1</code></li><li><code>1.0.0</code></li><li><code>1.0.1</code></li><li>……</li></ol><h2 id="依赖的版本号标记法"><a href="#依赖的版本号标记法" class="headerlink" title="依赖的版本号标记法"></a>依赖的版本号标记法</h2><p>我们广泛使用的 NPM 本身也遵从 SemVer 版本号命名，除了包版本本身的定义之外，最重要的是对三方包依赖的版本号的定义，不当的写法将导致一系列潜在的问题。</p><h3 id="指定可用的版本号范围"><a href="#指定可用的版本号范围" class="headerlink" title="指定可用的版本号范围"></a>指定可用的版本号范围</h3><p>在 NPM 包的 deps 系列字段中，经常出现形如 <code>~1.0.4</code>、<code>^2.1.1</code> 这样的标记法，这种标记法标记的是「版本号范围（version range）」，它表示依赖的三方包其版本号只要落在定义版本号范围内，即算合法。另外，当运行 <code>npm update</code> 时，依赖的包将升级到版本号范围支持的最高版本。</p><p>版本号范围的标记符号有很多种，诸如比较符号 <code>&gt;=</code>、<code>&lt;</code> 等；连接符 <code>-</code>；通配符 <code>x</code>、<code>*</code>；模糊符 <code>^</code>、<code>~</code>。具体的用法可参考 NPM 官方文档，这里仅给出常用的标记方式。</p><table><thead><tr><th>含义</th><th>最简</th><th>通配符</th><th>模糊符</th><th>版本号范围</th></tr></thead><tbody><tr><td>仅跟进修复版本</td><td><code>1.0</code></td><td><code>1.0.x</code></td><td><code>~1.0.4</code></td><td><code>&gt;=1.0.4 &lt;1.1.0</code></td></tr><tr><td>跟进每个小版本更新</td><td><code>1</code></td><td><code>1.x</code>、<code>1.x.x</code></td><td><code>^1.0.4</code></td><td><code>&gt;=1.0.4 &lt;2.0.0</code></td></tr><tr><td>始终升级到最新版</td><td><code>*</code></td><td><code>*</code></td><td><code>*</code></td><td><code>&gt;=0.0.0</code></td></tr></tbody></table><p>我们建议在写法上采用 <strong>「使用通配符的写法」</strong>，并且一般情况下 <strong>「跟进每个小版本更新」</strong>，但 <strong>不「始终升级到最新版」</strong>，即书写为 <code>1.x</code>。由于 <code>&lt;major&gt;</code> 位版本是不向下兼容的，所以在大版本的控制上，仍然采用人为干预以保证安全。</p><h3 id="不同的-deps-字段"><a href="#不同的-deps-字段" class="headerlink" title="不同的 deps 字段"></a>不同的 deps 字段</h3><p>NPM 包中的依赖有几种形式的字段：<code>dependencies</code>、<code>devDependencies</code>、<code>peerDependencies</code>。以下简要介绍下各字段的不同含义，以及使用场景。</p><table><thead><tr><th>字段</th><th>含义</th><th>依赖被安装的时机</th><th>使用场景</th></tr></thead><tbody><tr><td><code>dependencies</code></td><td>运行时依赖，包的调用者需要使用到的依赖</td><td>执行 <code>npm install</code> 后会把当前包的<code>dependencies</code> 字段中的所有依赖项安装到 <code>./node_modules</code> 目录。 执行 <code>npm install xxx</code> 后会把 xxx 安装到 <code>./node_modules</code> 下，同时会安装 xxx 的 <code>dependencies</code> 字段依赖项到<code>./node_modules/xxx/node_modules</code> 目录。  执行 <code>npm install xxx --save</code> 后会额外把 xxx 作为依赖存到当前包的<code>dependencies</code> 字段中。</td><td>所有程序运行需要用到的依赖代码，如 lodash 等。</td></tr><tr><td><code>devDependencies</code></td><td>开发时依赖，包的开发维护者需要使用到的依赖</td><td>执行 <code>npm install</code> 后也会把当前包的<code>devDependencies</code> 字段中的所有依赖项安装到 <code>./node_modules</code> 目录。 执行 <code>npm install xxx</code> 后会把 xxx 安装到 <code>./node_modules</code> 下，但不会安装 xxx 的 <code>devDependencies</code> 字段依赖项。  执行 <code>npm install xxx --save-dev</code> 后会额外把 xxx 作为开发时依赖存到当前包的<code>devDependencies</code> 字段中。</td><td>一般是一些开发调试的辅助工具，如测试工具 mocha、构建工具 gulp 等。</td></tr><tr><td><code>peerDependencies</code></td><td>略</td><td>略</td><td>仅在 特定场景 下有用，默认不使用此字段。</td></tr></tbody></table><p><strong>转载声明</strong>：本文转自「汇智网」<a href="http://mp.weixin.qq.com/s?__biz=MzI3MDAxODk0Ng==&mid=2650015847&idx=1&sn=22cbdc5f33b1b0fa10240fe7bea88bd4&mpshare=1&scene=23&srcid=0725qNBZrEO9h8NP3svRmdGp#rd">论版本号的正确打开方式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;版本号的正确打开方式&quot;&gt;&lt;a href=&quot;#版本号的正确打开方式&quot; class=&quot;headerlink&quot; title=&quot;版本号的正确打开方式&quot;&gt;&lt;/a&gt;版本号的正确打开方式&lt;/h1&gt;&lt;p&gt;版本号广泛运用于开发的各种场景：NPM 包的版本定义、对 NPM 包的特定版</summary>
      
    
    
    
    <category term="NPM" scheme="http://example.com/categories/NPM/"/>
    
    <category term="版本号" scheme="http://example.com/categories/NPM/%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
    
    <category term="npm" scheme="http://example.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>简单的一份2021年终回顾</title>
    <link href="http://example.com/2021/12/08/sayByeTo2021/"/>
    <id>http://example.com/2021/12/08/sayByeTo2021/</id>
    <published>2021-12-08T08:07:32.000Z</published>
    <updated>2021-12-16T13:43:34.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先对自己来个自我坦白，没写过总结，更没写过年度总结，得写😣！<br>写下这篇总结最主要的缘由，可能是因为在“回头”时，突然看不到自己曾走过的路👣，实属惭愧。<br>如果要用一句话来介绍一下自己，那么： “一个毫不起眼的菜鸡小前端”罢了。</p><h1 id="我的2021"><a href="#我的2021" class="headerlink" title="我的2021"></a>我的2021</h1><p>如果要按照时间去划分区块的话，<strong>校园生活</strong>和<strong>实习生活</strong>很平均的分割了我的这过去的365天📅。</p><h2 id="校园生活📖"><a href="#校园生活📖" class="headerlink" title="校园生活📖"></a>校园生活📖</h2><h3 id="课程之内"><a href="#课程之内" class="headerlink" title="课程之内"></a>课程之内</h3><p>2021年的主要校园生活也就是“生产性实训”了吧，现在想想那时候的时间可真的珍贵，每天都是大把大把的自由时间，有一个全能的老师“手摸手”带着做项目，也没有好好的“汲取”到整个开发的精髓。可能总觉得依旧是课堂，依旧是老师授课，所以态度也一直是”校园叛逆风”（课堂上执拗性的不好好听，课下忙里偷闲逐字恶补）吧😭。</p><p>唯一庆幸的就是自己在实训过程中，提前确定下来了发展方向，拨开了”乱花渐欲迷人眼“的各种技术栈，选择了Vue，从各方面吸收别人的开发经验补充自己，也感谢自己当时可以不厌其烦的一直去“啃”它，虽然进展现在看起来挺慢挺笨的。从另一个角度去看，也没有完整的”Java全栈”这堂较为完善的实训路线（抱歉各位老师了😖）。</p><p>最后还有一个小惊喜，或者说意外吧，就是又一次的拿到了”校三好学生“这个荣誉，着实是个surprise😊。</p><h3 id="课程之外"><a href="#课程之外" class="headerlink" title="课程之外"></a>课程之外</h3><p>值得欣慰的可能就是在上半年预瞻了我的下半年，所以尤其珍惜上半年在学校的日子。</p><p>学校今年改变最大的就是饮食条件了吧，虽然用些许的“华而不实”来评价，但是能看出来还是为了我们花了很大的心思，每顿都尽量尝试不同的窗口饭菜，感受不同阿姨打饭时的“抖抖”大法，毕竟大概率都是最后一顿了吧…👅</p><p>另一个改变就是新大楼的建成，也十分的庆幸我们可以作为“先锋军”提前入驻了大楼学习，提前尝鲜了师大目前可以提供的最高规格教学条件，还有那即将竣工的东区运动场地，感觉每一届毕业生都要为，没赶上母校来年的美好建设而遗憾呢？且学且受且珍惜啊…💪</p><p>最后的遗憾就是“大创”(河南师范大学大学生创新创业基地)没了，这个除了宿舍之外，一个可以24h遮风挡雨的“革命根据地”没了，实属是令人无奈…😔</p><h2 id="实习生活🔧"><a href="#实习生活🔧" class="headerlink" title="实习生活🔧"></a>实习生活🔧</h2><h3 id="再回首都"><a href="#再回首都" class="headerlink" title="再回首都"></a>再回首都</h3><p>在网络世界的各种机缘巧合，以及千转百绕的脉络中，看到了定位于”中国心理应用行业引导者“公司的一则招聘消息。当时由于自身非技术外的一些条件限制，吃了几次结结实实的闭门羹😥，但是不知道哪里来的勇气，追着换来了一次面试机会，当时为了抓住这个”稻草”，两天两夜的时间针🗡都扎不进去，最后的结果当然也是如尝所愿~😃。(现在拿着结果回顾的话，简单两方面，一是自己几段班长经历和对心理学的兴趣驱使着，另一方面就是技术总监的评价：足够的积极和主动去寻求进步机会)。</p><p>在京实习的整整四个月，说实话真的是转瞬即逝，没有一点点的防备时间就没了，但另一方面看也是收获颇丰。当时公司前端的技术栈就是纯Vue开发，和我当时定下来去啃的方向不谋而合，所以也在适应两天环境后，直接就投入了实际的项目开发之中(感谢小组长的信任😬)。</p><p>项目简单的概括就是一个关于”校园心理调研“的Saas产品，但从技术上去看，实现产品的过程中，也几乎全面覆盖了Vue的所有知识点💯，而在此之前自己的所有项目，都是在各种网站上买的课程，到了实际的工作开发之中才知道，真正的产品到底是何种”面貌“。这段经历也让我在一方面，逐渐的从一个”学生“身份向”职场“身份转变，这其中点点滴滴的认识也是所有即将面临毕业的学生，一份珍贵且难以复刻的财富💴，希望有同样经历的朋友可以试着好好的品味一下~</p><p>如今在技术上再次回顾彼时，由于认知尚浅且技术水平局限，所以很多时候都是为了某一个小功能的实现而去考虑代码该如何去书写这种工作方式，不知不觉间也剥离了除代码外的各种思考空间。但是说实话，也不知道从”学生“向”职场的转变过程中，到底以何种心态何种方式才算是合理？😕也许，这也可以是一个比较“吃香”的话题？</p><p>除了实习工作之外，也有挺多挺多的收获：结识了各方面突出且拔尖的朋友👬、品尝了带着京味儿的各国美食、复游了三年前曾走过的旅游景点🏕、点上了已丢弃多年的烹饪技能、捡起了游泳技能包以及初嗅了拳击运动🏊…</p><h3 id="逃京赴杭"><a href="#逃京赴杭" class="headerlink" title="逃京赴杭"></a>逃京赴杭</h3><p>北京！首都！追溯到三年之前，当时不顾一切的向它奔去，没想到再次返京一段时间后却萌生出了一种类似逃跑的狼狈心态…💨</p><p>主要是考虑到了自身未来“根据地”的选择🏠，这也实属不是一件容易的事儿，我当时是这样去考虑的：</p><table><thead><tr><th align="center">北京(X)/杭州(O)</th><th align="center">腰包厚度</th><th align="center">机遇挑战</th><th align="center">交际圈</th><th align="center">出行+牌照</th><th align="center">居住+户口</th><th align="center">健康程度</th><th align="center">亲人关系</th></tr></thead><tbody><tr><td align="center"><strong>毕业首年</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center">✔</td><td align="center">〰</td><td align="center"><strong>X</strong></td></tr><tr><td align="center"><strong>工作三年后</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center"><strong>工作五年后</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center"><strong>X</strong></td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center"><strong>成家立业</strong></td><td align="center">✔</td><td align="center"><strong>X</strong></td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td></tr></tbody></table><p>简单的根据上述表格，在横向与纵向的交叉对比中，在理想与现实的心里博弈中，选择了奔赴杭州。</p><p>在决定了根据地之后，就极度的缩小了目标范围。9月，也就是在那是遇到了定会改变我未来人生轨迹的”大哥“大哥。（插一句：对于每个人人生的不同阶段，都有一个特定的十字路口，亦或沼泽之境🕳，如果能有贵人指引或者拉上一把…） 对于那时的我来说，机会就是药，而好的机会就是一剂特效药。之后就是遗憾式的告别，期盼式的迎接，北京与杭州也就在此刻割裂开来~👋</p><p><strong>新的开始</strong>，一切都是值得期待，但另一方面，也都是蜕皮之苦…<br>但从技术层面来说，再也没有熟悉的Vue了，也几乎没有什么老本可以吃了，以至于在开始一段时间内，一度的认为就是纯纯的傻子一个🤡，思前想后也不知道自己现在到底会点什么，能做点什么，下一步又该怎麽做？陷入黑暗之地，要破罐破摔吗？</p><p>要么自己变成光，要么就去寻找光。<br>很幸运，这里对新人的安排就是导师制，新环境的任何方面如果有问题，都会给予及时的指引和教导。当然，虽然不知道他人的导师如何，但我的导师“彦祖”绝对不差于其他人🙇‍。当很多时候在技术的泥泞之中挣扎，在别人看来可能就是一个简单的小问题罢了，顿悟后的豁然开朗真的早已浸透身心。现在再去回顾上半年的实训课程，感触良多，可能这就是成长吧…有那么霎那之间，感觉自己很幸运，总有贵人在最需要的时刻伸出了援手。</p><p>现在看来，新技术栈去实现一些基础的业务场景，也已手到擒来，庆幸自己没有放弃自己，庆幸周围有你，有你们💜~</p><p><strong>新的改变</strong>，相较于身体，更多的是心理…<br>初中、高中、大学、直到上次实习，也都是和他人住在一起。而现在，一个人一个房间的独居生活，属实是顶不住，独在异乡的孤独，寂静，落寞，每当夜幕低垂之时，贯彻身心，更多的是在精神上给予极度寂静的攻击，这种情况在一开始的两周之后变得愈发可怕。其实对镜自问感觉自己相对于很多人已经是独立很多了，但是当”安静“袭来之时，还是不知道如何防御🛡。</p><p>要么改变环境，要么适应环境。<br>一个人孤独基调已经定下，所以可选项也只剩下了适应（目前感觉挺好）。独自尝试过很多的方式，有赖在公司不回去、有下回抖某软件忘却时间、有翻遍影视排行榜、也有白酒麻痹身体…到头来发现最好的方式原来就是：安排时间！下边就是上周五对周六周日的一个简单规划📅：</p><table><thead><tr><th></th><th>上午</th><th>下午</th><th>晚上</th></tr></thead><tbody><tr><td><strong>周六</strong></td><td>睡大觉，谁来也不行</td><td>年终总结写完实习</td><td>把本周欠下的视频和剧悉数补上</td></tr><tr><td><strong>周日</strong></td><td>睡小觉，看NBA比赛</td><td>洗澡洗衣服外出蹭饭</td><td>刷会儿热点跟上时代，早睡</td></tr></tbody></table><p>简单来说，就是周六周日均分为四大块，每一大块每周五的时候进行用一些特定计划去填充它，到时候岂不只剩下了执行？</p><h2 id="个人感悟👀"><a href="#个人感悟👀" class="headerlink" title="个人感悟👀"></a>个人感悟👀</h2><p>如果把21年从中间横刀切开来看，下半年各方面的成长速度完全碾压上半年…🚀</p><h3 id="改变伊始"><a href="#改变伊始" class="headerlink" title="改变伊始"></a>改变伊始</h3><p>打击人的永远是现实，锻炼人的永远是实践。<br>在今年的五月底，我属实按捺不住内心想出去实习的冲动，毅然决然的奔向北京，120天的实习，切实感受到了项目商用和自己捯饬的区别，也感受到了团队开发配合的重要性，更能理解作为导师带人的心路历程。这期间，做的项目是一个Saas产品，其中也参与了不少核心的模块开发，现在回想起来，特别感谢团队成员和组长对我的信任✨。</p><p>4个月说短也不短，说长却又转瞬即逝，每天的时间和精力都环绕在各种业务场景的思考，各种具体的实现逻辑，各种体验与感受考虑，可能对于我来说，什么都是新的，什么都是陌生的，每天都有着各式各样新鲜的刺激源出现，每时每刻都能感受到自己的改变，但从技术上去看，终于切身的理解到了理论和实践的区别，逐渐摸索到了理论跳向实践的思维方式，这可能是无法言语的一种愉悦和成长吧🤔？</p><p>从各个维度上去看，收获真的颇丰，从一个初入职场毫无经验的小白，接触到了企业完整的开发流程，以及企业上对于项目的各种开发规范，从独立学习单线程开发到团队配合多路并行开发，从一个毫无职场经验的菜鸟成长为可以带一个零基础实习生成长，从校园的懵懂无知社会阅历一片空白到深谙社会普遍现象浅尝职场风云的新届“车手”…😎</p><h3 id="逐步蜕变"><a href="#逐步蜕变" class="headerlink" title="逐步蜕变"></a>逐步蜕变</h3><p>现实，永远是逼着你改变方向的一把枪。<br>独赴首都的几个月，在社会与现实的洗礼下，经历了一段思想和精神上的激烈博弈，最终也在一定程度上规划了自己未来的发展方向或者说是现实轨迹？不知道若干年以后，当我再次打开这篇文章，在未来的某个静谧的午后回顾此时，会不会对我现在就向现实屈服的行为感到可笑？但至少现在看起来，没问题！🆗</p><p>杭州，一个三年前独游的互联网之乡；税友，一个当时从未听闻过的传统企业。没想到在各种机缘巧合之下却偷偷的互生了情愫，也许是一个人？也许是一篇文章？也许，是一座城？总之，税友俺来了！</p><p><strong>蹒跚学步在襁褓</strong>，刚入职的时候来到了公共基础服务团队，与其说是团队（前端），不如说是一枝独秀百花枯？！带我的导师是基础服务团队唯一一个前端开发，来到工位还没等坐下，看到他打开的vsCode上鳞次栉比的项目，密密麻麻的代码，突然间心里边猛的一揪，竟有些许的怕了起来？五味杂陈的情绪也在暗中作祟并逐渐的提到了胸口之上。最开始了解的就是主要技术栈：React Hooks、TypeScript，哇！好耳熟啊，但是完全不会…！然后就开始请教该如何入门，开始学习如何“拼写”这些技术栈。起初因为除了技术之外，很多的项目都有着很宽泛的前置知识，所以导师也是没有让我去替他分担一些东西，主要就是安排学习任务以“迎接”即将到来的新项目😬。</p><p><strong>遍体鳞伤为起跑</strong>，新项目来了，可笑的是，我当时竟然还没有产生一丝丝的担心，可是意外总是比现实来的更为突然：日常迭代多，资源紧缺，人手不足，时间迫切，评估偏差…感觉一时间五花八门，妖魔鬼怪似的问题都涌现出来了。其实最主要的原因是出在我身上，没有足够的技术能力去分担和承受部分生产压力所造成的，也就是这样，逼着自己不得不去学习，不得不去请教，不得不去想办法提高自己，这可能就是我在某一段时间比较“卷”的原因吧😡？</p><p><img src="/images/sayByeTo2021/image-20211216211418878.png" alt="image-20211216211418878"></p><p><img src="/images/sayByeTo2021/image-20211216211454233.png" alt="image-20211216211454233"></p><p>不得不说，很多时候人都是被逼出来的，开始的时候遇到各种问题都有着导师“手摸手”的进行指导，有了依靠就不想努力的惯性思维使得任何人都躲不过去，可是终究是有一天要独立去工作的，况且自己也是刚经历过带新人，深谙导师的角色在其中的弯弯绕绕与千转回肠。遇到问题之后先尝试独立思考，用脑子去摸索一边，解决不了带着思考请教，这样才是正解。</p><p><strong>内外兼修辅长跑</strong>，深知任何一个行业，任意一份工作，随时都会因为一些不可控的各种因素而发生波动，只有在从事行业的的根源上去让自己变得更强，才能应对时间长河里出现的各种问题。只是因为有些东西我们是掌握不了也改变不了的，比如时间，所以只能逼迫自己去不断学习，并保持适当的危机感。当然身体永远还是第一位的，接下来的首要目标就是保持锻炼💪，早点休息，牢牢的将革命本钱攥在手心，毕竟持续一段不到七个小时的睡眠时间身体顶不住。</p><h3 id="展望成蝶"><a href="#展望成蝶" class="headerlink" title="展望成蝶"></a>展望成蝶</h3><p>暂且先留在心间吧~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;先对自己来个自我坦白，没写过总结，更没写过年度总结，得写😣！&lt;br&gt;写下这篇总结最主要的缘由，可能是因为在“回头”时，突然看不到自己曾走过</summary>
      
    
    
    
    <category term="总结" scheme="http://example.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    <category term="年度总结" scheme="http://example.com/categories/%E6%80%BB%E7%BB%93/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年度总结" scheme="http://example.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>在React中使用TypeScript</title>
    <link href="http://example.com/2021/10/24/react-ts/"/>
    <id>http://example.com/2021/10/24/react-ts/</id>
    <published>2021-10-24T06:02:33.000Z</published>
    <updated>2021-10-28T08:12:54.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件声明"><a href="#组件声明" class="headerlink" title="组件声明"></a>组件声明</h2><p>在React中，组件的声明方式有两种：<strong>函数组件</strong>和<strong>类组件，</strong> 来看看这两种类型的组件声明时是如何定义TS类型的。</p><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>类组件的定义形式有两种：<code>React.Component&lt;P, S=&#123;&#125;&gt;</code> 和 <code>React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;</code>，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有时可以省略：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">IProps</span>, <span class="title">IState</span>&gt; </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;this.state.count&#125;</span></span><br><span class="line"><span class="xml">        &#123;this.props.name&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>React.PureComponent&lt;P, S=&#123;&#125; SS=&#123;&#125;&gt;</code> 也是差不多的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span>&lt;<span class="title">IProps</span>, <span class="title">IState</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><code>React.PureComponent</code>是有第三个参数的，它表示<code>getSnapshotBeforeUpdate</code>的返回值。</p><blockquote><p>那PureComponent和Component 的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate 是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。</p></blockquote><p>那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span>&lt;<span class="title">P</span>&gt; <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">P</span>&gt; </span>&#123;</span><br><span class="line">  <span class="attr">internalProp</span>: P;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props: P</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.internalProp = props;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line"><span class="keyword">type</span> IProps = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;React&quot;</span> age=&#123;<span class="number">18</span>&#125; /&gt;;          <span class="comment">// Success</span></span><br><span class="line">&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;TypeScript&quot;</span> age=<span class="string">&quot;hello&quot;</span> /&gt;;  <span class="comment">// Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">(<span class="params">props: IProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;name&#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除此之外，函数类型还可以使用<code>React.FunctionComponent&lt;P=&#123;&#125;&gt;</code>来定义，也可以使用其简写<code>React.FC&lt;P=&#123;&#125;&gt;</code>，两者效果是一样的。它是一个泛型接口，可以接收一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> React.FC&lt;P = &#123;&#125;&gt; = React.FunctionComponent&lt;P&gt;</span><br></pre></td></tr></table></figure><p>最终的定义形式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;IProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;name&#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Child1和Child2组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Child1 <span class="keyword">from</span> <span class="string">&quot;./child1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Child2 <span class="keyword">from</span> <span class="string">&quot;./child2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> App: React.FC&lt;IProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Child1</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Child2</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      TypeScript</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Child1</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Child1组件结构如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Child1: React.FC&lt;IProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, children &#125; = props;</span><br><span class="line">  <span class="built_in">console</span>.log(children);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello child1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Child1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：</p><p><img src="/images/react-ts/image-20211027145219797.png" alt="image-20211027145219797"></p><p>使用 React.FC 声明函数组件和普通声明的区别如下：</p><ul><li>React.FC 显式地定义了返回类型，其他方式是隐式推导的；</li><li>React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；</li><li>React.FC 为 children 提供了隐式的类型（ReactElement | null）。</li></ul><p>那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>&lt;<span class="title">P</span>&gt;(<span class="params">props: P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;props&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组件</span></span><br><span class="line"><span class="keyword">type</span> IProps = &#123; <span class="attr">name</span>: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;React&quot;</span> age=&#123;<span class="number">18</span>&#125; /&gt;;          <span class="comment">// Success</span></span><br><span class="line">&lt;MyComponent&lt;IProps&gt; name=<span class="string">&quot;TypeScript&quot;</span> age=<span class="string">&quot;hello&quot;</span> /&gt;;  <span class="comment">// Error</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：</p><p><img src="/images/react-ts/image-20211027152037738.png" alt="image-20211027152037738"></p><p>如果已知state 的类型，可以通过以下形式来自定义state的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>如果初始值为null，需要显式地声明 state 的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState&lt;<span class="built_in">number</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>); </span><br></pre></td></tr></table></figure><p>如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [user, setUser] = React.useState&lt;IUser&gt;(&#123;&#125; <span class="keyword">as</span> IUser);</span><br></pre></td></tr></table></figure><p>实际上，这里将空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user 的值，否则就会报错。</p><blockquote><p>根据useState在类型声明文件中的定义：定义两种形式，分别是有初始值和没有初始值的形式。</p></blockquote><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>useEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让我们可以控制何时运行函数来处理副作用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscription.unsubscribe();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [props.source]</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当函数的返回值不是函数或者effect函数中未定义的内容时，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      subscribe();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TypeScript就会报错：</p><p><img src="/images/react-ts/image-20211027152509367.png" alt="image-20211027152509367"></p><blockquote><p>根据useEffect在类型声明文件中的定义：useEffect的第一个参数只允许返回一个函数。</p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><p>useContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ColorContext = React.createContext(&#123; <span class="attr">color</span>: <span class="string">&quot;green&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; color &#125; = useContext(ColorContext);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color</span> &#125;&#125;&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IColor &#123;</span><br><span class="line"><span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ColorContext = React.createContext&lt;IColor&gt;(&#123; <span class="attr">color</span>: <span class="string">&quot;green&quot;</span> &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="import-React"><a href="#import-React" class="headerlink" title="import React"></a>import React</h3><p>在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就需要在tsconfig.json配置文件中进行如下配置：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 允许默认从没有默认导出的模块导入。</span></span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Types-or-Interfaces？"><a href="#Types-or-Interfaces？" class="headerlink" title="Types or Interfaces？"></a>Types or Interfaces？</h3><p>我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：</p><ul><li>在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用最通过声明合并来扩展它们；</li><li>在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。</li></ul><p>interface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type 可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以继续在原属性基础上，添加新属性：color</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type类型不支持属性扩展</span></span><br><span class="line"><span class="comment">// Error: Duplicate identifier &#x27;Animal&#x27;</span></span><br><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>type对于联合类型是很有用的，比如：type Type = TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件声明&quot;&gt;&lt;a href=&quot;#组件声明&quot; class=&quot;headerlink&quot; title=&quot;组件声明&quot;&gt;&lt;/a&gt;组件声明&lt;/h2&gt;&lt;p&gt;在React中，组件的声明方式有两种：&lt;strong&gt;函数组件&lt;/strong&gt;和&lt;strong&gt;类组件，&lt;/strong&gt;</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    <category term="React+Ts" scheme="http://example.com/categories/React/React-Ts/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://example.com/2021/10/02/React-lifeCycle/"/>
    <id>http://example.com/2021/10/02/React-lifeCycle/</id>
    <published>2021-10-02T03:31:14.000Z</published>
    <updated>2021-10-27T06:18:26.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><p><img src="/images/React-lifeCycle/react-lifecycle.jpg" alt="reactLifecycle"></p><h2 id="挂载卸载过程"><a href="#挂载卸载过程" class="headerlink" title="挂载卸载过程"></a>挂载卸载过程</h2><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h3><p>constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。<br> 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误</p><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount()"></a>componentWillMount()</h3><p>componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。</p><h3 id="render（）"><a href="#render（）" class="headerlink" title="render（）"></a>render（）</h3><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><p>组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染</p><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount ()"></a>componentWillUnmount ()</h3><p>在此处完成组件的卸载和数据的销毁。</p><ol><li>clear你在组建中所有的setTimeout,setInterval</li><li>移除所有组建中的监听 removeEventListener</li><li>有时候我们会碰到这个warning:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can only update a mounted or mounting component. This usually      means you called setState() on an unmounted component. This is a   no-op. Please check the code <span class="keyword">for</span> the undefined component.</span><br></pre></td></tr></table></figure><p>原因：因为你在组件中的ajax请求返回setState，而你<strong>组件销毁的时候，请求还未完成</strong>，因此会报warning<br>解决方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isMount === <span class="literal">true</span></span><br><span class="line">    axios.post().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isMount &amp;&amp; <span class="built_in">this</span>.setState(&#123;   <span class="comment">// 增加条件ismount为true时</span></span><br><span class="line">      <span class="attr">aaa</span>:res</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isMount === <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps (nextProps)"></a>componentWillReceiveProps (nextProps)</h3><ol><li>在接受父组件改变后的props需要重新渲染组件时用到的比较多</li><li>接受一个参数nextProps</li><li>通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  componentWillReceiveProps (nextProps) &#123;</span><br><span class="line">    nextProps.openNotice !== <span class="built_in">this</span>.props.openNotice&amp;&amp;<span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        <span class="attr">openNotice</span>:nextProps.openNotice</span><br><span class="line">    &#125;，() =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.openNotice:nextProps)</span><br><span class="line">      <span class="comment">//将state更新为nextProps,在setState的第二个参数（回调）可以打印出新的state</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h3><ol><li>主要用于性能优化(部分更新)</li><li>唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新</li><li>因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断</li></ol><h3 id="componentWillUpdate-nextProps-nextState"><a href="#componentWillUpdate-nextProps-nextState" class="headerlink" title="componentWillUpdate (nextProps,nextState)"></a>componentWillUpdate (nextProps,nextState)</h3><p>shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。</p><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p>render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。</p><h3 id="componentDidUpdate-prevProps-prevState"><a href="#componentDidUpdate-prevProps-prevState" class="headerlink" title="componentDidUpdate(prevProps,prevState)"></a>componentDidUpdate(prevProps,prevState)</h3><p>组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。</p><blockquote><p>说实话，钱给了我大部分的安全感，当我想要一件东西时，打开钱包一看，钱够。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React生命周期&quot;&gt;&lt;a href=&quot;#React生命周期&quot; class=&quot;headerlink&quot; title=&quot;React生命周期&quot;&gt;&lt;/a&gt;React生命周期&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/React-lifeCycle/react-li</summary>
      
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    <category term="基础" scheme="http://example.com/categories/React/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
    <category term="生命周期" scheme="http://example.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>前端面试exp02</title>
    <link href="http://example.com/2021/09/23/interview-exp02/"/>
    <id>http://example.com/2021/09/23/interview-exp02/</id>
    <published>2021-09-23T13:50:13.000Z</published>
    <updated>2021-09-23T14:24:10.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><h2 id="项目介绍-做什么的"><a href="#项目介绍-做什么的" class="headerlink" title="项目介绍(做什么的)"></a>项目介绍(做什么的)</h2><h2 id="平台用户角色不同权限怎么做校验"><a href="#平台用户角色不同权限怎么做校验" class="headerlink" title="平台用户角色不同权限怎么做校验"></a>平台用户角色不同权限怎么做校验</h2><h2 id="复制已登录角色链接到其他浏览器，会发生什么"><a href="#复制已登录角色链接到其他浏览器，会发生什么" class="headerlink" title="复制已登录角色链接到其他浏览器，会发生什么"></a>复制已登录角色链接到其他浏览器，会发生什么</h2><h2 id="如何拆分和设计组件"><a href="#如何拆分和设计组件" class="headerlink" title="如何拆分和设计组件"></a>如何拆分和设计组件</h2><p>1、使用的场景：不同的场景需求也不一样</p><p>2、组件对外暴露的字段</p><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><h2 id="继承的设计上，是为了方便什么"><a href="#继承的设计上，是为了方便什么" class="headerlink" title="继承的设计上，是为了方便什么"></a>继承的设计上，是为了方便什么</h2><p>1、简单来说是为了更好复用代码</p><p>2、js怎么实现封装和继承</p><h2 id="对MVVM框架的理解"><a href="#对MVVM框架的理解" class="headerlink" title="对MVVM框架的理解"></a>对MVVM框架的理解</h2><p>vm是连接视图层和数据层的桥梁</p><h2 id="双向绑定的原理"><a href="#双向绑定的原理" class="headerlink" title="双向绑定的原理"></a>双向绑定的原理</h2><p>数据劫持，监听-发布类</p><h2 id="vue中的key是做什么用的"><a href="#vue中的key是做什么用的" class="headerlink" title="vue中的key是做什么用的"></a>vue中的key是做什么用的</h2><p>diff算法简述</p><h2 id="vue不能对数组中的某一个数组进行变更原因"><a href="#vue不能对数组中的某一个数组进行变更原因" class="headerlink" title="vue不能对数组中的某一个数组进行变更原因"></a>vue不能对数组中的某一个数组进行变更原因</h2><p>MVVM框架，数据操作视图。对data对象中的数据进行监听，当侦测到数据改变时相应数据所影响的页面也会触发更新。所以我们所需要的这些响应式数据，受到javascript的限制，vue不能检测到对象属性的添加或删除，因为Vue利用的是Object的defineProperty()方法，在初始化实列时将属性转为getter/setter，所以属性必须在data对象上才能让vue转换它。<br> 当然这只是一般的属性，以一般字符串，数字，布尔值这样的基本数据类型作为属性值的响应，当然我们有时候的诉求的初始化属性的属性值不只有这样的基本数据变量，我们还会用到数组，对象这样的引用数据变量。引用数据变量就是对地址的引用，只是对象的指针发生变化，并没有重新生成一个对象</p><h2 id="数组内部元素更新，没有触发重绘"><a href="#数组内部元素更新，没有触发重绘" class="headerlink" title="数组内部元素更新，没有触发重绘"></a>数组内部元素更新，没有触发重绘</h2><h2 id="栈和堆的理解"><a href="#栈和堆的理解" class="headerlink" title="栈和堆的理解"></a>栈和堆的理解</h2><p>声明用栈，new用堆<br>所有的变量都是在栈里面存的<br>对象在堆里面存的<br>所有的对象都是通过地址引用到栈里面的</p><p>简单点理解栈里存放着局部变量，堆里存放着所有new出来的东西。<br>而两者可是实现关联是因为堆里面带着栈的内存地址。</p><p>堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。</p><p>栈是先进后出的，但是于堆而言却没有这个特性，两者都是存放临时数据的地方。 对于堆，我们可以随心所欲的进行增加变量和删除变量</p><h2 id="js如何实现一个栈"><a href="#js如何实现一个栈" class="headerlink" title="js如何实现一个栈"></a>js如何实现一个栈</h2><h2 id="rem和em的区别是什么"><a href="#rem和em的区别是什么" class="headerlink" title="rem和em的区别是什么"></a>rem和em的区别是什么</h2><h2 id="flex-grow是什么意思"><a href="#flex-grow是什么意思" class="headerlink" title="flex-grow是什么意思"></a>flex-grow是什么意思</h2><p>父元素flex布局宽度500px，有三个子元素，宽度都是100px，同时flex-grow 为 1 1 2，计算子元素真实宽度。</p><h2 id="position有哪些，特点"><a href="#position有哪些，特点" class="headerlink" title="position有哪些，特点"></a>position有哪些，特点</h2><p>static：所有元素在默认的情况下position属性均为static</p><p>relative：相对于自身定位，移动</p><p>absolute：相对于第一个非static方式定位</p><p>fixed：浏览器根元素固定为浏览器窗口</p><h2 id="盒模型宽度计算"><a href="#盒模型宽度计算" class="headerlink" title="盒模型宽度计算"></a>盒模型宽度计算</h2><h2 id="https的加密解密过程"><a href="#https的加密解密过程" class="headerlink" title="https的加密解密过程"></a>https的加密解密过程</h2><h2 id="promise用的多吗，没用…"><a href="#promise用的多吗，没用…" class="headerlink" title="promise用的多吗，没用…"></a>promise用的多吗，没用…</h2><h2 id="实现一个多维数组求和"><a href="#实现一个多维数组求和" class="headerlink" title="实现一个多维数组求和"></a>实现一个多维数组求和</h2><p>const arr = [1,2,3,[1,2,[3]]]</p><p>求最后1+2+3+1+2+3的和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">        arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">                sum += total(item); <span class="comment">//递归去处理数组元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += item</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(total([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>]]])) <span class="comment">// 45</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h2&gt;&lt;h2 id=&quot;项目介绍-做什么的&quot;&gt;&lt;a href=&quot;#项目介绍-做什么的&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="FE-Interview" scheme="http://example.com/categories/FE-Interview/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制09</title>
    <link href="http://example.com/2021/08/24/vue2-core09/"/>
    <id>http://example.com/2021/08/24/vue2-core09/</id>
    <published>2021-08-24T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:14.387Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自<a href="https://www.kancloud.cn/sllyli/vuejs">看云</a>《剖析vue.js内部运行机制》</p><h2 id="总结-amp-常见问题解答"><a href="#总结-amp-常见问题解答" class="headerlink" title="总结 &amp; 常见问题解答"></a>总结 &amp; 常见问题解答</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本小册的第一节中，笔者对 Vue.js 内部运行机制做了一个全局的概览，当时通过下面这张图把 Vue.js 拆分成一个一个小模块来介绍，之后通过这一系列小节的学习，相信大家已经对 Vue.js 内部的原理有了一个更进一步的了解，对这张图也再也不会感觉到那么陌生。</p><p><img src="https://img.kancloud.cn/01/db/01db136b4380b1804c072899e92daa3d_1752x1216.gif" alt="img"></p><p>每个小节中的代码都是笔者根据 Vue.js 原理单独抽离出来写成的 Demo，大家可以在我的 <a href="https://github.com/answershuto">Gtihub</a> 上查看完整的代码 (见 <a href="https://github.com/answershuto/VueDemo">VueDemo</a> 项目)。</p><p>本小册对 Vue.js 原理进行了初步的介绍，希望能够起到一个抛砖引玉的作用，读者读完以后，可以利用这些基础对 Vue.js 进行一个更加深入的探索，相信会有更大的收获。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>怎么实现 <code>this._test</code> 改变而不是 <code>this._data.test</code> 改变触发更新？</li></ol><p>答：其实这中间有一个<strong>代理</strong>的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_proxy(options.data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_proxy</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(that, key, &#123;</span><br><span class="line">            <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> that._data[key];</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                that._data[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质就是通过 <code>Object.defineProperty</code> 使在访问 <code>this</code> 上的某属性时从 <code>this._data</code> 中读取（写入）。</p><ol><li>能不能将依赖收集中讲到的 <code>dep.addSub(Dep.target)</code> 改成 <code>dep.addSub(new Watcher())</code>呢？</li></ol><p>为了便于读者理解这部分内容，我将代码做了简化，实际上一个 <code>Watcher</code> 对象可能会在多个 <code>Dep</code> 中，并不是每次 <code>addSub</code> 都是一个新的 <code>Watcher</code> 对象，需依赖 <code>Dep.target</code> 进行收集（实际上 <code>Dep.target</code> 也是通过 <code>Watcher</code> 对象的 <code>get</code> 方法调用 <code>pushTarget</code> 将自身赋值给 <code>Dep.target</code>）。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从 2017 年 12 月开始写这本小册到现在差不多 2 个月的时间，虽说之前写过类似的内容，但是将 Vue.js 源码抽离成一个一个 Demo 还是花了很多时间，对于这本小册也是前前后后改了好几次才让自己满意。</p><p>因为读者的基础不一致，而小册的定位是偏向于对新手读者更加友好，所以我尽量用更加浅显易懂的方式去写这本小册的内容。希望大家可以通过这本小册初步掌握 Vue.js 的原理，掌握这些原理以后再去尝试阅读 <a href="https://github.com/vuejs/vue">Vue.js 源码</a>，相信会事半功倍，也会对 Vue.js 有更深一层的理解。</p><p>End</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章转载自&lt;a href=&quot;https://www.kancloud.cn/sllyli/vuejs&quot;&gt;看云&lt;/a&gt;《剖析vue.js内部运行机制》&lt;/p&gt;
&lt;h2 id=&quot;总结-amp-常见问题解答&quot;&gt;&lt;a href=&quot;#总结-amp-常见问题解答&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制08</title>
    <link href="http://example.com/2021/08/21/vue2-core08/"/>
    <id>http://example.com/2021/08/21/vue2-core08/</id>
    <published>2021-08-21T07:17:49.000Z</published>
    <updated>2021-09-17T08:11:05.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex-状态管理的工作原理"><a href="#Vuex-状态管理的工作原理" class="headerlink" title="Vuex 状态管理的工作原理"></a>Vuex 状态管理的工作原理</h2><h2 id="为什么要使用-Vuex"><a href="#为什么要使用-Vuex" class="headerlink" title="为什么要使用 Vuex"></a>为什么要使用 Vuex</h2><p>当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。</p><p><img src="https://img.kancloud.cn/3c/39/3c3996a7b149957fb5aab814bca00147_632x361.gif" alt="img"></p><p>这个时候，我们就需要用到我们的状态管理工具 Vuex 了。Vuex 是一个专门为 Vue.js 框架设计的、专门用来对于 Vue.js 应用进行状态管理的库。它借鉴了 Flux、redux 的基本思想，将状态抽离到全局，形成一个 Store。因为 Vuex 内部采用了 new Vue 来将 Store 内的数据进行「响应式化」，所以 Vuex 是一款利用 Vue 内部机制的库，与 Vue 高度契合，与 Vue 搭配使用显得更加简单高效，但缺点是不能与其他的框架（如 react）配合使用。</p><p>本节将简单介绍 Vuex 最核心的内部机制，起个抛砖引玉的作用，想了解更多细节可以参考笔者 <a href="https://github.com/answershuto">Github</a> 上的另一篇文章 <a href="https://github.com/answershuto/learnVue/blob/master/docs/Vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.MarkDown">《Vuex源码解析》</a>或者直接阅读 <a href="https://github.com/vuejs/vuex">Vuex源码</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Vue.js 提供了一个 <code>Vue.use</code> 的方法来安装插件，内部会调用插件提供的 <code>install</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex);</span><br></pre></td></tr></table></figure><p>所以我们的插件需要提供一个 <code>install</code> 方法来安装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install (_Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;);</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采用 <code>Vue.mixin</code> 方法将 <code>vuexInit</code> 方法混淆进 <code>beforeCreate</code> 钩子中，并用 <code>Vue</code> 保存 Vue 对象。那么 <code>vuexInit</code> 究竟实现了什么呢？</p><p>我们知道，在使用 Vuex 的时候，我们需要将 <code>store</code> 传入到 Vue 实例中去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将store放入Vue创建时的option中*/</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    store</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是我们却在每一个 vm 中都可以访问该 <code>store</code>，这个就需要靠 <code>vuexInit</code> 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">this</span>.$options;</span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store = options.store;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store = options.parent.$store;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为之前已经用<code>Vue.mixin</code> 方法将 <code>vuexInit</code> 方法混淆进 <code>beforeCreate</code> 钩子中，所以每一个 vm 实例都会调用 <code>vuexInit</code> 方法。</p><p>如果是根节点（<code>$options</code>中存在 <code>store</code> 说明是根节点），则直接将 <code>options.store</code> 赋值给 <code>this.$store</code>。否则则说明不是根节点，从父节点的 <code>$store</code> 中获取。</p><p>通过这步的操作，我们已经可以在任意一个 vm 中通过 <code>this.$store</code> 来访问 <code>Store</code> 的实例啦～</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="数据的响应式化"><a href="#数据的响应式化" class="headerlink" title="数据的响应式化"></a>数据的响应式化</h3><p>首先我们需要在 <code>Store</code> 的构造函数中对 <code>state</code> 进行「响应式化」。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">$$state</span>: <span class="built_in">this</span>.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉「响应式」的同学肯定知道，这个步骤以后，<code>state</code> 会将需要的依赖收集在 <code>Dep</code> 中，在被修改时更新对应视图。我们来看一个小例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalData = &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">$$state</span>: &#123;</span><br><span class="line">                globalData</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modify */</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    globalData.d = <span class="string">&#x27;hi~&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Vue.prototype.globalData = globalData;</span><br></pre></td></tr></table></figure><p>任意模板中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;globalData.d&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述代码在全局有一个 <code>globalData</code>，它被传入一个 <code>Vue</code> 对象的 <code>data</code> 中，之后在任意 Vue 模板中对该变量进行展示，因为此时 <code>globalData</code> 已经在 Vue 的 <code>prototype</code> 上了所以直接通过 <code>this.prototype</code> 访问，也就是在模板中的 <code>&#123;&#123;globalData.d&#125;&#125;</code>。此时，<code>setTimeout</code> 在 1s 之后将 <code>globalData.d</code> 进行修改，我们发现模板中的 <code>globalData.d</code> 发生了变化。其实上述部分就是 Vuex 依赖 Vue 核心实现数据的“响应式化”。</p><p>讲完了 Vuex 最核心的通过 Vue 进行数据的「响应式化」，接下来我们再来介绍两个 <code>Store</code> 的 API。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vuex-状态管理的工作原理&quot;&gt;&lt;a href=&quot;#Vuex-状态管理的工作原理&quot; class=&quot;headerlink&quot; title=&quot;Vuex 状态管理的工作原理&quot;&gt;&lt;/a&gt;Vuex 状态管理的工作原理&lt;/h2&gt;&lt;h2 id=&quot;为什么要使用-Vuex&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制07</title>
    <link href="http://example.com/2021/08/17/vue2-core07/"/>
    <id>http://example.com/2021/08/17/vue2-core07/</id>
    <published>2021-08-17T07:17:49.000Z</published>
    <updated>2021-09-17T08:06:36.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="批量异步更新策略及nextTick原理"><a href="#批量异步更新策略及nextTick原理" class="headerlink" title="批量异步更新策略及nextTick原理"></a>批量异步更新策略及nextTick原理</h2><h2 id="为什么要异步更新"><a href="#为什么要异步更新" class="headerlink" title="为什么要异步更新"></a>为什么要异步更新</h2><p>通过前面几个章节我们介绍，相信大家已经明白了 Vue.js 是如何在我们修改 <code>data</code> 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“<code>setter -&gt; Dep -&gt; Watcher -&gt; patch -&gt; 视图</code>”的过程。</p><p>假设我们有如下这么一种情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;number&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">number</span>: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们按下 click 按钮的时候，<code>number</code> 会被循环增加1000次。</p><p>那么按照之前的理解，每次 <code>number</code> 被 +1 的时候，都会触发 <code>number</code> 的 <code>setter</code> 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。</p><p>Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 <code>setter</code> 方法后，对应的 <code>Watcher</code> 对象其实会被 <code>push</code> 进一个队列 <code>queue</code> 中，在下一个 tick 的时候将这个队列 <code>queue</code> 全部拿出来 <code>run</code>（ <code>Watcher</code> 对象的一个方法，用来触发 <code>patch</code> 操作） 一遍。</p><p><img src="https://img.kancloud.cn/84/56/8456483469198b4e046cd583fc847d16_350x404.gif" alt="img"></p><p>那么什么是下一个 tick 呢？</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>Vue.js 实现了一个 <code>nextTick</code> 函数，传入一个 <code>cb</code> ，这个 <code>cb</code> 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 <code>cb</code> 事件。</p><p>因为目前浏览器平台并没有实现 <code>nextTick</code> 方法，所以 Vue.js 源码中分别用 <code>Promise</code>、<code>setTimeout</code>、<code>setImmediate</code> 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。</p><p>笔者用 <code>setTimeout</code> 来模拟这个方法，当然，真实的源码中会更加复杂，笔者在小册中只讲原理，有兴趣了解源码中 <code>nextTick</code> 的具体实现的同学可以参考<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L90">next-tick</a>。</p><p>首先定义一个 <code>callbacks</code> 数组用来存储 <code>nextTick</code>，在下一个 tick 处理这些回调函数之前，所有的 <code>cb</code> 都会被存在这个 <code>callbacks</code> 数组中。<code>pending</code> 是一个标记位，代表一个等待的状态。</p><p><code>setTimeout</code> 会在 task 中创建一个事件 <code>flushCallbacks</code> ，<code>flushCallbacks</code> 则会在执行时将 <code>callbacks</code> 中的所有 <code>cb</code> 依次执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callbacks = [];</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callbacks.push(cb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">    callbacks.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">        copies[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再写-Watcher"><a href="#再写-Watcher" class="headerlink" title="再写 Watcher"></a>再写 Watcher</h2><p>第一个例子中，当我们将 <code>number</code> 增加 1000 次时，先将对应的 <code>Watcher</code> 对象给 <code>push</code> 进一个队列 <code>queue</code> 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？</p><p>因为 <code>number</code> 执行 ++ 操作以后对应的 <code>Watcher</code> 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 <code>Watcher</code> 对象去修改界面，而是只需要执行一个 <code>Watcher</code> 对象，使其将界面上的 0 变成 1000 即可。</p><p>那么，我们就需要执行一个过滤的操作，同一个的 <code>Watcher</code> 在同一个 tick 的时候应该只被执行一次，也就是说队列 <code>queue</code> 中不应该出现重复的 <code>Watcher</code> 对象。</p><p>那么我们给 <code>Watcher</code> 对象起个名字吧～用 <code>id</code> 来标记每一个 <code>Watcher</code> 对象，让他们看起来“不太一样”。</p><p>实现 <code>update</code> 方法，在修改数据后由 <code>Dep</code> 来调用， 而 <code>run</code> 方法才是真正的触发 <code>patch</code> 更新视图的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;watch&#x27;</span> + <span class="built_in">this</span>.id + <span class="string">&#x27; update&#x27;</span>);</span><br><span class="line">        queueWatcher(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;watch&#x27;</span> + <span class="built_in">this</span>.id + <span class="string">&#x27;视图更新啦～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h2><p>不知道大家注意到了没有？笔者已经将 <code>Watcher</code> 的 <code>update</code> 中的实现改成了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queueWatcher(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>将 <code>Watcher</code> 对象自身传递给 <code>queueWatcher</code> 方法。</p><p>我们来实现一下 <code>queueWatcher</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> has = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> queue = [];</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">    <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">        has[id] = <span class="literal">true</span>;</span><br><span class="line">        queue.push(watcher);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">            waiting = <span class="literal">true</span>;</span><br><span class="line">            nextTick(flushSchedulerQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个叫做 <code>has</code> 的 map，里面存放 id -&gt; true ( false ) 的形式，用来判断是否已经存在相同的 <code>Watcher</code> 对象 （这样比每次都去遍历 <code>queue</code> 效率上会高很多）。</p><p>如果目前队列 <code>queue</code> 中还没有这个 <code>Watcher</code> 对象，则该对象会被 <code>push</code> 进队列 <code>queue</code> 中去。</p><p><code>waiting</code> 是一个标记位，标记是否已经向 <code>nextTick</code> 传递了 <code>flushSchedulerQueue</code> 方法，在下一个 tick 的时候执行 <code>flushSchedulerQueue</code> 方法来 flush 队列 <code>queue</code>，执行它里面的所有 <code>Watcher</code> 对象的 <code>run</code> 方法。</p><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> watcher, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">        watcher = queue[index];</span><br><span class="line">        id = watcher.id;</span><br><span class="line">        has[id] = <span class="literal">null</span>;</span><br><span class="line">        watcher.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waiting  = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> watch1 = <span class="keyword">new</span> Watcher();</span><br><span class="line"><span class="keyword">let</span> watch2 = <span class="keyword">new</span> Watcher();</span><br><span class="line"></span><br><span class="line">watch1.update();</span><br><span class="line">watch1.update();</span><br><span class="line">watch2.update();</span><br></pre></td></tr></table></figure><p>我们现在 new 了两个 <code>Watcher</code> 对象，因为修改了 <code>data</code> 的数据，所以我们模拟触发了两次 <code>watch1</code> 的 <code>update</code> 以及 一次 <code>watch2</code> 的 <code>update</code>。</p><p>假设没有批量异步更新策略的话，理论上应该执行 <code>Watcher</code> 对象的 <code>run</code>，那么会打印。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch1 update</span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch1 update</span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch2 update</span><br><span class="line">watch2视图更新啦～</span><br></pre></td></tr></table></figure><p>实际上则执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch1 update</span><br><span class="line">watch1 update</span><br><span class="line">watch2 update</span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch2视图更新啦～</span><br></pre></td></tr></table></figure><p>这就是异步更新策略的效果，相同的 <code>Watcher</code> 对象会在这个过程中被剔除，在下一个 tick 的时候去更新视图，从而达到对我们第一个例子的优化。</p><p>我们再回过头聊一下第一个例子， <code>number</code> 会被不停地进行 <code>++</code> 操作，不断地触发它对应的 <code>Dep</code> 中的 <code>Watcher</code> 对象的 <code>update</code> 方法。然后最终 <code>queue</code> 中因为对相同 <code>id</code> 的 <code>Watcher</code> 对象进行了筛选，从而 <code>queue</code> 中实际上只会存在一个 <code>number</code> 对应的 <code>Watcher</code> 对象。在下一个 tick 的时候（此时 <code>number</code> 已经变成了 1000），触发 <code>Watcher</code> 对象的 <code>run</code> 方法来更新视图，将视图上的 <code>number</code> 从 0 直接变成 1000。</p><p>到这里，批量异步更新策略及 nextTick 原理已经讲完了，接下来让我们学习一下 Vuex 状态管理的工作原理。</p><p>注：本节代码参考[《批量异步更新策略及 nextTick 原理》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A">https://github.com/answershuto/VueDemo/blob/master/《批量异步更新策略及</a> nextTick 原理》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;批量异步更新策略及nextTick原理&quot;&gt;&lt;a href=&quot;#批量异步更新策略及nextTick原理&quot; class=&quot;headerlink&quot; title=&quot;批量异步更新策略及nextTick原理&quot;&gt;&lt;/a&gt;批量异步更新策略及nextTick原理&lt;/h2&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制06</title>
    <link href="http://example.com/2021/08/14/vue2-core06/"/>
    <id>http://example.com/2021/08/14/vue2-core06/</id>
    <published>2021-08-14T07:17:49.000Z</published>
    <updated>2021-09-17T08:10:31.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据状态更新时的差异-diff-及-patch-机制"><a href="#数据状态更新时的差异-diff-及-patch-机制" class="headerlink" title="数据状态更新时的差异 diff 及 patch 机制"></a>数据状态更新时的差异 diff 及 patch 机制</h2><h2 id="数据更新视图"><a href="#数据更新视图" class="headerlink" title="数据更新视图"></a>数据更新视图</h2><p>之前讲到，在对 <code>model</code> 进行操作对时候，会触发对应 <code>Dep</code> 中的 <code>Watcher</code> 对象。<code>Watcher</code> 对象会调用对应的 <code>update</code> 来修改视图。最终是将新产生的 VNode 节点与老 VNode 进行一个 <code>patch</code> 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p><p>这一章就来介绍一下这个 <code>patch</code> 的过程，因为 <code>patch</code> 过程本身比较复杂，这一章的内容会比较多，但是不要害怕，我们逐块代码去看，一定可以理解。</p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>因为使用了 Virtual DOM 的原因，Vue.js具有了跨平台的能力，Virtual DOM 终归只是一些 JavaScript 对象罢了，那么最终是如何调用不同平台的 API 的呢？</p><p>这就需要依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeOps = &#123;</span><br><span class="line">    setTextContent (text) &#123;</span><br><span class="line">        <span class="keyword">if</span> (platform === <span class="string">&#x27;weex&#x27;</span>) &#123;</span><br><span class="line">            node.parentNode.setAttr(<span class="string">&#x27;value&#x27;</span>, text);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (platform === <span class="string">&#x27;web&#x27;</span>) &#123;</span><br><span class="line">            node.textContent = text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    parentNode () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    removeChild () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    nextSibling () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    insertBefore () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，现在我们有上述一个 <code>nodeOps</code> 对象做适配，根据 platform 区分不同平台来执行当前平台对应的API，而对外则是提供了一致的接口，供 Virtual DOM 来调用。</p><h2 id="一些API"><a href="#一些API" class="headerlink" title="一些API"></a>一些API</h2><p>接下来我们来介绍其他的一些 API，这些API在下面 <code>patch</code> 的过程中会被用到，他们最终都会调用 <code>nodeOps</code> 中的相应函数来操作平台。</p><p><code>insert</code> 用来在 <code>parent</code> 这个父节点下插入一个子节点，如果指定了 <code>ref</code> 则插入到 <code>ref</code> 这个子节点前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ref.parentNode === parent) &#123;</span><br><span class="line">                nodeOps.insertBefore(parent, elm, ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeOps.appendChild(parent, elm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElm</code> 用来新建一个节点， <code>tag</code> 存在创建一个标签节点，否则创建一个文本节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params">vnode, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.tag) &#123;</span><br><span class="line">        insert(parentElm, nodeOps.createElement(vnode.tag), refElm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(parentElm, nodeOps.createTextNode(vnode.text), refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addVnodes</code> 用来批量调用 <code>createElm</code> 新建节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVnodes</span> (<span class="params">parentElm, refElm, vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">        createElm(vnodes[startIdx], parentElm, refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeNode</code> 用来移除一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parent = nodeOps.parentNode(el);</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        nodeOps.removeChild(parent, el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeVnodes</code> 会批量调用 <code>removeNode</code> 移除节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm, vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">        <span class="keyword">const</span> ch = vnodes[startIdx]</span><br><span class="line">        <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">            removeNode(ch.elm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>首先说一下 <code>patch</code> 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 <code>patch</code> 的过程，我们需要将他们进行比对。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/28/1609be691ed64525?w=706&h=295&f=jpeg&s=18300" alt="img"></p><p>diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。</p><p><img src="https://img.kancloud.cn/78/ed/78ed0f7a71736796f0d4c31f5a9d1b9c_628x214.gif" alt="img"></p><p>这张图中的相同颜色的方块中的节点会进行比对，比对得到「<strong>差异</strong>」后将这些「<strong>差异</strong>」更新到视图上。因为只进行同层级的比对，所以十分高效。</p><p><code>patch</code> 的过程相当复杂，我们先用简单的代码来看一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, parentElm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">        addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(oldVNode, vnode)) &#123;</span><br><span class="line">            patchVnode(oldVNode, vnode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">            addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>patch</code> 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。我们来逐步捋一下逻辑， <code>addVnodes</code> 、 <code>removeVnodes</code> 等函数后面会讲。</p><p>首先在 <code>oldVnode</code>（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 <code>addVnodes</code> 将这些节点批量添加到 <code>parentElm</code> 上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">    addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后同理，在 <code>vnode</code>（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 <code>removeVnodes</code> 进行批量的节点删除即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一种情况，当 <code>oldVNode</code> 与 <code>vnode</code> 都存在的时候，需要判断它们是否属于 <code>sameVnode</code>（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameVnode(oldVNode, vnode)) &#123;</span><br><span class="line">    patchVnode(oldVNode, vnode);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">    addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h2><p>上面这些比较好理解，下面我们来看看什么情况下两个 VNode 会属于 <code>sameVnode</code> （相同的节点）呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        a.key === b.key &amp;&amp;</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        (!!a.data) === (!!b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameInputType</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tag !== <span class="string">&#x27;input&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> typeA = (i = a.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type</span><br><span class="line">    <span class="keyword">const</span> typeB = (i = b.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type</span><br><span class="line">    <span class="keyword">return</span> typeA === typeB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sameVnode</code> 其实很简单，只有当 <code>key</code>、 <code>tag</code>、 <code>isComment</code>（是否为注释节点）、 <code>data</code>同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改类型，所以他们被视为不同类型）即可。</p><h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h2><p>之前patch的过程还剩下 <code>patchVnode</code> 这个函数没有讲，这也是最复杂的一个，我们现在来看一下。因为这个函数是在符合 <code>sameVnode</code> 的条件下触发的，所以会进行「<strong>比对</strong>」。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123;</span><br><span class="line">        vnode.elm = oldVnode.elm;</span><br><span class="line">        vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm;</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children;</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.text) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123;</span><br><span class="line">            updateChildren(elm, oldCh, ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldVnode.text) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">            addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldCh) &#123;</span><br><span class="line">            removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text) &#123;</span><br><span class="line">            nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的这种情况也比较简单，在当新老 VNode 节点都是 <code>isStatic</code>（静态的），并且 <code>key</code> 相同时，只要将 <code>componentInstance</code> 与 <code>elm</code> 从老 VNode 节点“拿过来”即可。这里的 <code>isStatic</code> 也就是前面提到过的「编译」的时候会将静态节点标记出来，这样就可以跳过比对的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123;</span><br><span class="line">    vnode.elm = oldVnode.elm;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，当新 VNode 节点是文本节点的时候，直接用 <code>setTextContent</code> 来设置 text，这里的 <code>nodeOps</code> 是一个适配层，根据不同平台提供不同的操作平台 DOM 的方法，实现跨平台。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新 VNode 节点是非文本节点当时候，需要分几种情况。</p><ul><li><code>oldCh</code> 与 <code>ch</code> 都存在且不相同时，使用 <code>updateChildren</code> 函数来更新子节点，这个后面重点讲。</li><li>如果只有 <code>ch</code> 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 <code>ch</code> 批量插入插入到节点elm下。</li><li>同理当只有 <code>oldch</code> 存在时，说明需要将老节点通过 <code>removeVnodes</code> 全部清除。</li><li>最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123;</span><br><span class="line">    updateChildren(elm, oldCh, ch);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldVnode.text) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldCh) &#123;</span><br><span class="line">    removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><p>接下来就要讲一下 <code>updateChildren</code> 函数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldStartVnode) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVnode) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">            nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">            nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> elmToMove = oldCh[idxInOld];</span><br><span class="line">            <span class="keyword">if</span> (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                createElm(newStartVnode, parentElm);</span><br><span class="line">                newStartVnode = newCh[++newStartIdx];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elmToMove = oldCh[idxInOld];</span><br><span class="line">                <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(elmToMove, newStartVnode);</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">                    nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    createElm(newStartVnode, parentElm);</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = (newCh[newEndIdx + <span class="number">1</span>]) ? newCh[newEndIdx + <span class="number">1</span>].elm : <span class="literal">null</span>;</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到代码那么多先不要着急，我们还是一点一点地讲解。</p><p>首先我们定义 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 分别是新老两个 VNode 的两边的索引，同时 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 分别指向这几个索引对应的 VNode 节点。</p><p><img src="https://img.kancloud.cn/9d/4a/9d4a83c7a917571940a8edd29396c345_885x397.gif" alt="img"></p><p>接下来是一个 <code>while</code> 循环，在这过程中，<code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 会逐渐向中间靠拢。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) </span><br></pre></td></tr></table></figure><p><img src="https://img.kancloud.cn/9b/fa/9bfa3d79db0aa810974ce4000e01ffd2_864x428.gif" alt="img"></p><p>首先当 <code>oldStartVnode</code> 或者 <code>oldEndVnode</code> 不存在的时候，<code>oldStartIdx</code> 与 <code>oldEndIdx</code> 继续向中间靠拢，并更新对应的 <code>oldStartVnode</code> 与 <code>oldEndVnode</code> 的指向（注：下面讲到的 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 移动都会伴随着 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 的指向的变化，之后的部分只会讲 <code>Idx</code> 的移动）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!oldStartVnode) &#123;</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVnode) &#123;</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来这一块，是将 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 两两比对的过程，一共会出现 2*2=4 种情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    newEndVnode = newCh[--newEndIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">    newEndVnode = newCh[--newEndIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>首先是 <code>oldStartVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接进行 <code>patchVnode</code>，同时 <code>oldStartIdx</code> 与 <code>newStartIdx</code> 向后移动一位。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b71f5a48631f4?w=618&h=251&f=png&s=19993" alt="img"></p><p>其次是 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code>，也就是两个 VNode 的结尾是相同的 VNode，同样进行 <code>patchVnode</code> 操作并将 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 向前移动一位。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b7228b9ecb23a?w=753&h=235&f=png&s=20727" alt="img"></p><p>接下来是两种交叉的情况。</p><p>先是 <code>oldStartVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code> 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 <code>oldStartVnode.elm</code> 这个节点直接移动到 <code>oldEndVnode.elm</code> 这个节点的后面即可。然后 <code>oldStartIdx</code> 向后移动一位，<code>newEndIdx</code> 向前移动一位。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b723af0fd706a?w=1540&h=776&f=png&s=105982" alt="img"></p><p>同理，<code>oldEndVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 <code>oldEndVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 前面。同样的，<code>oldEndIdx</code> 向前移动一位，<code>newStartIdx</code> 向后移动一位。</p><p><img src="https://img.kancloud.cn/aa/8d/aa8d34c20a47b212378b1da678355af9_810x432.gif" alt="img"></p><p>最后是当以上情况都不符合的时候，这种情况怎么处理呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> elmToMove = oldCh[idxInOld];</span><br><span class="line">    <span class="keyword">if</span> (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">        createElm(newStartVnode, parentElm);</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elmToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(elmToMove, newStartVnode);</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">            nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createElm(newStartVnode, parentElm);</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i, key</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">        key = children[i].key</span><br><span class="line">        <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createKeyToOldIdx</code> 的作用是产生 <code>key</code> 与 <code>index</code> 索引对应的一个 map 表。比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">xx</span>: xx, <span class="attr">key</span>: <span class="string">&#x27;key0&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">xx</span>: xx, <span class="attr">key</span>: <span class="string">&#x27;key1&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">xx</span>: xx, <span class="attr">key</span>: <span class="string">&#x27;key2&#x27;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在经过 <code>createKeyToOldIdx</code> 转化以后会变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">key0</span>: <span class="number">0</span>, </span><br><span class="line">    <span class="attr">key1</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="attr">key2</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以根据某一个 key 的值，快速地从 <code>oldKeyToIdx</code>（<code>createKeyToOldIdx</code> 的返回值）中获取相同 key 的节点的索引 <code>idxInOld</code>，然后找到相同的节点。</p><p>如果没有找到相同的节点，则通过 <code>createElm</code> 创建一个新节点，并将 <code>newStartIdx</code> 向后移动一位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">    createElm(newStartVnode, parentElm);</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则如果找到了节点，同时它符合 <code>sameVnode</code>，则将这两个节点进行 <code>patchVnode</code>，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 的前面。同理，<code>newStartIdx</code> 往后移动一位。</p><p><img src="https://img.kancloud.cn/e9/fa/e9fa09c72cbca2763a9fd891f8894d3c_750x373.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    elmToMove = oldCh[idxInOld];</span><br><span class="line">    <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(elmToMove, newStartVnode);</span><br><span class="line">        oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">        nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不符合 <code>sameVnode</code>，只能创建一个新节点插入到 <code>parentElm</code> 的子节点中，<code>newStartIdx</code> 往后移动一位。</p><p><img src="https://img.kancloud.cn/bc/0d/bc0dc37b80d324472e77d4eb418edf67_927x462.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    createElm(newStartVnode, parentElm);</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步就很容易啦，当 <code>while</code> 循环结束以后，如果 <code>oldStartIdx &gt; oldEndIdx</code>，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 <code>addVnodes</code> 将这些节点插入即可。</p><p><img src="https://img.kancloud.cn/9b/17/9b172cca47e698754c47653c10bc815f_784x373.gif" alt="img"></p><p>同理，如果满足 <code>newStartIdx &gt; newEndIdx</code> 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 <code>removeVnodes</code> 批量删除即可。</p><p><img src="https://img.kancloud.cn/37/65/3765205d0b78788b7cdddcffb70a495f_836x367.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = (newCh[newEndIdx + <span class="number">1</span>]) ? newCh[newEndIdx + <span class="number">1</span>].elm : <span class="literal">null</span>;</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，比对的核心实现已经讲完了，这部分比较复杂，不过仔细地梳理一下比对的过程，相信一定能够理解得更加透彻的。</p><p>注：本节代码参考[《数据状态更新时的差异 diff 及 patch 机制》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82">https://github.com/answershuto/VueDemo/blob/master/《数据状态更新时的差异</a> diff 及 patch 机制》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据状态更新时的差异-diff-及-patch-机制&quot;&gt;&lt;a href=&quot;#数据状态更新时的差异-diff-及-patch-机制&quot; class=&quot;headerlink&quot; title=&quot;数据状态更新时的差异 diff 及 patch 机制&quot;&gt;&lt;/a&gt;数据状态更新时的</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制05</title>
    <link href="http://example.com/2021/08/10/vue2-core05/"/>
    <id>http://example.com/2021/08/10/vue2-core05/</id>
    <published>2021-08-10T07:17:49.000Z</published>
    <updated>2021-09-17T08:09:28.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="template-模板是怎样通过-Compile-编译的"><a href="#template-模板是怎样通过-Compile-编译的" class="headerlink" title="template 模板是怎样通过 Compile 编译的"></a>template 模板是怎样通过 Compile 编译的</h2><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p><code>compile</code> 编译可以分成 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 三个阶段，最终需要得到 render function。这部分内容不算 Vue.js 的响应式核心，只是用来编译的，笔者认为在精力有限的情况下不需要追究其全部的实现细节，能够把握如何解析的大致流程即可。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606ec3d306ab28f?w=824&h=496&f=png&s=37271" alt="img"></p><p>由于解析过程比较复杂，直接上代码可能会导致不了解这部分内容的同学一头雾水。所以笔者准备提供一个 template 的示例，通过这个示例的变化来看解析的过程。但是解析的过程及结果都是将最重要的部分抽离出来展示，希望能让读者更好地了解其核心部分的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;c&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;demo&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;item in sz&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;div :class=&quot;c&quot; class=&quot;demo&quot; v-if=&quot;isShow&quot;&gt;&lt;span v-for=&quot;item in sz&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/div&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>接下来的过程都会依赖这个示例来进行。</p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>首先是 <code>parse</code>，<code>parse</code> 会用正则等方式将 template 模板中进行字符串解析，得到指令、class、style等数据，形成 AST（<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。</a>）。</p><p>这个过程比较复杂，会涉及到比较多的正则进行字符串解析，我们来看一下得到的 AST 的样子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 标签属性的map，记录了标签上属性 */</span></span><br><span class="line">    <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;:class&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;v-if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 解析得到的:class */</span></span><br><span class="line">    <span class="string">&#x27;classBinding&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 标签属性v-if */</span></span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">    <span class="comment">/* v-if的条件 */</span></span><br><span class="line">    <span class="string">&#x27;ifConditions&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;exp&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">/* 标签属性class */</span></span><br><span class="line">    <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 标签的tag */</span></span><br><span class="line">    <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 子标签数组 */</span></span><br><span class="line">    <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;v-for&#x27;</span>: <span class="string">&quot;item in sz&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/* for循环的参数 */</span></span><br><span class="line">            <span class="string">&#x27;alias&#x27;</span>: <span class="string">&quot;item&quot;</span>,</span><br><span class="line">            <span class="comment">/* for循环的对象 */</span></span><br><span class="line">            <span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">            <span class="comment">/* for循环是否已经被处理的标记位 */</span></span><br><span class="line">            <span class="string">&#x27;forProcessed&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 表达式，_s是一个转字符串的函数 */</span></span><br><span class="line">                    <span class="string">&#x27;expression&#x27;</span>: <span class="string">&#x27;_s(item)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#123;&#123;item&#125;&#125;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到的 AST 通过一些特定的属性，能够比较清晰地描述出标签的属性以及依赖关系。</p><p>接下来我们用代码来讲解一下如何使用正则来把 template 编译成我们需要的 AST 的。</p><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>首先我们定义一下接下来我们会用到的正则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> singleAttrIdentifier = <span class="regexp">/([^\s&quot;&#x27;&lt;&gt;/=]+)/</span></span><br><span class="line"><span class="keyword">const</span> singleAttrAssign = <span class="regexp">/(?:=)/</span></span><br><span class="line"><span class="keyword">const</span> singleAttrValues = [</span><br><span class="line">  <span class="regexp">/&quot;([^&quot;]*)&quot;+/</span>.source,</span><br><span class="line">  <span class="regexp">/&#x27;([^&#x27;]*)&#x27;+/</span>.source,</span><br><span class="line">  <span class="regexp">/([^\s&quot;&#x27;=&lt;&gt;`]+)/</span>.source</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> attribute = <span class="keyword">new</span> <span class="built_in">RegExp</span>(</span><br><span class="line">  <span class="string">&#x27;^\\s*&#x27;</span> + singleAttrIdentifier.source +</span><br><span class="line">  <span class="string">&#x27;(?:\\s*(&#x27;</span> + singleAttrAssign.source + <span class="string">&#x27;)&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;\\s*(?:&#x27;</span> + singleAttrValues.join(<span class="string">&#x27;|&#x27;</span>) + <span class="string">&#x27;))?&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> qnameCapture = <span class="string">&#x27;((?:&#x27;</span> + ncname + <span class="string">&#x27;\\:)?&#x27;</span> + ncname + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"><span class="keyword">const</span> startTagOpen = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;^&lt;&#x27;</span> + qnameCapture)</span><br><span class="line"><span class="keyword">const</span> startTagClose = <span class="regexp">/^\s*(\/?)&gt;/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> endTag = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;^&lt;\\/&#x27;</span> + qnameCapture + <span class="string">&#x27;[^&gt;]*&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTagRE = <span class="regexp">/\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> forAliasRE = <span class="regexp">/(.*?)\s+(?:in|of)\s+(.*)/</span></span><br></pre></td></tr></table></figure><h2 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h2><p>因为我们解析 template 采用循环进行字符串匹配的方式，所以每匹配解析完一段我们需要将已经匹配掉的去掉，头部的指针指向接下来需要匹配的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    index += n</span><br><span class="line">    html = html.substring(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，当我们把第一个 div 的头标签全部匹配完毕以后，我们需要将这部分除去，也就是向右移动 43 个字符。</p><p><img src="https://img.kancloud.cn/30/12/3012cf68fb6155a4d9ccf0490bcc85c8_1086x199.gif" alt="img"></p><p>调用 <code>advance</code> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advance(43);</span><br></pre></td></tr></table></figure><p>得到结果</p><p><img src="https://img.kancloud.cn/84/89/84898f9a7959fa81cc4055869bd98c4f_1096x198.gif" alt="img"></p><h3 id="parseHTML"><a href="#parseHTML" class="headerlink" title="parseHTML"></a>parseHTML</h3><p>首先我们需要定义个 <code>parseHTML</code> 函数，在里面我们循环解析 template 字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(html) &#123;</span><br><span class="line">        <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (html.match(endTag)) &#123;</span><br><span class="line">                <span class="comment">//...process end tag</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">                <span class="comment">//...process start tag</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...process text</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parseHTML</code> 会用 <code>while</code> 来循环解析 template ，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个 template 被解析完毕。</p><h3 id="parseStartTag"><a href="#parseStartTag" class="headerlink" title="parseStartTag"></a>parseStartTag</h3><p>我们来写一个 <code>parseStartTag</code> 函数，用来解析起始标签（”</p><p>“部分的内容）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">const</span> match = &#123;</span><br><span class="line">            <span class="attr">tagName</span>: start[<span class="number">1</span>],</span><br><span class="line">            <span class="attr">attrs</span>: [],</span><br><span class="line">            <span class="attr">start</span>: index</span><br><span class="line">        &#125;</span><br><span class="line">        advance(start[<span class="number">0</span>].length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> end, attr</span><br><span class="line">        <span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class="line">            advance(attr[<span class="number">0</span>].length)</span><br><span class="line">            match.attrs.push(&#123;</span><br><span class="line">                <span class="attr">name</span>: attr[<span class="number">1</span>],</span><br><span class="line">                <span class="attr">value</span>: attr[<span class="number">3</span>]</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">            match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">            advance(end[<span class="number">0</span>].length);</span><br><span class="line">            match.end = index;</span><br><span class="line">            <span class="keyword">return</span> match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先用 <code>startTagOpen</code> 正则得到标签的头部，可以得到 <code>tagName</code>（标签名称），同时我们需要一个数组 <code>attrs</code> 用来存放标签内的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line"><span class="keyword">const</span> match = &#123;</span><br><span class="line">    <span class="attr">tagName</span>: start[<span class="number">1</span>],</span><br><span class="line">    <span class="attr">attrs</span>: [],</span><br><span class="line">    <span class="attr">start</span>: index</span><br><span class="line">&#125;</span><br><span class="line">advance(start[<span class="number">0</span>].length);</span><br></pre></td></tr></table></figure><p>接下来使用 <code>startTagClose</code> 与 <code>attribute</code> 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 <code>while</code> 循环一直到匹配到 <code>startTagClose</code> 为止，解析内部所有的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> end, attr</span><br><span class="line"><span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class="line">    advance(attr[<span class="number">0</span>].length)</span><br><span class="line">    match.attrs.push(&#123;</span><br><span class="line">        <span class="attr">name</span>: attr[<span class="number">1</span>],</span><br><span class="line">        <span class="attr">value</span>: attr[<span class="number">3</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (end) &#123;</span><br><span class="line">    match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">    advance(end[<span class="number">0</span>].length);</span><br><span class="line">    match.end = index;</span><br><span class="line">    <span class="keyword">return</span> match</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>此外，我们需要维护一个 <strong>stack</strong> 栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 <code>currentParent</code> 变量用来存放当前标签的父标签节点的引用， <code>root</code> 变量用来指向根标签节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line"><span class="keyword">let</span> currentParent, root;</span><br></pre></td></tr></table></figure><p><img src="https://img.kancloud.cn/40/28/4028cf3960616fca915c0f2ed4229427_709x451.gif" alt="img"></p><p>知道这个以后，我们优化一下 <code>parseHTML</code> ，在 <code>startTagOpen</code> 的 <code>if</code> 逻辑中加上新的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">tag</span>: startTagMatch.tagName,</span><br><span class="line">        <span class="attr">lowerCasedTag</span>: startTagMatch.tagName.toLowerCase(),</span><br><span class="line">        <span class="attr">attrsList</span>: startTagMatch.attrs,</span><br><span class="line">        <span class="attr">attrsMap</span>: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">        <span class="attr">parent</span>: currentParent,</span><br><span class="line">        <span class="attr">children</span>: []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentParent)&#123;</span><br><span class="line">        currentParent.children.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(element);</span><br><span class="line">    currentParent = element;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 <code>startTagMatch</code> 得到的结果首先封装成 <code>element</code> ，这个就是最终形成的 AST 的节点，标签节点的 type 为 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">tag</span>: startTagMatch.tagName,</span><br><span class="line">    <span class="attr">attrsList</span>: startTagMatch.attrs,</span><br><span class="line">    <span class="attr">attrsMap</span>: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">    <span class="attr">parent</span>: currentParent,</span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让 <code>root</code> 指向根节点的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    root = element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们将当前节点的 <code>element</code> 放入父节点 <code>currentParent</code> 的 <code>children</code> 数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentParent)&#123;</span><br><span class="line">    currentParent.children.push(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将当前节点 <code>element</code> 压入 stack 栈中，并将 <code>currentParent</code> 指向当前节点，因为接下去下一个解析如果还是头标签或者是文本的话，会成为当前节点的子节点，如果是尾标签的话，那么将会从栈中取出当前节点，这种情况我们接下来要讲。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack.push(element);</span><br><span class="line">currentParent = element;</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>其中的 <code>makeAttrsMap</code> 是将 attrs 转换成 map 格式的一个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAttrsMap</span> (<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = attrs.length; i &lt; l; i++) &#123;</span><br><span class="line">        map[attrs[i].name] = attrs[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parseEndTag"><a href="#parseEndTag" class="headerlink" title="parseEndTag"></a>parseEndTag</h3><p>同样，我们在 <code>parseHTML</code> 中加入对尾标签的解析函数，为了匹配如“</p><p>”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> endTagMatch = html.match(endTag)</span><br><span class="line"> <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">    advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">    parseEndTag(endTagMatch[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>parseEndTag</code> 来解析尾标签，它会从 stack 栈中取出最近的跟自己标签名一致的那个元素，将 <code>currentParent</code> 指向那个元素，并将该元素之前的元素都从 stack 中出栈。</p><p>这里可能有同学会问，难道解析的尾元素不应该对应 stack 栈的最上面的一个元素才对吗？</p><p>其实不然，比如说可能会存在自闭合的标签，如“<br>”，或者是写了“”但是没有加上“&lt; /span&gt;”的情况，这时候就要找到 stack 中的第二个位置才能找到同名标签。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseEndTag</span> (<span class="params">tagName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (pos = stack.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack[pos].lowerCasedTag === tagName.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stack.length = pos;</span><br><span class="line">        currentParent = stack[pos]; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parseText"><a href="#parseText" class="headerlink" title="parseText"></a>parseText</h3><p>最后是解析文本，这个比较简单，只需要将文本取出，然后有两种情况，一种是普通的文本，直接构建一个节点 push 进当前 <code>currentParent</code> 的 children 中即可。还有一种情况是文本是如“”这样的 Vue.js 的表达式，这时候我们需要用 <code>parseText</code> 来将表达式转化成代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">text = html.substring(<span class="number">0</span>, textEnd)</span><br><span class="line">advance(textEnd)</span><br><span class="line"><span class="keyword">let</span> expression;</span><br><span class="line"><span class="keyword">if</span> (expression = parseText(text)) &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="number">2</span>,</span><br><span class="line">        text,</span><br><span class="line">        expression</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="number">3</span>,</span><br><span class="line">        text,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>我们会用到一个 <code>parseText</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseText</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!defaultTagRE.test(text)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">let</span> lastIndex = defaultTagRE.lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> match, index</span><br><span class="line">    <span class="keyword">while</span> ((match = defaultTagRE.exec(text))) &#123;</span><br><span class="line">        index = match.index</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">            tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex, index)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> exp = match[<span class="number">1</span>].trim()</span><br><span class="line">        tokens.push(<span class="string">`_s(<span class="subst">$&#123;exp&#125;</span>)`</span>)</span><br><span class="line">        lastIndex = index + match[<span class="number">0</span>].length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; text.length) &#123;</span><br><span class="line">        tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.join(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个 <code>tokens</code> 数组来存放解析结果，通过 <code>defaultTagRE</code> 来循环匹配该文本，如果是普通文本直接 <code>push</code> 到 <code>tokens</code> 数组中去，如果是表达式（），则转化成“_s(${exp})”的形式。</p><p>举个例子，如果我们有这样一个文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;hello,&#123;&#123;name&#125;&#125;.&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>最终得到 <code>tokens</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokens = [<span class="string">&#x27;hello,&#x27;</span>, _s(name), <span class="string">&#x27;.&#x27;</span>];</span><br></pre></td></tr></table></figure><p>最终通过 <code>join</code> 返回表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> + _s(name) + <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="processIf与processFor"><a href="#processIf与processFor" class="headerlink" title="processIf与processFor"></a>processIf与processFor</h3><p>最后介绍一下如何处理“<code>v-if</code>”以及“<code>v-for</code>”这样的 Vue.js 的表达式的，这里我们只简单介绍两个示例中用到的表达式解析。</p><p>我们只需要在解析头标签的内容中加入这两个表达式的解析函数即可，在这时“<code>v-for</code>”之类指令已经在属性解析时存入了 <code>attrsMap</code> 中了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">tag</span>: startTagMatch.tagName,</span><br><span class="line">        <span class="attr">attrsList</span>: startTagMatch.attrs,</span><br><span class="line">        <span class="attr">attrsMap</span>: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">        <span class="attr">parent</span>: currentParent,</span><br><span class="line">        <span class="attr">children</span>: []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processIf(element);</span><br><span class="line">    processFor(element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentParent)&#123;</span><br><span class="line">        currentParent.children.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(element);</span><br><span class="line">    currentParent = element;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要定义一个 <code>getAndRemoveAttr</code> 函数，用来从 <code>el</code> 的 <code>attrsMap</code> 属性或是 <code>attrsList</code> 属性中取出 <code>name</code> 对应值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAndRemoveAttr</span> (<span class="params">el, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> val</span><br><span class="line">    <span class="keyword">if</span> ((val = el.attrsMap[name]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> list = el.attrsList</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i].name === name) &#123;</span><br><span class="line">                list.splice(i, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说解析示例的 div 标签属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAndRemoveAttr(el, <span class="string">&#x27;v-for&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可有得到“item in sz”。</p><p>有了这个函数这样我们就可以开始实现 <code>processFor</code> 与 <code>processIf</code> 了。</p><p>“v-for”会将指令解析成 <code>for</code> 属性以及 <code>alias</code> 属性，而“v-if”会将条件都存入 <code>ifConditions</code> 数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFor</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> exp;</span><br><span class="line">    <span class="keyword">if</span> ((exp = getAndRemoveAttr(el, <span class="string">&#x27;v-for&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">const</span> inMatch = exp.match(forAliasRE);</span><br><span class="line">        el.for = inMatch[<span class="number">2</span>].trim();</span><br><span class="line">        el.alias = inMatch[<span class="number">1</span>].trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processIf</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exp = getAndRemoveAttr(el, <span class="string">&#x27;v-if&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (exp) &#123;</span><br><span class="line">        el.if = exp;</span><br><span class="line">        <span class="keyword">if</span> (!el.ifConditions) &#123;</span><br><span class="line">            el.ifConditions = [];</span><br><span class="line">        &#125;</span><br><span class="line">        el.ifConditions.push(&#123;</span><br><span class="line">            <span class="attr">exp</span>: exp,</span><br><span class="line">            <span class="attr">block</span>: el</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经把 <code>parse</code> 的过程介绍完了，接下来看一下 <code>optimize</code>。</p><h2 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h2><p><code>optimize</code> 主要作用就跟它的名字一样，用作「优化」。</p><p>这个涉及到后面要讲 <code>patch</code> 的过程，因为 <code>patch</code> 的过程实际上是将 VNode 节点进行一层一层的比对，然后将「差异」更新到视图上。那么一些静态节点是不会根据数据变化而产生变化的，这些节点我们没有比对的需求，是不是可以跳过这些静态节点的比对，从而节省一些性能呢？</p><p>那么我们就需要为静态的节点做上一些「标记」，在 <code>patch</code> 的时候我们就可以直接跳过这些被标记的节点的比对，从而达到「优化」的目的。</p><p>经过 <code>optimize</code> 这层的处理，每个节点会加上 <code>static</code> 属性，用来标记是否是静态的。</p><p>得到如下结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;:class&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;v-if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;classBinding&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ifConditions&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;exp&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 静态标志 */</span></span><br><span class="line">    <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;v-for&#x27;</span>: <span class="string">&quot;item in sz&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&#x27;alias&#x27;</span>: <span class="string">&quot;item&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;forProcessed&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;expression&#x27;</span>: <span class="string">&#x27;_s(item)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#123;&#123;item&#125;&#125;&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用代码实现一下 <code>optimize</code> 函数。</p><h3 id="isStatic"><a href="#isStatic" class="headerlink" title="isStatic"></a>isStatic</h3><p>首先实现一个 <code>isStatic</code> 函数，传入一个 node 判断该 node 是否是静态节点。判断的标准是当 type 为 2（表达式节点）则是非静态节点，当 type 为 3（文本节点）的时候则是静态节点，当然，如果存在 <code>if</code> 或者 <code>for</code>这样的条件的时候（表达式节点），也是非静态节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (!node.if &amp;&amp; !node.for);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="markStatic"><a href="#markStatic" class="headerlink" title="markStatic"></a>markStatic</h3><p><code>markStatic</code> 为所有的节点标记上 <code>static</code>，遍历所有节点通过 <code>isStatic</code> 来判断当前节点是否是静态节点，此外，会遍历当前节点的所有子节点，如果子节点是非静态节点，那么当前节点也是非静态节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStatic</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.static = isStatic(node);</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = node.children[i];</span><br><span class="line">            markStatic(child);</span><br><span class="line">            <span class="keyword">if</span> (!child.static) &#123;</span><br><span class="line">                node.static = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="markStaticRoots"><a href="#markStaticRoots" class="headerlink" title="markStaticRoots"></a>markStaticRoots</h3><p>接下来是 <code>markStaticRoots</code> 函数，用来标记 <code>staticRoot</code>（静态根）。这个函数实现比较简单，简单来将就是如果当前节点是静态节点，同时满足该节点并不是只有一个文本节点左右子节点（作者认为这种情况的优化消耗会大于收益）时，标记 <code>staticRoot</code> 为 true，否则为 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStaticRoots</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">        node.children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        node.children[<span class="number">0</span>].type === <span class="number">3</span></span><br><span class="line">        )) &#123;</span><br><span class="line">            node.staticRoot = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.staticRoot = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="optimize-1"><a href="#optimize-1" class="headerlink" title="optimize"></a>optimize</h3><p>有了以上的函数，就可以实现 <code>optimize</code> 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optimize</span> (<span class="params">rootAst</span>) </span>&#123;</span><br><span class="line">    markStatic(rootAst);</span><br><span class="line">    markStaticRoots(rootAst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code> 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p><p>首先带大家感受一下真实的 Vue.js 编译得到的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params"><span class="built_in">this</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isShow) ? </span><br><span class="line">    _c(</span><br><span class="line">        <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">staticClass</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">            <span class="attr">class</span>: c</span><br><span class="line">        &#125;,</span><br><span class="line">        _l(</span><br><span class="line">            (sz),</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _c(<span class="string">&#x27;span&#x27;</span>,[_v(_s(item))])</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    : _e()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里可能会纳闷了，这些 <code>_c</code>，<code>_l</code> 到底是什么？其实他们是 Vue.js 对一些函数的简写，比如说 <code>_c</code> 对应的是 <code>createElement</code> 这个函数。没关系，我们把它用 VNode 的形式写出来就会明白了，这个对接上一章写的 VNode 函数。</p><p>首先是第一层 div 节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> isShow ? (<span class="keyword">new</span> VNode(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: c</span><br><span class="line">    &#125;, [ <span class="comment">/*这里还有子节点*/</span> ])) : createEmptyVNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在 <code>children</code> 中加上第二层 span 及其子文本节点节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 渲染v-for列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params">val, render</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val.length);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.length; i &lt; l; i++) &#123;</span><br><span class="line">        ret[i] = render(val[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> isShow ? (<span class="keyword">new</span> VNode(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: c</span><br><span class="line">    &#125;, </span><br><span class="line">        <span class="comment">/* begin */</span></span><br><span class="line">        renderList(sz, <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="string">&#x27;span&#x27;</span>, &#123;&#125;, [</span><br><span class="line">                createTextVNode(item);</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* end */</span></span><br><span class="line">    )) : createEmptyVNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何来实现一个 <code>generate</code> 呢？</p><h3 id="genIf"><a href="#genIf" class="headerlink" title="genIf"></a>genIf</h3><p>首先实现一个处理 <code>if</code> 条件的 <code>genIf</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genIf</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.ifProcessed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!el.ifConditions.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;_e()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;el.ifConditions[<span class="number">0</span>].exp&#125;</span>)?<span class="subst">$&#123;genElement(el.ifConditions[<span class="number">0</span>].block)&#125;</span>: _e()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="genFor"><a href="#genFor" class="headerlink" title="genFor"></a>genFor</h3><p>然后是处理 <code>for</code> 循环的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genFor</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.forProcessed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> exp = el.for;</span><br><span class="line">    <span class="keyword">const</span> alias = el.alias;</span><br><span class="line">    <span class="keyword">const</span> iterator1 = el.iterator1 ? <span class="string">`,<span class="subst">$&#123;el.iterator1&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> iterator2 = el.iterator2 ? <span class="string">`,<span class="subst">$&#123;el.iterator2&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_l((<span class="subst">$&#123;exp&#125;</span>),`</span> +</span><br><span class="line">        <span class="string">`function(<span class="subst">$&#123;alias&#125;</span><span class="subst">$&#123;iterator1&#125;</span><span class="subst">$&#123;iterator2&#125;</span>)&#123;`</span> +</span><br><span class="line">        <span class="string">`return <span class="subst">$&#123;genElement(el)&#125;</span>`</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="genText"><a href="#genText" class="headerlink" title="genText"></a>genText</h3><p>处理文本节点的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genText</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;el.expression&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="genElement"><a href="#genElement" class="headerlink" title="genElement"></a>genElement</h3><p>接下来实现一下 <code>genElement</code>，这是一个处理节点的函数，因为它依赖 <code>genChildren</code> 以及g <code>enNode</code> ，所以这三个函数放在一起讲。</p><p>genElement会根据当前节点是否有 <code>if</code> 或者 <code>for</code> 标记然后判断是否要用 <code>genIf</code> 或者 <code>genFor</code> 处理，否则通过 <code>genChildren</code> 处理子节点，同时得到 <code>staticClass</code>、<code>class</code> 等属性。</p><p><code>genChildren</code> 比较简单，遍历所有子节点，通过 <code>genNode</code> 处理后用“，”隔开拼接成字符串。</p><p><code>genNode</code> 则是根据 <code>type</code> 来判断该节点是用文本节点 <code>genText</code> 还是标签节点 <code>genElement</code> 来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genNode</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> genElement(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> genText(el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genChildren</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> children = el.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;children.map(genNode).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genElement</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genIf(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genFor(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = genChildren(el);</span><br><span class="line">        <span class="keyword">let</span> code;</span><br><span class="line">        code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>,&#x27;&#123;</span></span><br><span class="line"><span class="string">            staticClass: <span class="subst">$&#123;el.attrsMap &amp;&amp; el.attrsMap[<span class="string">&#x27;:class&#x27;</span>]&#125;</span>,</span></span><br><span class="line"><span class="string">            class: <span class="subst">$&#123;el.attrsMap &amp;&amp; el.attrsMap[<span class="string">&#x27;class&#x27;</span>]&#125;</span>,</span></span><br><span class="line"><span class="string">        &#125;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">            children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">        &#125;</span>)`</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generate-1"><a href="#generate-1" class="headerlink" title="generate"></a>generate</h3><p>最后我们使用上面的函数来实现 <code>generate</code>，其实很简单，我们只需要将整个 AST 传入后判断是否为空，为空则返回一个 div 标签，否则通过 <code>generate</code> 来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params">rootAst</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> code = rootAst ? genElement(rootAst) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">render</span>: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经历过这些过程以后，我们已经把 template 顺利转成了 render function 了，接下来我们将介绍 <code>patch</code> 的过程，来看一下具体 VNode 节点如何进行差异的比对。</p><p>注：本节代码参考[《template 模板是怎样通过 Compile 编译的》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8Atemplate">https://github.com/answershuto/VueDemo/blob/master/《template</a> 模板是怎样通过 Compile 编译的》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;template-模板是怎样通过-Compile-编译的&quot;&gt;&lt;a href=&quot;#template-模板是怎样通过-Compile-编译的&quot; class=&quot;headerlink&quot; title=&quot;template 模板是怎样通过 Compile 编译的&quot;&gt;&lt;/a&gt;te</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制04</title>
    <link href="http://example.com/2021/08/07/vue2-core04/"/>
    <id>http://example.com/2021/08/07/vue2-core04/</id>
    <published>2021-08-07T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:56.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现-Virtual-DOM-下的一个-VNode-节点"><a href="#实现-Virtual-DOM-下的一个-VNode-节点" class="headerlink" title="实现 Virtual DOM 下的一个 VNode 节点"></a>实现 Virtual DOM 下的一个 VNode 节点</h2><h2 id="什么是VNode"><a href="#什么是VNode" class="headerlink" title="什么是VNode"></a>什么是VNode</h2><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><h2 id="实现一个VNode"><a href="#实现一个VNode" class="headerlink" title="实现一个VNode"></a>实现一个VNode</h2><p>VNode 归根结底就是一个 JavaScript 对象，只要这个类的一些属性可以正确直观地描述清楚当前节点的信息即可。我们来实现一个简单的 <code>VNode</code> 类，加入一些基本属性，为了便于理解，我们先不考虑复杂的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">tag, data, children, text, elm</span>) &#123;</span><br><span class="line">        <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">        <span class="built_in">this</span>.tag = tag;</span><br><span class="line">        <span class="comment">/*当前节点的一些数据信息，比如props、attrs等数据*/</span></span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">        <span class="built_in">this</span>.children = children;</span><br><span class="line">        <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">        <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">        <span class="built_in">this</span>.elm = elm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我目前有这么一个 Vue 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    This is a span.</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>用 JavaScript 代码形式就是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(</span><br><span class="line">        <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 指令集合数组 */</span></span><br><span class="line">            <span class="attr">directives</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* v-show指令 */</span></span><br><span class="line">                    <span class="attr">rawName</span>: <span class="string">&#x27;v-show&#x27;</span>,</span><br><span class="line">                    <span class="attr">expression</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">/* 静态class */</span></span><br><span class="line">            <span class="attr">staticClass</span>: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [ <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">&#x27;This is a span.&#x27;</span>) ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看转换成 VNode 以后的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="comment">/* 指令集合数组 */</span></span><br><span class="line">        <span class="attr">directives</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* v-show指令 */</span></span><br><span class="line">                <span class="attr">rawName</span>: <span class="string">&#x27;v-show&#x27;</span>,</span><br><span class="line">                <span class="attr">expression</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/* 静态class */</span></span><br><span class="line">        <span class="attr">staticClass</span>: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">text</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        <span class="comment">/* 子节点是一个文本VNode节点 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">tag</span>: <span class="literal">undefined</span>,</span><br><span class="line">            <span class="attr">data</span>: <span class="literal">undefined</span>,</span><br><span class="line">            <span class="attr">text</span>: <span class="string">&#x27;This is a span.&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以将 VNode 进一步封装一下，可以实现一些产生常用 VNode 的方法。</p><ul><li>创建一个空节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmptyVNode</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> VNode();</span><br><span class="line">    node.text = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个文本节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>克隆一个 VNode 节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneVNode</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cloneVnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        node.tag,</span><br><span class="line">        node.data,</span><br><span class="line">        node.children,</span><br><span class="line">        node.text,</span><br><span class="line">        node.elm</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> cloneVnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，VNode 就是一个 JavaScript 对象，用 JavaScript 对象的属性来描述当前节点的一些状态，用 VNode 节点的形式来模拟一棵 Virtual DOM 树。</p><p>注：本节代码参考[《实现 Virtual DOM 下的一个 VNode 节点》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%AE%9E%E7%8E%B0">https://github.com/answershuto/VueDemo/blob/master/《实现</a> Virtual DOM 下的一个 VNode 节点》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现-Virtual-DOM-下的一个-VNode-节点&quot;&gt;&lt;a href=&quot;#实现-Virtual-DOM-下的一个-VNode-节点&quot; class=&quot;headerlink&quot; title=&quot;实现 Virtual DOM 下的一个 VNode 节点&quot;&gt;&lt;/a&gt;实现</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制03</title>
    <link href="http://example.com/2021/08/03/vue2-core03/"/>
    <id>http://example.com/2021/08/03/vue2-core03/</id>
    <published>2021-08-03T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式系统的依赖收集追踪原理"><a href="#响应式系统的依赖收集追踪原理" class="headerlink" title="响应式系统的依赖收集追踪原理"></a>响应式系统的依赖收集追踪原理</h2><h2 id="为什么要依赖收集？"><a href="#为什么要依赖收集？" class="headerlink" title="为什么要依赖收集？"></a>为什么要依赖收集？</h2><p><strong>先举个栗子🌰</strong></p><p>我们现在有这么一个 Vue 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">template</span>: </span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text2&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">text1</span>: <span class="string">&#x27;text1&#x27;</span>,</span><br><span class="line">        <span class="attr">text2</span>: <span class="string">&#x27;text2&#x27;</span>,</span><br><span class="line">        <span class="attr">text3</span>: <span class="string">&#x27;text3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们做了这么一个操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.text3 = <span class="string">&#x27;modify text3&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们修改了 <code>data</code> 中 <code>text3</code> 的数据，但是因为视图中并不需要用到 <code>text3</code> ，所以我们并不需要触发上一章所讲的 <code>cb</code> 函数来更新视图，调用 <code>cb</code> 显然是不正确的。</p><p><strong>再来一个栗子🌰</strong></p><p>假设我们现在有一个全局的对象，我们可能会在多个 Vue 对象中用到它进行展示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalObj = &#123;</span><br><span class="line">    <span class="attr">text1</span>: <span class="string">&#x27;text1&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">template</span>:</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>: globalObj</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">template</span>:</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    <span class="attr">data</span>: globalObj</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个时候，我们执行了如下操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalObj.text1 = <span class="string">&#x27;hello,text1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们应该需要通知 <code>o1</code> 以及 <code>o2</code> 两个vm实例进行视图的更新，「依赖收集」会让 <code>text1</code> 这个数据知道“哦～有两个地方依赖我的数据，我变化的时候需要通知它们～”。</p><p>最终会形成数据与视图的一种对应关系，如下图。</p><p><img src="https://img.kancloud.cn/5f/b8/5fb8adff0d214c2d2364b40b475e62d5_610x270.gif" alt="img"></p><p>接下来我们来介绍一下「依赖收集」是如何实现的。</p><h2 id="订阅者-Dep"><a href="#订阅者-Dep" class="headerlink" title="订阅者 Dep"></a>订阅者 Dep</h2><p>首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 <code>Watcher</code> 观察者对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="built_in">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理解我们只实现了添加的部分代码，主要是两件事情：</p><ol><li>用 <code>addSub</code> 方法可以在目前的 <code>Dep</code> 对象中增加一个 <code>Watcher</code> 的订阅操作；</li><li>用 <code>notify</code> 方法通知目前 <code>Dep</code> 对象的 <code>subs</code> 中的所有 <code>Watcher</code> 对象触发更新操作。</li></ol><h2 id="观察者-Watcher"><a href="#观察者-Watcher" class="headerlink" title="观察者 Watcher"></a>观察者 Watcher</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */</span></span><br><span class="line">        Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新视图的方法 */</span></span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;视图更新啦～&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>接下来我们修改一下 <code>defineReactive</code> 以及 Vue 的构造函数，来完成依赖收集。</p><p>我们在闭包中增加了一个 Dep 类的对象，用来收集 <code>Watcher</code> 对象。在对象被「读」的时候，会触发 <code>reactiveGetter</code> 函数把当前的 <code>Watcher</code> 对象（存放在 Dep.target 中）收集到 <code>Dep</code> 类中去。之后如果当该对象被「<strong>写</strong>」的时候，则会触发 <code>reactiveSetter</code> 方法，通知 <code>Dep</code> 类调用 <code>notify</code> 来触发所有 <code>Watcher</code> 对象的 <code>update</code> 方法更新对应视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 一个Dep类对象 */</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* 将Dep.target（即当前的Watcher对象存入dep的subs中） */</span></span><br><span class="line">            dep.addSub(Dep.target);</span><br><span class="line">            <span class="keyword">return</span> val;         </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._data = options.data;</span><br><span class="line">        observer(<span class="built_in">this</span>._data);</span><br><span class="line">        <span class="comment">/* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */</span></span><br><span class="line">        <span class="keyword">new</span> Watcher();</span><br><span class="line">        <span class="comment">/* 在这里模拟render的过程，为了触发test属性的get函数 */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render~&#x27;</span>, <span class="built_in">this</span>._data.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下。</p><p>首先在 <code>observer</code> 的过程中会注册 <code>get</code> 方法，该方法用来进行「<strong>依赖收集</strong>」。在它的闭包中会有一个 <code>Dep</code> 对象，这个对象用来存放 Watcher 对象的实例。其实「<strong>依赖收集</strong>」的过程就是把 <code>Watcher</code> 实例存放到对应的 <code>Dep</code> 对象中去。<code>get</code> 方法可以让当前的 <code>Watcher</code> 对象（Dep.target）存放到它的 subs 中（<code>addSub</code>）方法，在数据变化时，<code>set</code> 会调用 <code>Dep</code> 对象的 <code>notify</code> 方法通知它内部所有的 <code>Watcher</code> 对象进行视图更新。</p><p>这是 <code>Object.defineProperty</code> 的 <code>set/get</code> 方法处理的事情，那么「<strong>依赖收集</strong>」的前提条件还有两个：</p><ol><li>触发 <code>get</code> 方法；</li><li>新建一个 Watcher 对象。</li></ol><p>这个我们在 Vue 的构造类中处理。新建一个 <code>Watcher</code> 对象只需要 new 出来，这时候 <code>Dep.target</code> 已经指向了这个 new 出来的 <code>Watcher</code> 对象来。而触发 <code>get</code> 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 <code>get</code> 进行「依赖收集」。</p><p>本章我们介绍了「依赖收集」的过程，配合之前的响应式原理，已经把整个「响应式系统」介绍完毕了。其主要就是 <code>get</code> 进行「依赖收集」。<code>set</code> 通过观察者来更新视图，配合下图仔细捋一捋，相信一定能搞懂它！</p><p><img src="https://img.kancloud.cn/3f/32/3f32fe9400f1f726e6d10eadd342b277_1460x728.gif" alt="img"></p><p>注：本节代码参考<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86%E3%80%8B.js">《响应式系统的依赖收集追踪原理》</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应式系统的依赖收集追踪原理&quot;&gt;&lt;a href=&quot;#响应式系统的依赖收集追踪原理&quot; class=&quot;headerlink&quot; title=&quot;响应式系统的依赖收集追踪原理&quot;&gt;&lt;/a&gt;响应式系统的依赖收集追踪原理&lt;/h2&gt;&lt;h2 id=&quot;为什么要依赖收集？&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制02</title>
    <link href="http://example.com/2021/07/31/vue2-core02/"/>
    <id>http://example.com/2021/07/31/vue2-core02/</id>
    <published>2021-07-31T07:17:49.000Z</published>
    <updated>2021-09-17T08:11:24.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式系统的基本原理"><a href="#响应式系统的基本原理" class="headerlink" title="响应式系统的基本原理"></a>响应式系统的基本原理</h2><h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><p>Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「<strong>响应式系统</strong>」。尽管我们在使用 Vue.js 进行开发时不会直接修改「<strong>响应式系统</strong>」，但是理解它的实现有助于避开一些常见的「<strong>坑</strong>」，也有助于在遇见一些琢磨不透的问题时可以深入其原理来解决它。</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a><code>Object.defineProperty</code></h2><p>首先我们来介绍一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a>，Vue.js就是基于它实现「<strong>响应式系统</strong>」的。</p><p>首先是使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    obj: 目标对象</span></span><br><span class="line"><span class="comment">    prop: 需要操作的目标对象的属性名</span></span><br><span class="line"><span class="comment">    descriptor: 描述符</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    return value 传入对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p>descriptor的一些属性，简单介绍几个属性，具体可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN 文档</a>。</p><ul><li><code>enumerable</code>，属性是否可枚举，默认 false。</li><li><code>configurable</code>，属性是否可以被修改或者删除，默认 false。</li><li><code>get</code>，获取属性的方法。</li><li><code>set</code>，设置属性的方法。</li></ul><h2 id="实现-observer（可观察的）"><a href="#实现-observer（可观察的）" class="headerlink" title="实现 observer（可观察的）"></a>实现 <code>observer</code>（可观察的）</h2><p>知道了 <code>Object.defineProperty</code> 以后，我们来用它使对象变成可观察的。</p><p>这一部分的内容我们在第二小节中已经初步介绍过，在 <code>init</code> 的阶段会进行初始化，对数据进行「<strong>响应式化</strong>」。</p><p><img src="https://img.kancloud.cn/c4/dd/c4dd695d1c4423aeb8ea55e67fff486d_828x336.gif" alt="img"></p><p>为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。</p><p>首先我们定义一个 <code>cb</code> 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 渲染视图 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;视图更新啦～&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义一个 <code>defineReactive</code> ，这个方法通过 <code>Object.defineProperty</code> 来实现对对象的「<strong>响应式</strong>」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 <code>defineReactive</code> 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 <code>reactiveGetter</code> 方法，而在该属性被「写」的时候则会触发 <code>reactiveSetter</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span>,       <span class="comment">/* 属性可枚举 */</span></span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>,     <span class="comment">/* 属性可被修改或删除 */</span></span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;         <span class="comment">/* 实际上会依赖收集，下一小节会讲 */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">            cb(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这是不够的，我们需要在上面再封装一层 <code>observer</code> 。这个函数传入一个 value（需要「<strong>响应式</strong>」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 <code>defineReactive</code> 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value || (<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        defineReactive(value, key, value[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，让我们用 <code>observer</code> 来封装一个 Vue 吧！</p><p>在 Vue 的构造函数中，对 <code>options</code> 的 <code>data</code> 进行处理，这里的 <code>data</code> 想必大家很熟悉，就是平时我们在写 Vue 项目时组件中的 <code>data</code> 属性（实际上是一个函数，这里当作一个对象来简单处理）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Vue构造类 */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._data = options.data;</span><br><span class="line">        observer(<span class="built_in">this</span>._data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只要 new 一个 Vue 对象，就会将 <code>data</code> 中的数据进行「<strong>响应式</strong>」化。如果我们对 <code>data</code> 的属性进行下面的操作，就会触发 <code>cb</code> 方法更新视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="string">&quot;I am test.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o._data.test = <span class="string">&quot;hello,world.&quot;</span>;  <span class="comment">/* 视图更新啦～ */</span></span><br></pre></td></tr></table></figure><p>至此，响应式原理已经介绍完了，接下来让我们学习「<strong>响应式系统</strong>」的另一部分 ——「<strong>依赖收集</strong>」。</p><p>注：本节代码参考<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%8B.js">《响应式系统的基本原理》</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应式系统的基本原理&quot;&gt;&lt;a href=&quot;#响应式系统的基本原理&quot; class=&quot;headerlink&quot; title=&quot;响应式系统的基本原理&quot;&gt;&lt;/a&gt;响应式系统的基本原理&lt;/h2&gt;&lt;h2 id=&quot;响应式系统&quot;&gt;&lt;a href=&quot;#响应式系统&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制01</title>
    <link href="http://example.com/2021/07/27/vue2-core01/"/>
    <id>http://example.com/2021/07/27/vue2-core01/</id>
    <published>2021-07-27T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:02.359Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自<a href="https://www.kancloud.cn/sllyli/vuejs">看云</a>《剖析vue.js内部运行机制》</p><h2 id="Vue-js-运行机制全局概览"><a href="#Vue-js-运行机制全局概览" class="headerlink" title="Vue.js 运行机制全局概览"></a>Vue.js 运行机制全局概览</h2><h2 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h2><p>这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。</p><p>首先我们来看一下笔者画的内部流程图。</p><p><img src="https://img.kancloud.cn/01/db/01db136b4380b1804c072899e92daa3d_1752x1216.gif" alt="img"></p><p>大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。</p><h2 id="初始化及挂载"><a href="#初始化及挂载" class="headerlink" title="初始化及挂载"></a>初始化及挂载</h2><p><img src="https://img.kancloud.cn/c4/dd/c4dd695d1c4423aeb8ea55e67fff486d_828x336.gif" alt="img"></p><p>在 <code>new Vue()</code> 之后。 Vue 会调用 <code>_init</code> 函数进行初始化，也就是这里的 <code>init</code> 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 <code>Object.defineProperty</code> 设置 <code>setter</code> 与 <code>getter</code> 函数，用来实现「<strong>响应式</strong>」以及「<strong>依赖收集</strong>」，后面会详细讲到，这里只要有一个印象即可。</p><p>初始化之后调用 <code>$mount</code> 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「<strong>编译</strong>」步骤。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>compile编译可以分成 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 三个阶段，最终需要得到 render function。</p><p><img src="https://img.kancloud.cn/7e/80/7e80fcd4e490557058f4e19af76e5795_824x496.gif" alt="img"></p><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p><code>parse</code> 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。</p><h3 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h3><p><code>optimize</code> 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 <code>update</code> 更新界面时，会有一个 <code>patch</code> 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p><code>generate</code> 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。</p><p>在经历过 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>接下来也就是 Vue.js 响应式核心部分。</p><p><img src="https://img.kancloud.cn/3f/32/3f32fe9400f1f726e6d10eadd342b277_1460x728.gif" alt="img"></p><p>这里的 <code>getter</code> 跟 <code>setter</code> 已经在之前介绍过了，在 <code>init</code> 的时候通过 <code>Object.defineProperty</code> 进行了绑定，它使得当被设置的对象被读取的时候会执行 <code>getter</code> 函数，而在当被赋值的时候会执行 <code>setter</code> 函数。</p><p>当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 <code>getter</code> 函数进行「<strong>依赖收集</strong>」，「<strong>依赖收集</strong>」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。</p><p><img src="https://img.kancloud.cn/43/c8/43c84091dc595cdf3eb9db090b7aec13_520x245.gif" alt="img"></p><p>在修改对象的值的时候，会触发对应的 <code>setter</code>， <code>setter</code> 通知之前「<strong>依赖收集</strong>」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 <code>update</code> 来更新视图，当然这中间还有一个 <code>patch</code> 的过程以及使用队列来异步更新的策略，这个我们后面再讲。</p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><p>比如说下面这样一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;div&#x27;</span>,                 <span class="comment">/*说明这是一个div标签*/</span></span><br><span class="line">    <span class="attr">children</span>: [                 <span class="comment">/*存放该标签的子节点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">tag</span>: <span class="string">&#x27;a&#x27;</span>,           <span class="comment">/*说明这是一个a标签*/</span></span><br><span class="line">            <span class="attr">text</span>: <span class="string">&#x27;click me&#x27;</span>    <span class="comment">/*标签的内容*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染后可以得到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">a</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。</p><h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p><img src="https://img.kancloud.cn/d1/dc/d1dc77e6aec6a13caa86bc32afd24509_731x339.gif" alt="img"></p><p>前面我们说到，在修改一个对象值的时候，会通过 <code>setter -&gt; Watcher -&gt; update</code> 的流程来修改对应的视图，那么最终是如何更新视图的呢？</p><p>当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 <code>innerHTML</code> 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「<strong>浪费</strong>」。</p><p>那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「**<code>patch</code><strong>」了。我们会将新的 VNode 与旧的 VNode 一起传入 <code>patch</code> 进行比较，经过 diff 算法得出它们的「</strong>差异<strong>」。最后我们只需要将这些「</strong>差异**」的对应 DOM 进行修改即可。</p><h2 id="再看全局"><a href="#再看全局" class="headerlink" title="再看全局"></a>再看全局</h2><p><img src="https://img.kancloud.cn/01/db/01db136b4380b1804c072899e92daa3d_1752x1216.gif" alt="img"></p><p>回过头再来看看这张图，是不是大脑中已经有一个大概的脉络了呢？</p><p><strong>那么，让我们继续学习每一个模块吧!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章转载自&lt;a href=&quot;https://www.kancloud.cn/sllyli/vuejs&quot;&gt;看云&lt;/a&gt;《剖析vue.js内部运行机制》&lt;/p&gt;
&lt;h2 id=&quot;Vue-js-运行机制全局概览&quot;&gt;&lt;a href=&quot;#Vue-js-运行机制全局概览&quot; class=</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue+echarts重复渲染循环数据格式</title>
    <link href="http://example.com/2021/07/21/Vue-echarts/"/>
    <id>http://example.com/2021/07/21/Vue-echarts/</id>
    <published>2021-07-21T10:25:06.000Z</published>
    <updated>2021-09-17T08:20:16.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Vue项目中封装echarts"><a href="#在Vue项目中封装echarts" class="headerlink" title="在Vue项目中封装echarts"></a>在Vue项目中封装echarts</h1><blockquote><p>文章目的：在vue项目中使用echarts针对相同类型的数据渲染，无法定位渲染id和繁琐问题</p></blockquote><h3 id="先看效果图"><a href="#先看效果图" class="headerlink" title="先看效果图"></a>先看效果图</h3><p><img src="/images/Vue-echarts/image-20210814185111072.png" alt="image-20210814185111072"></p><h2 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install echarts</span><br></pre></td></tr></table></figure><h2 id="在main-js中引入依赖"><a href="#在main-js中引入依赖" class="headerlink" title="在main.js中引入依赖"></a>在main.js中引入依赖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入echarts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="在公共的方法文件夹中创建echarts-js文件"><a href="#在公共的方法文件夹中创建echarts-js文件" class="headerlink" title="在公共的方法文件夹中创建echarts.js文件"></a>在公共的方法文件夹中创建echarts.js文件</h2><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/util/echarts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">echarts, id, seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(seriesdata)<span class="comment">//echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">        <span class="built_in">this</span>.echarts = echarts;</span><br><span class="line">        <span class="keyword">let</span> option = <span class="built_in">this</span>.getOption(seriesdata, answerTotal)  <span class="comment">//把参数传递给方法</span></span><br><span class="line">        <span class="keyword">var</span> myChart = <span class="built_in">this</span>.echarts.init(<span class="built_in">document</span>.getElementById(id));<span class="comment">//获取dom</span></span><br><span class="line">        myChart.setOption(option);     <span class="comment">//暴露出去</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOption</span>(<span class="params">seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> option = &#123;</span><br><span class="line">            <span class="comment">// 环形中间的标题</span></span><br><span class="line">            <span class="attr">title</span>: &#123;</span><br><span class="line">                <span class="attr">text</span>: answerTotal + <span class="string">&quot;人&quot;</span>,</span><br><span class="line">                <span class="attr">left</span>: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                <span class="attr">top</span>: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line">                <span class="attr">textStyle</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: <span class="string">&quot;#27D9C8&quot;</span>,</span><br><span class="line">                    <span class="attr">fontSize</span>: <span class="number">18</span>,</span><br><span class="line">                    <span class="attr">align</span>: <span class="string">&quot;center&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 环形中间的标题</span></span><br><span class="line">            <span class="attr">graphic</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                <span class="attr">left</span>: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                <span class="attr">top</span>: <span class="string">&quot;40%&quot;</span>,</span><br><span class="line">                <span class="attr">style</span>: &#123;</span><br><span class="line">                    <span class="attr">text</span>: <span class="string">&quot;实测&quot;</span>,</span><br><span class="line">                    <span class="attr">textAlign</span>: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                    <span class="attr">fill</span>: <span class="string">&quot;#333&quot;</span>,</span><br><span class="line">                    <span class="attr">fontSize</span>: <span class="number">18</span>,</span><br><span class="line">                    <span class="attr">fontWeight</span>: <span class="number">700</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">legend</span>: &#123;</span><br><span class="line">                <span class="attr">show</span>: <span class="literal">false</span>, <span class="comment">//图例显示与隐藏</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">series</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">                    <span class="comment">// roseType: &#x27;area&#x27;,</span></span><br><span class="line">                    <span class="attr">radius</span>: [<span class="string">&#x27;40%&#x27;</span>, <span class="string">&#x27;60%&#x27;</span>],</span><br><span class="line">                    <span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line"></span><br><span class="line">                    <span class="attr">label</span>: &#123;</span><br><span class="line">                        <span class="attr">alignTo</span>: <span class="string">&#x27;edge&#x27;</span>,</span><br><span class="line">                        <span class="attr">formatter</span>: <span class="string">&#x27;&#123;name|&#123;b&#125;&#125;\n&#123;time|&#123;c&#125; 人&#125;&#x27;</span>,</span><br><span class="line">                        <span class="attr">minMargin</span>: <span class="number">5</span>,</span><br><span class="line">                        <span class="attr">edgeDistance</span>: <span class="number">10</span>,</span><br><span class="line">                        <span class="attr">lineHeight</span>: <span class="number">15</span>,</span><br><span class="line">                        <span class="attr">rich</span>: &#123;</span><br><span class="line">                            <span class="attr">time</span>: &#123;</span><br><span class="line">                                <span class="attr">fontSize</span>: <span class="number">10</span>,</span><br><span class="line">                                <span class="attr">color</span>: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">                        <span class="attr">normal</span>: &#123;</span><br><span class="line">                            <span class="attr">color</span>: <span class="function"><span class="keyword">function</span> (<span class="params">colors</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> colorList = [<span class="string">&#x27;#FF8400&#x27;</span>, <span class="string">&#x27;#EEC23A&#x27;</span>, <span class="string">&#x27;#EEE93A&#x27;</span>, <span class="string">&#x27;#CCCCCC&#x27;</span>];</span><br><span class="line">                                <span class="keyword">return</span> colorList[colors.dataIndex]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="attr">shadowBlur</span>: <span class="number">200</span>,</span><br><span class="line">                        <span class="attr">shadowColor</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.5)&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">data</span>: seriesdata,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在Vue所需echarts文件中引入该echarts-js文件"><a href="#在Vue所需echarts文件中引入该echarts-js文件" class="headerlink" title="在Vue所需echarts文件中引入该echarts.js文件"></a>在Vue所需echarts文件中引入该echarts.js文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入封装的echarts方法</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&quot;@/util/echarts.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="规划好echarts放置的地方"><a href="#规划好echarts放置的地方" class="headerlink" title="规划好echarts放置的地方"></a>规划好echarts放置的地方</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px; height: 400px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //echarts存放的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实例化一个渲染echarts的方法"><a href="#实例化一个渲染echarts的方法" class="headerlink" title="实例化一个渲染echarts的方法"></a>实例化一个渲染echarts的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addEcharts</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> echarts(<span class="built_in">this</span>.$echarts, <span class="string">&quot;main&quot;</span>, <span class="built_in">this</span>.seriesdata,<span class="built_in">this</span>.answerTotal);  </span><br><span class="line">      <span class="comment">//echarts传参，this.$echarts声明是echarts，main是div的ID, this.seriesdata,this.answerTotal是传递参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="在Vue生命周期mounted阶段调用该方法"><a href="#在Vue生命周期mounted阶段调用该方法" class="headerlink" title="在Vue生命周期mounted阶段调用该方法"></a>在Vue生命周期mounted阶段调用该方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.addEcharts();  <span class="comment">//调用组件的时候自动调用这个方法</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h2><p><img src="/images/Vue-echarts/image-20210814185044874.png" alt="image-20210814185044874"></p><h2 id="可能遇到的问题（待补充）"><a href="#可能遇到的问题（待补充）" class="headerlink" title="可能遇到的问题（待补充）"></a>可能遇到的问题（待补充）</h2><h3 id="echarts-js-5fd2-7-Uncaught-in-promise-TypeError-Cannot-read-property-‘init’-of-undefined"><a href="#echarts-js-5fd2-7-Uncaught-in-promise-TypeError-Cannot-read-property-‘init’-of-undefined" class="headerlink" title="echarts.js?5fd2:7 Uncaught (in promise) TypeError: Cannot read property ‘init’ of undefined"></a>echarts.js?5fd2:7 Uncaught (in promise) TypeError: Cannot read property ‘init’ of undefined</h3><p><img src="/images/Vue-echarts/image-20210814184516054.png" alt="image-20210814184516054"></p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>对于数据加载和dom初始化过程，如果不加限制 使用echarts 绘图的js方法<strong>有很大机率</strong>先于dom初始完成之前运行，所以造成图表不显示。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>使用setTimeout函数延迟运行绘图的js.时间在500毫秒左右,可根据情况调整；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/util/echarts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">echarts, id, seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(seriesdata)<span class="comment">//echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">        <span class="built_in">this</span>.echarts = echarts;</span><br><span class="line">        <span class="keyword">let</span> option = <span class="built_in">this</span>.getOption(seriesdata, answerTotal)  <span class="comment">//把参数传递给方法</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改的地方👇👇👇</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myChart = <span class="built_in">this</span>.echarts.init(<span class="built_in">document</span>.getElementById(id));<span class="comment">//获取dom</span></span><br><span class="line">        myChart.setOption(option);     <span class="comment">//暴露出去</span></span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">        <span class="comment">// 修改的地方👆👆👆</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOption</span>(<span class="params">seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> option = &#123;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ...(中间均未发生改变)</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">data</span>: seriesdata,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Vue项目中封装echarts&quot;&gt;&lt;a href=&quot;#在Vue项目中封装echarts&quot; class=&quot;headerlink&quot; title=&quot;在Vue项目中封装echarts&quot;&gt;&lt;/a&gt;在Vue项目中封装echarts&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;文</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="项目学习" scheme="http://example.com/categories/Vue/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Project" scheme="http://example.com/tags/Project/"/>
    
    <category term="echarts" scheme="http://example.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>前端面试exp01</title>
    <link href="http://example.com/2021/07/15/interview-exp01/"/>
    <id>http://example.com/2021/07/15/interview-exp01/</id>
    <published>2021-07-15T06:33:12.000Z</published>
    <updated>2021-09-23T13:24:50.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍-amp-项目介绍"><a href="#自我介绍-amp-项目介绍" class="headerlink" title="自我介绍 &amp; 项目介绍"></a>自我介绍 &amp; 项目介绍</h2><h2 id="从用户输入URL到看到页面，这个过程中都发生了什么？"><a href="#从用户输入URL到看到页面，这个过程中都发生了什么？" class="headerlink" title="从用户输入URL到看到页面，这个过程中都发生了什么？"></a>从用户输入URL到看到页面，这个过程中都发生了什么？</h2><p><img src="../images/interview-exp01/image-20210904205421204.png" alt="image-20210904205421204"></p><h2 id="defer-amp-async-的区别"><a href="#defer-amp-async-的区别" class="headerlink" title="defer &amp; async 的区别"></a>defer &amp; async 的区别</h2><p> defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 一句话，defer是“渲染完再执行”，async是“下载完就执行”。 另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p><h2 id="为什么加载同步script标签中的内容会阻塞文档渲染？"><a href="#为什么加载同步script标签中的内容会阻塞文档渲染？" class="headerlink" title="为什么加载同步script标签中的内容会阻塞文档渲染？"></a>为什么加载同步script标签中的内容会阻塞文档渲染？</h2><p>JavaScript是单线程的语言。</p><p>单线程意味着什麽呢？意味着一次只能干一件事。这条线程，被JavaScript的执行和浏览器的渲染所共享（也就是说两者用的均是这一条线程，浏览器在某个时间点只能执行JS或渲染UI一个动作）。</p><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><p><img src="../images/interview-exp01/image-20210917144847187.png" alt="image-20210917144847187"></p><p><img src="../images/interview-exp01/image-20210917144858432.png" alt="image-20210917144858432"></p><h2 id="对BFC语法规范的理解？"><a href="#对BFC语法规范的理解？" class="headerlink" title="对BFC语法规范的理解？"></a>对BFC语法规范的理解？</h2><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。可以把它理解成一个独立的区域</p><p>另外还有个概念叫<code>IFC</code>（IFC的line box（线框高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响）。不过，<code>BFC</code>问得更多。</p><p><strong>如何生成BFC</strong></p><p>1、overflow<code>: 不为</code>visible</p><p>2、浮动中：不为none</p><p>3、定位中：不为static</p><p>4、display：flex，inline-block</p><h2 id="对“闭包”的理解？"><a href="#对“闭包”的理解？" class="headerlink" title="对“闭包”的理解？"></a>对“闭包”的理解？</h2><p>　　在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。</p><p><strong>优点：</strong></p><p>1、可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用。</p><p>2、避免变量污染全局。</p><p>3、把变量存到独立的作用域，作为私有成员存在。</p><p><strong>缺点：</strong></p><p>1、对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。</p><p>2、对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域长度。</p><h2 id="防抖-amp-节流-的原理及应用场景？"><a href="#防抖-amp-节流-的原理及应用场景？" class="headerlink" title="防抖 &amp; 节流 的原理及应用场景？"></a>防抖 &amp; 节流 的原理及应用场景？</h2><p>1、基本概念</p><p> 防抖：最后一次点击事件后time过后才会执行</p><p>节流：持续触发事件时，保证一定time内执行一次</p><p>2、分别适合用在什么场景：</p><p>防抖：input   </p><p>节流：resize   scroll</p><h2 id="滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景"><a href="#滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景" class="headerlink" title="滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景"></a>滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景</h2><p>①scrollTop/scrollLeft:滚动的距离，一开始默认都是0，往下滚动scrollTop增加，往右scrollLeft增加。</p><p>②scrollHeight/scrollWidth:整个页面内容的大小，包括被隐藏的部分。</p><p>③clientHeight/clientWidth:视图显示部分的大小</p><p>①判断滚动方向，记录之前的scrollTop，scrollLeft，然后触发后进行比较判断</p><p>②判断是否到达顶部底部，scrollTop+clientHeight == scrollHeight到达底部</p><h2 id="JS的异步处理函数有哪些？（具体阐述，ES5-–-gt-ES6）"><a href="#JS的异步处理函数有哪些？（具体阐述，ES5-–-gt-ES6）" class="headerlink" title="JS的异步处理函数有哪些？（具体阐述，ES5 –&gt; ES6）"></a>JS的异步处理函数有哪些？（具体阐述，ES5 –&gt; ES6）</h2><p>setTimeout、setInterval、promise、async await</p><h2 id="关于async和await的应用场景题"><a href="#关于async和await的应用场景题" class="headerlink" title="关于async和await的应用场景题"></a>关于async和await的应用场景题</h2><p> 一个请求接着一个请求：后一个请求依赖前一个请求返回值</p><p> 请求后的错误处理：使用 try/catch 直接捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">imageCrawler</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">await</span> getImage(url)</span><br><span class="line">        <span class="keyword">return</span> img</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）"><a href="#浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）" class="headerlink" title="浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）"></a>浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）</h2><p>宏任务：整体代码，setTimeout，setInterval，I/O操作</p><p>微任务：new Promise().then ，MutaionObserver（前端的回溯）</p><p>Node V10以后和浏览器的行为统一了：先执行完一轮宏任务，再去清空微任务队列.</p><h2 id="Vue的双向数据绑定原理"><a href="#Vue的双向数据绑定原理" class="headerlink" title="Vue的双向数据绑定原理"></a>Vue的双向数据绑定原理</h2><p>利用Object.defineProperty()数据劫持，结合发布者-订阅者模式实现的。</p><p><strong>数据劫持</strong>：Object.defineProperty()：简单的说 就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法，当我们给这个属性赋值的时候，又用到了它里面的set方法</p><p><strong>发布者-订阅者</strong>：</p><p> 前面所讲的数据劫持，其实就是为属性创建了一个观察者对象，监听数据的变化。接下来就是创建发布类和订阅类，如下：</p><p><img src="https://img-blog.csdnimg.cn/20190420173653318.png" alt="img"></p><p><strong>observer</strong>，创建数据监听，并为每个属性建立一个发布类。</p><p><strong>Dep</strong>是发布类，维护与该属性相关的订阅实例，当数据发生更新时，会通知所有的订阅实例。</p><p><strong>Watcher</strong>是订阅类，注册到所有相关属性的Dep发布类中，接受发布类的数据变更通知，通过回调，实现视图的更新。</p><h2 id="Vue的diff算法"><a href="#Vue的diff算法" class="headerlink" title="Vue的diff算法"></a>Vue的diff算法</h2><p><code>diff</code> 算法只对同级节点进行对比</p><p>都用key做为唯一标识，进行查找，只有key和标签类型相同时才会复用老节点（遍历前都会根据老的节点构建一个map，方便根据key快速查找）</p><p>ps：与react不同的是，react 采用从左向右进行遍历</p><h2 id="使用v-for渲染列表是key值的作用？"><a href="#使用v-for渲染列表是key值的作用？" class="headerlink" title="使用v-for渲染列表是key值的作用？"></a>使用v-for渲染列表是key值的作用？</h2><p>key的作用让列表中每个item都有一个唯一的识别身份，可以下标值index或者id, 主要是为了vue精准的追踪到每一个元素，高效的更新虚拟DOM。</p><h2 id="项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）"><a href="#项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）" class="headerlink" title="项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）"></a>项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）</h2><p><strong>原理：</strong>首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。<br><strong>优点：</strong>页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p><p><strong>不足：</strong>数据量大的时候，加载速度依旧很慢</p><p><strong>优化：</strong>缩略图格式（压缩资源大小）</p><h2 id="项目中遇到的问题？"><a href="#项目中遇到的问题？" class="headerlink" title="项目中遇到的问题？"></a>项目中遇到的问题？</h2><h3 id="使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义"><a href="#使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义" class="headerlink" title="使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义"></a>使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义</h3><p>this.$nextTick()将回调延迟到下次 DOM 更新之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p><p>由于dom元素还没有更新， 因此打印出来的还是未改变之前的值，而通过this.$nextTick()获取到的值为dom更新之后的值</p><h2 id="小程序的样式适配怎么做的"><a href="#小程序的样式适配怎么做的" class="headerlink" title="小程序的样式适配怎么做的"></a>小程序的样式适配怎么做的</h2><p>小程序的适配原理，提出了一种新单位rpx，可以根据屏幕宽度进行自适应，规定屏幕宽为750rpx</p><p><strong>微信官方提供的换算方式</strong>：rpx = px * (目标设备宽 px 值 / 750)</p><p>在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p><p><strong>一般情况设计稿是按照iphone6尺寸设计的，设计稿上尺寸大小可以直接等于rpx</strong></p><h2 id="CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置"><a href="#CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置" class="headerlink" title="CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置"></a>CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置</h2><p>flex布局下的一个属性：align-self</p><h2 id="CSS选择器（常见的，伪类选择器用过哪些，-before-after应用场景）"><a href="#CSS选择器（常见的，伪类选择器用过哪些，-before-after应用场景）" class="headerlink" title="CSS选择器（常见的，伪类选择器用过哪些，::before ::after应用场景）"></a>CSS选择器（常见的，伪类选择器用过哪些，::before ::after应用场景）</h2><p>常见伪类——:hover,:link,:active,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让超链接点击之前是红色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*让超链接点击之后是橙色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: orange;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标悬停，放到标签上的时候是绿色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标点击链接，但是不松手的时候*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: black;&#125;</span><br></pre></td></tr></table></figure><p>常见伪元素——::before,::after,</p><p>::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。</p><p>这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。</p><p>所以不要用:before或:after展示有实际意义的内容，尽量使用它们显示修饰性内容，例如图标。</p><p>举例：网站有些联系电话，希望在它们前加一个icon☎，就可以使用:before伪元素，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.phoneNumber</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;\260E&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;phoneNumber&quot;</span>&gt;</span>12345645654<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最常用的就是清除浮动</p><h2 id="选择器优先级排列"><a href="#选择器优先级排列" class="headerlink" title="选择器优先级排列"></a>选择器优先级排列</h2><p>内联样式 =&gt; id(id选择器) =&gt; class(类选择器) =&gt; div(标签选择器) =&gt; ul&gt;li子选择器() =&gt; li a(后代选择器) =&gt; a:hover(伪类选择器) </p><p><strong>选择器的权值加到一起，大的优先；如果权值相同，后定义的优先</strong> </p><h2 id="CSS函数用过嘛？常见的calc-函数-计算长度值，-var"><a href="#CSS函数用过嘛？常见的calc-函数-计算长度值，-var" class="headerlink" title="CSS函数用过嘛？常见的calc()函数 计算长度值， var()"></a>CSS函数用过嘛？常见的calc()函数 计算长度值， var()</h2><h3 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h3><p>这个函数使我们能够计算CSS值，而不是指定确切的值。通常用于计算元素的大小或位置。它支持加法、减法、乘法和除法。</p><p><strong>需要特别注意重要一点</strong>是<code>+</code>和<code>-</code>运算符<strong>必须用空格隔开</strong>，不然无法正常工作。<code>*</code>和<code>/</code>运算符不有这限制，但出于一致性的考虑，建议添加空格。</p><p>实践例子：水平居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;calc&quot;</span>&gt;</span>Centered with calc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.calc</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">100px</span>)//页面总长度的一半减去自身长度的一半</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h3><p>通过这个函数，我们可以使用一个自定义属性的值作为另一个CSS属性的值。简单地说，可以定义一个颜色，放在自定义属性(CSS变量)中，然后通过调用var函数重用该属性值。</p><p>此函数接受两个参数，即自定义属性和一个默认值，如果出现问题，将使用默认值。</p><p>实践例子：一个网站的主题色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --bg-<span class="attribute">color</span>: green;//通过 --前缀来实现自定义</span><br><span class="line">  --<span class="attribute">color</span>: white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.var</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg-color);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js如何判断数组-Array-isArray-instanceof-原理"><a href="#js如何判断数组-Array-isArray-instanceof-原理" class="headerlink" title="js如何判断数组  Array.isArray()   instanceof 原理"></a>js如何判断数组  Array.isArray()   instanceof 原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理解就是运用对象原型的toString方法将Array转换为字符串，之后进行比对，下面我们来详细分析下各个部分的组成。<br>Object.prototype.toString代表这个toString方法本来是对象原型上面的，之后call方法将toString方法中的this转换为参数value，这样传进的参数value（实际上对于此方法应该是个数组[]）就可以通过原型的方法来转换为字符串。</p><h3 id="value-instanceof-Type-true-false"><a href="#value-instanceof-Type-true-false" class="headerlink" title="value instanceof Type == true/false"></a>value instanceof Type == true/false</h3><p> instanceof实现原理：看左边实例的–proto–指向的原型链上，有没有跟右侧类型的prototype指向同一个对象</p><h2 id="JS对象深拷贝"><a href="#JS对象深拷贝" class="headerlink" title="JS对象深拷贝"></a>JS对象深拷贝</h2><p>使用JSON.parse（）和 JSON.stringify（）对对象进行深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(会忽略function和undefined的字段，只能克隆原始对象自身的值，不能克隆它继承的值)</p><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="事件循环（Event-Loop）机制"><a href="#事件循环（Event-Loop）机制" class="headerlink" title="事件循环（Event Loop）机制"></a>事件循环（Event Loop）机制</h2><p>js是单线程的 </p><p>宏任务：整体代码，setTimeout，setInterval，I/O操作</p><p>微任务：new Promise（）.then ，MutaionObserver（前端的回溯）</p><h2 id="二分法查找时间复杂度O-logn-、-快排时间复杂度O-nlogn"><a href="#二分法查找时间复杂度O-logn-、-快排时间复杂度O-nlogn" class="headerlink" title="二分法查找时间复杂度O(logn)、 快排时间复杂度O(nlogn)"></a>二分法查找时间复杂度O(logn)、 快排时间复杂度O(nlogn)</h2><p>二分查找：假设一个数组长度为n,每次查找后数据长度减半，第一次查找后数据长度为n/2,第二次查找后数据长度为n/(2的2次方)，第k次查找后数据长度为n/(2的k次方)，最坏情况下数数据长度为1时找到该数，即n/(2的k次方)=1, 解得k=log2n</p><p>快排基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>冒泡排序：O(n^2)</p><h2 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h2><p>栈：先进后出</p><p>队列：先进先出</p><h2 id="打印二叉树用什么数据结构"><a href="#打印二叉树用什么数据结构" class="headerlink" title="打印二叉树用什么数据结构"></a>打印二叉树用什么数据结构</h2><p> 队列</p><h2 id="遍历对象和数组的方法"><a href="#遍历对象和数组的方法" class="headerlink" title="遍历对象和数组的方法"></a>遍历对象和数组的方法</h2><p>遍历对象：for…in、Object.keys().forEach()</p><p>遍历数组：forEach、map、for循环遍历、for…in、for…of(只能遍历出value，无下标)</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><h3 id="大概多久出面试结果？"><a href="#大概多久出面试结果？" class="headerlink" title="大概多久出面试结果？"></a>大概多久出面试结果？</h3><h3 id="对我此次面试表现的评价？"><a href="#对我此次面试表现的评价？" class="headerlink" title="对我此次面试表现的评价？"></a>对我此次面试表现的评价？</h3><h3 id="跟同批次同学相比优点和缺点？"><a href="#跟同批次同学相比优点和缺点？" class="headerlink" title="跟同批次同学相比优点和缺点？"></a>跟同批次同学相比优点和缺点？</h3><h3 id="对于缺点和差距有什么指导性建议？"><a href="#对于缺点和差距有什么指导性建议？" class="headerlink" title="对于缺点和差距有什么指导性建议？"></a>对于缺点和差距有什么指导性建议？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自我介绍-amp-项目介绍&quot;&gt;&lt;a href=&quot;#自我介绍-amp-项目介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍 &amp;amp; 项目介绍&quot;&gt;&lt;/a&gt;自我介绍 &amp;amp; 项目介绍&lt;/h2&gt;&lt;h2 id=&quot;从用户输入URL到看到页面，这个过</summary>
      
    
    
    
    <category term="FE-Interview" scheme="http://example.com/categories/FE-Interview/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue3-Vue2</title>
    <link href="http://example.com/2021/06/20/vue3-vue2/"/>
    <id>http://example.com/2021/06/20/vue3-vue2/</id>
    <published>2021-06-20T11:01:24.000Z</published>
    <updated>2021-09-17T07:16:57.030Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>vue3 相比 vue2 的十项优点</strong></p><p>本文章转载自华为云社区《<a href="https://www.oschina.net/action/GoToLink?url=https://bbs.huaweicloud.com/blogs/300280?utm_source=oschina&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">【云驻共创】vue3 相比 vue2 的十项优点</a>》，作者：海拥</p><p>Vue3新版本的理念成型于 2018 年末，当时的 Vue 2 已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，Vue3在2020年正式推出，在源码和API都有较大变化，性能得到了显著的提升，比Vue2.x快1.2~2倍。</p><p><strong>其中，一些比较重要的优点有：</strong></p><p>diff算法的优化；hoistStatic 静态提升；cacheHandlers 事件侦听器缓存；ssr渲染；更好的Ts支持；Compostion API: 组合API/注入API；更先进的组件；自定义渲染API；按需编译，体积比vue2.x更小；支持多根节点组件等。下面我们就来具体说说vue3 的优点：</p><h2 id="优点1：diff算法的优化"><a href="#优点1：diff算法的优化" class="headerlink" title="优点1：diff算法的优化"></a><strong>优点1：diff算法的优化</strong></h2><p>vue2中的虚拟dom是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上）</p><p>vue3新增了静态标记（patchflag）与上次虚拟节点对比时，只对比带有patch flag的节点（动态数据所在的节点）；可通过flag信息得知当前节点要对比的具体内容。</p><p>例如：下面的模板包含一个div，div内包含三个段落，其中前两个段落是静态固定不变的，而第三个段落的内容绑定的msg属性，当msg改变的时候，Vue会生成新的虚拟DOM然后和旧的进行对比。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>云驻共创<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>如何评价 vue3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当视图更新时，只对动态节点部分进行diff运算，减少了资源的损耗。Patchflag是个枚举，取值为1代表这个元素的文本是动态绑定的，取值为2代表元素的class是动态绑定的。</p><h2 id="优点2：hoistStatic-静态提升"><a href="#优点2：hoistStatic-静态提升" class="headerlink" title="优点2：hoistStatic 静态提升"></a><strong>优点2：hoistStatic 静态提升</strong></h2><p>vue2无论元素是否参与更新，每次都会重新创建然后再渲染。</p><p>vue3对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可。<br>例如：下面我们利用Vue 3 Template Explorer,来直观的感受一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>共创1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>共创2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>静态提升之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        _openBlock(),</span><br><span class="line">        _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;共创1&#x27;</span>),</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;共创2&#x27;</span>),</span><br><span class="line">            _createVNode(</span><br><span class="line">                <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                _toDisplayString(_ctx.name),</span><br><span class="line">                <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">            ),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态提升之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;共创1&#x27;</span>,</span><br><span class="line">    -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;共创2&#x27;</span>,</span><br><span class="line">    -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        _openBlock(),</span><br><span class="line">        _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _hoisted_1,</span><br><span class="line">            _hoisted_2,</span><br><span class="line">            _createVNode(</span><br><span class="line">                <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                _toDisplayString(_ctx.name),</span><br><span class="line">                <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">            ),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看出，_hoisted_1 和_hoisted_2 两个方法被提升到了渲染函数 render 之外，也就是我们说的静态提升。通过静态提升可以避免每次渲染的时候都要重新创建这些对象，从而大大提高了渲染效率。</p><h2 id="优点3：cacheHandlers-事件侦听器缓存"><a href="#优点3：cacheHandlers-事件侦听器缓存" class="headerlink" title="优点3：cacheHandlers 事件侦听器缓存"></a><strong>优点3：cacheHandlers 事件侦听器缓存</strong></h2><p>vue2.x中，绑定事件每次触发都要重新生成全新的function去更新，cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新。</p><p>默认情况下onClick会被视为动态绑定，所以每次都会追踪它的变化，但是同一个函数没必要追踪变化，直接缓存起来复用即可。</p><p>例如：下面我们同样是通过Vue 3 Template Explorer，来看一下事件监听器缓存的作用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;todo&quot;</span>&gt;</span>做点有趣的事<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该段 html 经过编译后变成我们下面的结构(未开启事件监听缓存)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_openBlock(),_createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>,&#123; <span class="attr">onClick</span>: _ctx.todo&#125;, <span class="string">&#x27;做点有趣的事&#x27;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>,</span><br><span class="line">                [<span class="string">&#x27;onClick&#x27;</span>]),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们开启事件监听器缓存后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_openBlock(),_createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>,&#123;</span><br><span class="line">                    <span class="attr">onClick</span>:    <span class="comment">//开启监听后</span></span><br><span class="line">                        _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span>_ctx.todo(...args)),</span><br><span class="line">                &#125;,<span class="string">&#x27;做点有趣的事&#x27;</span>),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对比开启事件监听缓存前后的代码，转换之后的代码, 大家可能还看不懂, 但是不要紧，我们只需要观察有没有静态标记即可，在Vue3的diff算法中, 只有有静态标记的才会进行比较, 才会进行追踪。</p><h2 id="优点4：ssr渲染"><a href="#优点4：ssr渲染" class="headerlink" title="优点4：ssr渲染"></a><strong>优点4：ssr渲染</strong></h2><p>Vue2 中也是有 SSR 渲染的，但是 Vue3 中的 SSR 渲染相对于 Vue2 来说，性能方面也有对应的提升。</p><p>当存在大量静态内容时，这些内容会被当作纯字符串推进一个 buffer 里面，即使存在动态的绑定，会通过模版插值潜入进去。这样会比通过虚拟 dmo 来渲染的快上很多。</p><p>当静态内容大到一个量级的时候，会用_createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml，就不需要再创建对象，然后根据对象渲染。</p><h2 id="优点5：更好的Ts支持"><a href="#优点5：更好的Ts支持" class="headerlink" title="优点5：更好的Ts支持"></a><strong>优点5：更好的Ts支持</strong></h2><p>vue2不适合使用ts，原因在于vue2的Option API风格。options是个简单对象，而ts是一种类型系统、面向对象的语法。两者有点不匹配。</p><p>在vue2结合ts的具体实践中，要用 vue-class-component 强化 vue 组件，让 Script 支持 TypeScript 装饰器，用 vue-property-decorator 来增加更多结合 Vue 特性的装饰器，最终搞的ts的组件写法和js的组件写法差别挺大。</p><p>在vue3中，量身打造了defineComponent函数，使组件在ts下，更好的利用参数类型推断 。Composition API 代码风格中，比较有代表性的api就是 ref 和 reactive，也很好的支持了类型声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Component = defineComponent(&#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">success</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">        <span class="attr">student</span>: &#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="built_in">Object</span> <span class="keyword">as</span> PropType&lt;Student&gt;,</span><br><span class="line">          required: <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> year = ref(<span class="number">2020</span>)</span><br><span class="line">      <span class="keyword">const</span> month = ref&lt;string | number&gt;(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">      month.value = <span class="number">9</span> <span class="comment">// OK</span></span><br><span class="line">     <span class="keyword">const</span> result = year.value.split(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="优点6：Compostion-API-组合API-注入API"><a href="#优点6：Compostion-API-组合API-注入API" class="headerlink" title="优点6：Compostion API: 组合API/注入API"></a><strong>优点6：Compostion API: 组合API/注入API</strong></h2><p>传统的网页是html/css/javascript（结构/样式/逻辑）分离。vue通过组件化的方式，将联系紧密的结构/样式/逻辑放在一起，有利于代码的维护。compostion api更进一步，着力于JS（逻辑）部分，将逻辑相关的代码放在一起，这样更有利于代码的维护。</p><p>在vue2的组件内使用的是Option API风格(data/methods/mounted)来组织的代码，这样会让逻辑分散，举个例子就是我们完成一个计数器功能，要在data里声明变量，在methods定义响应函数，在mounted里初始化变量，如果在一个功能比较多、代码量比较大的组件里，你要维护这样一个功能，就需要在data/methods/mounted反复的切换到对应位置，然后进行代码的更改。</p><p>而在vue3中，使用setup函数。如下所示跟count相关的逻辑，都放到counter.js文件里，跟todo相关的逻辑放到todos.js里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useTodo <span class="keyword">from</span> <span class="string">&#x27;./todos&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> &#123; val, todos, addTodo &#125; = useTodo()</span><br><span class="line"><span class="keyword">let</span> &#123;count,add&#125; = useCounter() </span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">val, todos, addTodo,</span><br><span class="line">count,add,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点7：更先进的组件"><a href="#优点7：更先进的组件" class="headerlink" title="优点7：更先进的组件"></a><strong>优点7：更先进的组件</strong></h2><p>vue2是不允许这样写的，组件必须有一个跟节点，现在可以这样写，vue将为我们创建一个虚拟的Fragment节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;华为云享专家&lt;/div&gt;</span><br><span class="line">&lt;div&gt;全栈领域博主&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在Suspended-component完全渲染之前，备用内容会被显示出来。如果是异步组件，Suspense可以等待组件被下载，或者在设置函数中执行一些异步操作。</p><h2 id="优点8：自定义渲染API"><a href="#优点8：自定义渲染API" class="headerlink" title="优点8：自定义渲染API"></a><strong>优点8：自定义渲染API</strong></h2><p>vue2.x项目架构对于weex（移动端跨平台方案）和myvue（小程序上使用）等渲染到不同平台不太友好，vue3.0推出了自定义渲染API解决了该问题。下面我们先看vue2和vue3的入口写法有哪些不同。</p><p>vue2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; =&gt; h(App)&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./src/App&quot;</span></span><br><span class="line">createApp(App).mount((<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue官方实现的 createApp 会给我们的 template 映射生成 html 代码，但是要是你不想渲染生成到 html ，而是要渲染生成到 canvas 之类的不是html的代码的时候，那就需要用到 Custom Renderer API 来定义自己的 render 渲染生成函数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime-render&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./src/App&quot;</span>; <span class="comment">// 根组件</span></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用自定义渲染API，如weex和myvue这类方案的问题就得到了完美解决。只需重写createApp即可。</p><h2 id="优点9：按需编译，体积比vue2-x更小"><a href="#优点9：按需编译，体积比vue2-x更小" class="headerlink" title="优点9：按需编译，体积比vue2.x更小"></a><strong>优点9：按需编译，体积比vue2.x更小</strong></h2><p>框架的大小也会影响其性能。这是 Web 应用程序的唯一关注点，因为需要即时下载资源，在浏览器解析必要的 JavaScript 之前该应用程序是不可交互的。对于单页应用程序尤其如此。尽管 Vue 一直是相对轻量级的（Vue 2 的运行时大小压缩为 23 KB）。</p><p>在 Vue 3 中，通过将大多数全局 API 和内部帮助程序移至 ES 模块导出来，实现了这一目标。这使现代的打包工具可以静态分析模块依赖性并删除未使用的导出相关的代码。模板编译器还会生成友好的 Tree-shaking 代码，在模板中实际使用了该功能时才导入该功能的帮助程序。</p><p>框架的某些部分永远不会 Tree-shaking，因为它们对于任何类型的应用都是必不可少的。我们将这些必不可少的部分的度量标准称为基准尺寸。尽管增加了许多新功能，但 Vue 3 的基准大小压缩后约为 10 KB，还不到 Vue 2 的一半。</p><h2 id="优点10：支持多根节点组件"><a href="#优点10：支持多根节点组件" class="headerlink" title="优点10：支持多根节点组件"></a><strong>优点10：支持多根节点组件</strong></h2><p>Vue3 一个模板不再限制有多个根节点，(多个根节点上的 Attribute 继承) 需要显式定义 attribute 应该分布在哪里。否则控制台会给出警告提示。</p><p>在 Vue 3 中，组件现在正式支持多根节点组件，即片段！</p><p>在 2.x 中，不支持多根组件，当用户意外创建多根组件时会发出警告，因此，为了修复此错误，许多组件被包装在一个中。如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">    &lt;main&gt;...&lt;/main&gt;</span><br><span class="line">    &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在 3.x 中，组件现在可以有多个根节点！但是，这确实要求开发者明确定义属性应该分布在哪里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;/header&gt;</span><br><span class="line">  &lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;/footer&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="结尾想说的"><a href="#结尾想说的" class="headerlink" title="结尾想说的"></a><strong>结尾想说的</strong></h2><p>Vue是国内最火的前端框架之一。性能提升，运行速度是vue2的1.2-2倍。</p><ul><li>体积更小，按需编译体积vue2要更小。</li><li>类型推断，更好的支持ts这个也是趋势。</li><li>高级给予，暴露了更底层的API和提供更先进的内置组件。</li><li>组合API，能够更好的组织逻辑，封装逻辑，复用逻辑</li></ul><h2 id="对未来的展望："><a href="#对未来的展望：" class="headerlink" title="对未来的展望："></a><strong>对未来的展望：</strong></h2><p>技术总是越新越好，越来越多的企业都升级了vue3；</p><p>大型项目，由于对TS的友好越来越多的大型项目可以使用vue3；</p><p>作为程序员，我们就应该适应市场，提高自己的竞争力，为加薪提供空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;strong&gt;vue3 相比 vue2 的十项优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文章转载自华为云社区《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https://bbs.huaweicloud.com/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>koa2-demo</title>
    <link href="http://example.com/2021/06/12/koa2-demo/"/>
    <id>http://example.com/2021/06/12/koa2-demo/</id>
    <published>2021-06-12T12:53:10.000Z</published>
    <updated>2021-09-17T07:37:20.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Koa2框架的简单项目搭建及实战开发"><a href="#基于Koa2框架的简单项目搭建及实战开发" class="headerlink" title="[基于Koa2框架的简单项目搭建及实战开发]"></a>[基于Koa2框架的简单项目搭建及实战开发]</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://koa.bootcss.com/">Koa</a>是基于 Node.js 平台的下一代 web 开发框架，由express原班人马打造，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p><p>此文是简单介绍使用kos2进行项目的基本搭建以及api的简单开发</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1、Koa框架是基于node.js的，安装node是必须进行的第一步，这里就不在赘述了</p><p>2、安装koa（推荐使用淘宝镜像进行安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa --save</span><br></pre></td></tr></table></figure><p>3、全局安装Koa2的项目生成器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa-generator -g</span><br></pre></td></tr></table></figure><p>4、创建一个项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koa2 myProject</span><br></pre></td></tr></table></figure><p>5、进入这个项目文件夹，下载依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myProject</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure><blockquote><p>koa2 myProject 是用来生成项目的几门架构的</p></blockquote><p><img src="/images/koa2-demo/image-20210628200133834.png" alt="image-20210628200133834"></p><p>6、接下来，我们就可以启动项目服务了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">or</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:3000/%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%9E%E5%86%B5">http://localhost:3000/即可查看项目的运行实况</a></p><p><img src="/images/koa2-demo/image-20210628200448515.png" alt="image-20210628200448515"></p><h2 id="安装sequelize"><a href="#安装sequelize" class="headerlink" title="安装sequelize"></a>安装sequelize</h2><p>（Sequelize是一个基于promise的nodejs ORM，目前支持Postgres、mysql、SQLite和Microsoft SQL Server。它具有强大的事务支持，关联关系，读取和复制等功能。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install sequelize --save</span><br></pre></td></tr></table></figure><h2 id="安装mysql、mysql2"><a href="#安装mysql、mysql2" class="headerlink" title="安装mysql、mysql2"></a>安装mysql、mysql2</h2><p>项目使用的是mysql的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install mysql mysql2 --save</span><br></pre></td></tr></table></figure><h2 id="配置Sequelize的数据库链接"><a href="#配置Sequelize的数据库链接" class="headerlink" title="配置Sequelize的数据库链接"></a>配置Sequelize的数据库链接</h2><p>在项目的根目录下创建一个config目录，config目录中创建db.js，该文件主要用来创建mysql的数据库链接的。<br><code>/config/db.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;koa_demo&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="attr">dialect</span>: <span class="string">&#x27;mysql&#x27;</span>,</span><br><span class="line">    <span class="attr">operatorsAliases</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">dialectOptions</span>: &#123;</span><br><span class="line">        <span class="comment">// 字符集</span></span><br><span class="line">        <span class="attr">charset</span>: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">        <span class="attr">collate</span>: <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">        <span class="attr">supportBigNumbers</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">bigNumberStrings</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">poll</span>: &#123;</span><br><span class="line">        <span class="attr">max</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">min</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 信号量：对特定资源的允许同时访问的操作数量进行控制（并发数）</span></span><br><span class="line">        <span class="attr">acquire</span>: <span class="number">30000</span>,</span><br><span class="line">        <span class="comment">// 空闲数</span></span><br><span class="line">        <span class="attr">idle</span>: <span class="number">10000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 东八时区 （&#x27;:08:00&#x27;）</span></span><br><span class="line">    <span class="attr">timezone</span>: <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sequelize</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其中koa_demo为数据库名称，root为数据库用户名，123456为数据库密码，这是我自己本地的默认数据库信息</p></blockquote><h2 id="创建schema、modules、controllers"><a href="#创建schema、modules、controllers" class="headerlink" title="创建schema、modules、controllers"></a>创建schema、modules、controllers</h2><p>schema:数据表模型实例<br>modules：实体模型<br>controllers：控制器</p><p>3个目录下分别创建student.js</p><p><img src="/images/koa2-demo/image-20210628200827484.png" alt="image-20210628200827484"></p><h3 id="schema数据表模型"><a href="#schema数据表模型" class="headerlink" title="schema数据表模型"></a>schema数据表模型</h3><p>在schema目录下新建一个student.js文件，该文件的主要作用就是建立与数据表的对应关系，也可以理解为代码的建表。<br><code>schema/student.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const moment = require(&quot;moment&quot;);</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">sequelize, DataTypes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sequelize.define(<span class="string">&#x27;student&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">id</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.INTEGER,</span><br><span class="line">            <span class="attr">primaryKey</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">autoIncrement</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//学生姓名</span></span><br><span class="line">        <span class="attr">name</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 婚否</span></span><br><span class="line">        <span class="attr">married</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;married&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//年龄</span></span><br><span class="line">        <span class="attr">age</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.INTEGER,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;age&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//性别</span></span><br><span class="line">        <span class="attr">gender</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;gender&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//分数</span></span><br><span class="line">        <span class="attr">grade</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.STRING,</span><br><span class="line">            <span class="attr">allowNull</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">field</span>: <span class="string">&#x27;grade&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 创建时间</span></span><br><span class="line">        <span class="attr">createdAt</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.DATE</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 更新时间</span></span><br><span class="line">        <span class="attr">updatedAt</span>: &#123;</span><br><span class="line">            <span class="attr">type</span>: DataTypes.DATE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果为true，则表示名称和model相同，即user</span></span><br><span class="line"><span class="comment">         * 如果为fasle，mysql创建的表名称会是复数，即users</span></span><br><span class="line"><span class="comment">         * 如果指定的表名称本身就是复数，则形式不变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="attr">freezeTableName</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模型应用、使用"><a href="#模型应用、使用" class="headerlink" title="模型应用、使用"></a>模型应用、使用</h3><p>在项目中modules目录下创建student.js文件，为学生信息表，该文件为文章的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mysql的配置文件</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../config/db&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; QueryTypes, DataTypes &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入sequelize对象</span></span><br><span class="line"><span class="keyword">const</span> Sequelize = db.sequelize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入数据表模型</span></span><br><span class="line"><span class="comment">// const student = Sequelize.import(&#x27;../schema/student&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;../schema/student&#x27;</span>)(Sequelize, DataTypes);</span><br><span class="line">student.sync(&#123; <span class="attr">force</span>: <span class="literal">false</span> &#125;); <span class="comment">//自动创建表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">studentModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   创建学生表模型</span></span><br><span class="line">    <span class="comment">//   @param data</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">createStudent</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> student.create(&#123;</span><br><span class="line">            <span class="attr">name</span>: data.name, <span class="comment">//姓名</span></span><br><span class="line">            <span class="attr">age</span>: data.age,  <span class="comment">//年龄</span></span><br><span class="line">            <span class="attr">gender</span>: data.gender,  <span class="comment">//性别</span></span><br><span class="line">            <span class="attr">grade</span>: data.grade, <span class="comment">//分数</span></span><br><span class="line">            <span class="attr">married</span>: data.married,  <span class="comment">//婚否</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   查询学生信息的详情</span></span><br><span class="line">    <span class="comment">//   @param id 学生信息ID</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise&lt;Model&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">getStudentDetail</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> student.findOne(&#123;</span><br><span class="line">            <span class="attr">where</span>: &#123;</span><br><span class="line">                id</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = studentModel;</span><br></pre></td></tr></table></figure><h3 id="controllers-控制器"><a href="#controllers-控制器" class="headerlink" title="controllers 控制器"></a>controllers 控制器</h3><p>控制器的主要作用为功能的处理，项目中controllers目录下创建student.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StudentModel = <span class="built_in">require</span>(<span class="string">&quot;../modules/student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">studentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   创建学生信息</span></span><br><span class="line">    <span class="comment">//   @param ctx</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise.&lt;void&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//接收客服端</span></span><br><span class="line">        <span class="keyword">let</span> req = ctx.request.body;</span><br><span class="line">        <span class="keyword">if</span> (req.name &amp;&amp; req.age &amp;&amp; req.gender &amp;&amp; req.grade &amp;&amp; req.married) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建学生信息模型</span></span><br><span class="line">                <span class="keyword">const</span> ret = <span class="keyword">await</span> StudentModel.createStudent(req);</span><br><span class="line">                <span class="comment">//使用刚刚创建的学生信息ID查询学生信息详情，且返回学生信息详情信息</span></span><br><span class="line">                <span class="keyword">const</span> data = <span class="keyword">await</span> StudentModel.getStudentDetail(ret.id);</span><br><span class="line"></span><br><span class="line">                ctx.response.status = <span class="number">200</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;创建学生信息成功&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                ctx.response.status = <span class="number">412</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">412</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;创建学生信息失败&#x27;</span>,</span><br><span class="line">                    <span class="attr">data</span>: err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.response.status = <span class="number">416</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&#x27;参数不齐全&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   获取学生详情</span></span><br><span class="line">    <span class="comment">//   @param ctx</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise.&lt;void&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">detail</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> id = ctx.params.id;</span><br><span class="line">        <span class="keyword">if</span> (id) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 查询学生信息详情模型</span></span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">await</span> StudentModel.getStudentDetail(id);</span><br><span class="line">                ctx.response.status = <span class="number">200</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                ctx.response.status = <span class="number">412</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    <span class="attr">code</span>: <span class="number">412</span>,</span><br><span class="line">                    <span class="attr">msg</span>: <span class="string">&#x27;查询失败&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.response.status = <span class="number">416</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                <span class="attr">code</span>: <span class="number">416</span>,</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&#x27;学生ID必须传&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = studentController;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由，也可以简单理解为路径，主要是作为请求的url，请求的路径来处理一些请求，返回数据。一般情况下，基于node的项目，路由都是在一个叫做routes的目录下面。</p><p>routes目录下创建student.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)()</span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">const</span> StudentController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/student&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由前置</span></span><br><span class="line">router.prefix(<span class="string">&#x27;/student&#x27;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建学生</span></span><br><span class="line">router.post(<span class="string">&#x27;/student/create&#x27;</span>, StudentController.create);</span><br><span class="line"><span class="comment">//获取某个学生详情</span></span><br><span class="line">router.get(<span class="string">&#x27;/student/:id&#x27;</span>, StudentController.detail)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>然后在app.js添加如下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;./routes/student&#x27;</span>)</span><br><span class="line">app.use(student.routes(), student.allowedMethods())</span><br></pre></td></tr></table></figure><blockquote><p>注意koa框架的洋葱圈模型，不懂得可以去自行查询</p></blockquote><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><p>跨域是web开发中不可避免的一个必须要解决的问题了。跨域问题，主要是要解决服务器端的通信问题。在node的开发中，只需要实现一个CORS标准就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa-cors --save</span><br></pre></td></tr></table></figure><p>然后在根目录下的app.js加入koa-cors的引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const cors = require(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line">app.use(cors()) //使用cors</span><br></pre></td></tr></table></figure><blockquote><p>同理：注意koa框架的洋葱圈模型，不懂得可以去自行查询</p></blockquote><p>完整的app.js文件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">require</span>(<span class="string">&#x27;koa-json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> onerror = <span class="built_in">require</span>(<span class="string">&#x27;koa-onerror&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> users = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;./routes/student&#x27;</span>)</span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">onerror(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">// middlewares</span></span><br><span class="line">app.use(bodyparser(&#123;</span><br><span class="line">    <span class="attr">enableTypes</span>: [<span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;form&#x27;</span>, <span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">&#125;))</span><br><span class="line">app.use(json())</span><br><span class="line">app.use(logger())</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)(__dirname + <span class="string">&#x27;/public&#x27;</span>))</span><br><span class="line"></span><br><span class="line">app.use(views(__dirname + <span class="string">&#x27;/views&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">extension</span>: <span class="string">&#x27;pug&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span>() - start</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">// error-handling</span></span><br><span class="line">app.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;server error&#x27;</span>, err, ctx)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(student.routes(), student.allowedMethods())</span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="然后重启项目"><a href="#然后重启项目" class="headerlink" title="然后重启项目"></a>然后重启项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="/images/koa2-demo/image-20210628201511106.png" alt="image-20210628201511106"></p><p>如果启动过程中出现上图的结果，说明服务启动成功</p><h2 id="使用Postman软件进行接口的测试"><a href="#使用Postman软件进行接口的测试" class="headerlink" title="使用Postman软件进行接口的测试"></a>使用Postman软件进行接口的测试</h2><h4 id="创建一个student的测试接口为："><a href="#创建一个student的测试接口为：" class="headerlink" title="创建一个student的测试接口为："></a>创建一个student的测试接口为：</h4><p><a href="http://127.0.0.1:3000/student/student/create">http://127.0.0.1:3000/student/student/create</a></p><h4 id="查询一个student的测试接口为："><a href="#查询一个student的测试接口为：" class="headerlink" title="查询一个student的测试接口为："></a>查询一个student的测试接口为：</h4><p><a href="http://localhost:3000/student/student/1">http://localhost:3000/student/student/1</a></p><p>####请求条件选择为：</p><p>POST请求<br>Body ===&gt; x-www-form-rulencoded</p><h4 id="如下图所示"><a href="#如下图所示" class="headerlink" title="如下图所示"></a>如下图所示</h4><p><img src="/images/koa2-demo/image-20210628201654659.png" alt="image-20210628201654659"></p><p>点击《send》请求后，返回的信息如下：</p><p><img src="/images/koa2-demo/image-20210628201947721.png" alt="image-20210628201947721"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;创建学生信息成功&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jungle&quot;</span>,</span><br><span class="line">        <span class="string">&quot;married&quot;</span>: <span class="string">&quot;未婚&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createdAt&quot;</span>: <span class="string">&quot;2021-06-10T12:19:20.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updatedAt&quot;</span>: <span class="string">&quot;2021-06-10T12:19:20.000Z&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口返回成功后，我们去数据库里看一下这个表</p><p><img src="/images/koa2-demo/image-20210628202210099.png" alt="image-20210628202210099"></p><p>可以看到，已经在下koa_demo这个数据库中创建了一张student新表，且内容也是我们刚才进行添加的信息</p><h2 id="over"><a href="#over" class="headerlink" title="over"></a>over</h2><p>关于koa2的项目搭建先简单介绍到这里吧，算是对简单所学知识的一个小总结。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于Koa2框架的简单项目搭建及实战开发&quot;&gt;&lt;a href=&quot;#基于Koa2框架的简单项目搭建及实战开发&quot; class=&quot;headerlink&quot; title=&quot;[基于Koa2框架的简单项目搭建及实战开发]&quot;&gt;&lt;/a&gt;[基于Koa2框架的简单项目搭建及实战开发]&lt;/</summary>
      
    
    
    
    <category term="Node" scheme="http://example.com/categories/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/categories/Node/Koa2/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>koa2-core</title>
    <link href="http://example.com/2021/06/08/koa2-core/"/>
    <id>http://example.com/2021/06/08/koa2-core/</id>
    <published>2021-06-08T11:33:21.000Z</published>
    <updated>2021-09-17T07:37:28.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa2核心（洋葱圈模型）简介和实践理解"><a href="#Koa2核心（洋葱圈模型）简介和实践理解" class="headerlink" title="[Koa2核心（洋葱圈模型）简介和实践理解]"></a>[Koa2核心（洋葱圈模型）简介和实践理解]</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Koa2概述"><a href="#Koa2概述" class="headerlink" title="Koa2概述:"></a>Koa2概述:</h3><ul><li>基于Node.js平台的web开发框架</li><li>由Express原班人马打造：Express Koa Koa2</li></ul><p><img src="/images/koa2-core/1672451-20210511111549887-1302388100.png" alt="img"></p><ul><li> async/await 要求环境依赖Node v7.6.0及以上</li></ul><h3 id="Koa2特点"><a href="#Koa2特点" class="headerlink" title="Koa2特点"></a>Koa2特点</h3><ul><li>支持 async/await</li><li>洋葱模型中间件：当客户端发起一个请求到达第一层中间件并处理后，服务器处理请求，将处理结果传递给第二层中间件，到达第二层中间件后再处理，再将处理结果传递给第三层中间件，之后再进入第三层中间件处理；第三层处理后，依次将处理结果向上返回给第二层处理、第一层处理，最后第一层再响应给客户端</li></ul><p><img src="/images/koa2-core/1672451-20210511123621900-1538897783.png" alt="img"></p><h2 id="二、快速上手"><a href="#二、快速上手" class="headerlink" title="二、快速上手"></a>二、快速上手</h2><ul><li> <strong>检查Node的环境，要求环境依赖Node v7.6.0及以上</strong></li></ul><p>　　　　node -v</p><ul><li><strong>安装Koa</strong></li></ul><p>　　　　npm init -y</p><p>　　　　npm install koa</p><ul><li><strong>创建并编写app.js文件</strong></li></ul><p>　　　　1.创建Koa对象</p><p>　　　　2.编写相应函数(中间件)</p><p>　　　　3.监听窗口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建koa对象</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="comment">//编写响应函数(中间件)，ctx是应用上下文提供request和response方法接受和相应；</span></span><br><span class="line"><span class="comment">//参考洋葱模型，第二层中间件是否执行取决于第一层中间件的next()是否执行</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa1&quot;</span>) </span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span> next() <span class="comment">//执行第二层中间件，并且是异步的，next()返回一个Promise对象，在此等待第二层中间件返回后才继续往下执行；</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa1.1&quot;</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第二层中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa2&quot;</span>) </span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span> next(); <span class="comment">//执行第三层中间件，next()的返回值来自于第三层中间件的return，并且是一个Promise&#123;I love The dog!&#125;对象，　　　　　　　　　　　　　　　　　　//想要获取Promise对象中的数据，需要用await，则箭头函数要用async修饰；</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa2.1&quot;</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第三层中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa3&quot;</span>)</span><br><span class="line">    ctx.response.body = <span class="string">&quot;hello koa3!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I love The dog!&quot;</span>  <span class="comment">//向第二层中间件返回执行结果</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定端口号</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>在浏览器中输入：<a href="http://localhost:3000发起请求">http://localhost:3000发起请求</a></strong></li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在控制台可以看到这样的输出顺序</p><p><img src="/images/koa2-core/1672451-20210511123440580-1266972367.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Koa2核心（洋葱圈模型）简介和实践理解&quot;&gt;&lt;a href=&quot;#Koa2核心（洋葱圈模型）简介和实践理解&quot; class=&quot;headerlink&quot; title=&quot;[Koa2核心（洋葱圈模型）简介和实践理解]&quot;&gt;&lt;/a&gt;[Koa2核心（洋葱圈模型）简介和实践理解]&lt;/</summary>
      
    
    
    
    <category term="Node" scheme="http://example.com/categories/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/categories/Node/Koa2/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>vue中使用vue-qr生成并下载二维码</title>
    <link href="http://example.com/2021/05/26/Vue-qr/"/>
    <id>http://example.com/2021/05/26/Vue-qr/</id>
    <published>2021-05-26T01:42:04.000Z</published>
    <updated>2021-09-17T07:36:28.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue中使用vue-qr生成并下载二维码"><a href="#vue中使用vue-qr生成并下载二维码" class="headerlink" title="vue中使用vue-qr生成并下载二维码"></a>vue中使用vue-qr生成并下载二维码</h1><p>最近在项目中遇到一个生成二维码的需求，并且二维码上要带上logo和背景。</p><p>另一种二维码生成<strong>qrcode</strong>只能单纯的生成二维码，不能带logo及其它一些自定义。</p><p>于是选择了<strong>vue-qr</strong>。它具有自定义二维码背景、logo、实点颜色等等特性，能够生成更炫酷的二维码。</p><h2 id="vue中使用vue-qr生成二维码"><a href="#vue中使用vue-qr生成二维码" class="headerlink" title="vue中使用vue-qr生成二维码"></a>vue中使用vue-qr生成二维码</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-qr --save</span><br></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic-setting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;qrcode&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">vue-qr</span> <span class="attr">:correctLevel</span>=<span class="string">&quot;3&quot;</span> <span class="attr">:autoColor</span>=<span class="string">&quot;false&quot;</span> <span class="attr">colorDark</span>=<span class="string">&quot;#313a90&quot;</span> <span class="attr">:bgSrc</span>=<span class="string">&quot;bgSrc&quot;</span> <span class="attr">:logoSrc</span>=<span class="string">&quot;logoSrc&quot;</span> <span class="attr">:text</span>=<span class="string">&quot;codeUrl&quot;</span> <span class="attr">:size</span>=<span class="string">&quot;95&quot;</span> <span class="attr">:margin</span>=<span class="string">&quot;0&quot;</span> <span class="attr">:logoMargin</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">vue-qr</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;downloadImg&quot;</span>&gt;</span>下载该二维码&#123;&#123; imgurl &#125;&#125;<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> VueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;vue-qr&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">imgurl</span>: <span class="string">&quot;https://www.baidu.com/&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    VueQr,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="参数及说明"><a href="#参数及说明" class="headerlink" title="参数及说明"></a>参数及说明</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>text</td><td>二维码内容</td><td>是</td></tr><tr><td>size</td><td>尺寸, 长宽一致, 包含外边距</td><td>是</td></tr><tr><td>margin</td><td>二维码图像的外边距, 默认 20px</td><td>否</td></tr><tr><td>dotScale</td><td>数据区域点缩小比例,默认为0.35</td><td>否</td></tr><tr><td>correctLevel</td><td>容错级别 0-3</td><td>否</td></tr><tr><td>whiteMargin</td><td>若设为 true, 背景图外将绘制白色边框（默认是true）</td><td>否</td></tr><tr><td>bindElement</td><td>指定是否需要自动将生成的二维码绑定到HTML上（默认是true）</td><td>否</td></tr><tr><td>callback</td><td>生成的二维码 Data URI 可以在回调中取得,第一个参数为二维码 data URL, 第二个参数为 props 传过来的 qid(因为二维码生成是异步的,所以加个 id 用于排序)</td><td>否</td></tr></tbody></table><blockquote><p>可以使用 <code>bindElement</code> 来指定要自动填入二维码图像的元素的 ID（不含前导「#」），支持 <code>&lt;div&gt;</code> 或是 <code>&lt;img&gt;</code>。</p></blockquote><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><table><thead><tr><th>参数</th><th>说明</th><th>是否必要</th></tr></thead><tbody><tr><td>colorDark</td><td>黑点的颜色</td><td>否</td></tr><tr><td>colorLight</td><td>空白区域的颜色</td><td>否</td></tr><tr><td>autoColor</td><td>若为 true, 背景图的主要颜色将作为实点的颜色, 即 colorDark,默认 true</td><td>否</td></tr></tbody></table><blockquote><p>若设置了 <code>autoColor</code>，则 <code>colorDark</code> 和 <code>colorLight</code> 都将被忽略。</p></blockquote><h3 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h3><table><thead><tr><th><strong>参数</strong></th><th>说明</th><th>是否必要</th></tr></thead><tbody><tr><td>bgSrc</td><td>欲嵌入的背景图地址</td><td>否</td></tr><tr><td>gifBgSrc</td><td>欲嵌入的背景图 gif 地址,设置后普通的背景图将失效。设置此选项会影响性能</td><td>否</td></tr><tr><td>backgroundColor</td><td>背景色</td><td>否</td></tr><tr><td>backgroundDimming</td><td>叠加在背景图上的颜色, 在解码有难度的时有一定帮助</td><td>否</td></tr></tbody></table><blockquote><p>若设定了 <code>gifBackground</code> ，则 <code>backgroundImage</code> 将会被忽略。</p></blockquote><h3 id="logo图像"><a href="#logo图像" class="headerlink" title="logo图像"></a>logo图像</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>logoSrc</td><td>嵌入至二维码中心的 LOGO 地址</td><td>否</td></tr><tr><td>logoScale</td><td>用于计算 LOGO 大小的值, 过大将导致解码失败, LOGO 尺寸计算公式 logoScale*(size-2*margin), 默认 0.2</td><td>否</td></tr><tr><td>logoMargin</td><td>标识周围的空白边框, 默认为0</td><td>否</td></tr><tr><td>logoBackgroundColor</td><td>背景色,需要设置 logo margin</td><td>否</td></tr><tr><td>logoCornerRadius</td><td>标识及其边框的圆角半径, 默认为0</td><td>否</td></tr></tbody></table><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>binarize</td><td>若为 true, 图像将被二值化处理, 未指定阈值则使用默认值，默认是false</td><td>否</td></tr><tr><td>binarizeThreshold</td><td>(0 &lt; threshold &lt; 255) 二值化处理的阈值</td><td>否</td></tr></tbody></table><h2 id="vue中下载生成的二维码"><a href="#vue中下载生成的二维码" class="headerlink" title="vue中下载生成的二维码"></a>vue中下载生成的二维码</h2><h3 id="添加下载事件"><a href="#添加下载事件" class="headerlink" title="添加下载事件"></a>添加下载事件</h3><p>生成二维码&amp;下载二维码完整版代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic-setting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;qrcode&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">vue-qr</span> <span class="attr">:correctLevel</span>=<span class="string">&quot;3&quot;</span> <span class="attr">:autoColor</span>=<span class="string">&quot;false&quot;</span> <span class="attr">colorDark</span>=<span class="string">&quot;#313a90&quot;</span> <span class="attr">:bgSrc</span>=<span class="string">&quot;bgSrc&quot;</span> <span class="attr">:logoSrc</span>=<span class="string">&quot;logoSrc&quot;</span> <span class="attr">:text</span>=<span class="string">&quot;codeUrl&quot;</span> <span class="attr">:size</span>=<span class="string">&quot;95&quot;</span> <span class="attr">:margin</span>=<span class="string">&quot;0&quot;</span> <span class="attr">:logoMargin</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">vue-qr</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;downloadImg&quot;</span>&gt;</span>下载该二维码&#123;&#123; imgurl &#125;&#125;<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> VueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;vue-qr&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 自定义二维码扫描的地址</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">imgurl</span>: <span class="string">&quot;https://www.baidu.com/&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">components</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    VueQr,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">downloadImg</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> oQrcode = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#qrcode img&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> url = oQrcode.src;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&quot;click&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 自定义下载二维码图片的名字</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      a.download = <span class="string">&quot;download二维码&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//url地址</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      a.href = url;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">//进行下载</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      a.dispatchEvent(event);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h3><p><img src="/images/Vue-qr/directive.gif" alt="directive"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue中使用vue-qr生成并下载二维码&quot;&gt;&lt;a href=&quot;#vue中使用vue-qr生成并下载二维码&quot; class=&quot;headerlink&quot; title=&quot;vue中使用vue-qr生成并下载二维码&quot;&gt;&lt;/a&gt;vue中使用vue-qr生成并下载二维码&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="项目学习" scheme="http://example.com/categories/Vue/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue-qr" scheme="http://example.com/tags/Vue-qr/"/>
    
  </entry>
  
</feed>
