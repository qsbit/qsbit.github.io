<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jungle</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-14T11:04:02.773Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jungle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue+echarts</title>
    <link href="http://example.com/2021/07/31/Vue-echarts/"/>
    <id>http://example.com/2021/07/31/Vue-echarts/</id>
    <published>2021-07-31T10:25:06.000Z</published>
    <updated>2021-08-14T11:04:02.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Vue项目中封装echarts"><a href="#在Vue项目中封装echarts" class="headerlink" title="在Vue项目中封装echarts"></a>在Vue项目中封装echarts</h1><blockquote><p>文章目的：在vue项目中使用echarts针对相同类型的数据渲染，无法定位渲染id和繁琐问题</p></blockquote><h3 id="先看效果图"><a href="#先看效果图" class="headerlink" title="先看效果图"></a>先看效果图</h3><p><img src="/images/Vue-echarts/image-20210814185111072.png" alt="image-20210814185111072"></p><h2 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install echarts</span><br></pre></td></tr></table></figure><h2 id="在main-js中引入依赖"><a href="#在main-js中引入依赖" class="headerlink" title="在main.js中引入依赖"></a>在main.js中引入依赖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入echarts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="在公共的方法文件夹中创建echarts-js文件"><a href="#在公共的方法文件夹中创建echarts-js文件" class="headerlink" title="在公共的方法文件夹中创建echarts.js文件"></a>在公共的方法文件夹中创建echarts.js文件</h2><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/util/echarts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">echarts, id, seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(seriesdata)<span class="comment">//echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">        <span class="built_in">this</span>.echarts = echarts;</span><br><span class="line">        <span class="keyword">let</span> option = <span class="built_in">this</span>.getOption(seriesdata, answerTotal)  <span class="comment">//把参数传递给方法</span></span><br><span class="line">        <span class="keyword">var</span> myChart = <span class="built_in">this</span>.echarts.init(<span class="built_in">document</span>.getElementById(id));<span class="comment">//获取dom</span></span><br><span class="line">        myChart.setOption(option);     <span class="comment">//暴露出去</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOption</span>(<span class="params">seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> option = &#123;</span><br><span class="line">            <span class="comment">// 环形中间的标题</span></span><br><span class="line">            title: &#123;</span><br><span class="line">                text: answerTotal + <span class="string">&quot;人&quot;</span>,</span><br><span class="line">                left: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                top: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                    color: <span class="string">&quot;#27D9C8&quot;</span>,</span><br><span class="line">                    fontSize: <span class="number">18</span>,</span><br><span class="line">                    align: <span class="string">&quot;center&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 环形中间的标题</span></span><br><span class="line">            graphic: &#123;</span><br><span class="line">                type: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                left: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                top: <span class="string">&quot;40%&quot;</span>,</span><br><span class="line">                style: &#123;</span><br><span class="line">                    text: <span class="string">&quot;实测&quot;</span>,</span><br><span class="line">                    textAlign: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                    fill: <span class="string">&quot;#333&quot;</span>,</span><br><span class="line">                    fontSize: <span class="number">18</span>,</span><br><span class="line">                    fontWeight: <span class="number">700</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            legend: &#123;</span><br><span class="line">                show: <span class="literal">false</span>, <span class="comment">//图例显示与隐藏</span></span><br><span class="line">            &#125;,</span><br><span class="line">            series: [</span><br><span class="line">                &#123;</span><br><span class="line">                    type: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">                    <span class="comment">// roseType: &#x27;area&#x27;,</span></span><br><span class="line">                    radius: [<span class="string">&#x27;40%&#x27;</span>, <span class="string">&#x27;60%&#x27;</span>],</span><br><span class="line">                    center: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line"></span><br><span class="line">                    label: &#123;</span><br><span class="line">                        alignTo: <span class="string">&#x27;edge&#x27;</span>,</span><br><span class="line">                        formatter: <span class="string">&#x27;&#123;name|&#123;b&#125;&#125;\n&#123;time|&#123;c&#125; 人&#125;&#x27;</span>,</span><br><span class="line">                        minMargin: <span class="number">5</span>,</span><br><span class="line">                        edgeDistance: <span class="number">10</span>,</span><br><span class="line">                        lineHeight: <span class="number">15</span>,</span><br><span class="line">                        rich: &#123;</span><br><span class="line">                            time: &#123;</span><br><span class="line">                                fontSize: <span class="number">10</span>,</span><br><span class="line">                                color: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    itemStyle: &#123;</span><br><span class="line">                        normal: &#123;</span><br><span class="line">                            color: <span class="function"><span class="keyword">function</span> (<span class="params">colors</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> colorList = [<span class="string">&#x27;#FF8400&#x27;</span>, <span class="string">&#x27;#EEC23A&#x27;</span>, <span class="string">&#x27;#EEE93A&#x27;</span>, <span class="string">&#x27;#CCCCCC&#x27;</span>];</span><br><span class="line">                                <span class="keyword">return</span> colorList[colors.dataIndex]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        shadowBlur: <span class="number">200</span>,</span><br><span class="line">                        shadowColor: <span class="string">&#x27;rgba(0, 0, 0, 0.5)&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    data: seriesdata,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在Vue所需echarts文件中引入该echarts-js文件"><a href="#在Vue所需echarts文件中引入该echarts-js文件" class="headerlink" title="在Vue所需echarts文件中引入该echarts.js文件"></a>在Vue所需echarts文件中引入该echarts.js文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入封装的echarts方法</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&quot;@/util/echarts.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="规划好echarts放置的地方"><a href="#规划好echarts放置的地方" class="headerlink" title="规划好echarts放置的地方"></a>规划好echarts放置的地方</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px; height: 400px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //echarts存放的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实例化一个渲染echarts的方法"><a href="#实例化一个渲染echarts的方法" class="headerlink" title="实例化一个渲染echarts的方法"></a>实例化一个渲染echarts的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addEcharts</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> echarts(<span class="built_in">this</span>.$echarts, <span class="string">&quot;main&quot;</span>, <span class="built_in">this</span>.seriesdata,<span class="built_in">this</span>.answerTotal);  </span><br><span class="line">      <span class="comment">//echarts传参，this.$echarts声明是echarts，main是div的ID, this.seriesdata,this.answerTotal是传递参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="在Vue生命周期mounted阶段调用该方法"><a href="#在Vue生命周期mounted阶段调用该方法" class="headerlink" title="在Vue生命周期mounted阶段调用该方法"></a>在Vue生命周期mounted阶段调用该方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.addEcharts();  <span class="comment">//调用组件的时候自动调用这个方法</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h2><p><img src="/images/Vue-echarts/image-20210814185044874.png" alt="image-20210814185044874"></p><h2 id="可能遇到的问题（待补充）"><a href="#可能遇到的问题（待补充）" class="headerlink" title="可能遇到的问题（待补充）"></a>可能遇到的问题（待补充）</h2><h3 id="echarts-js-5fd2-7-Uncaught-in-promise-TypeError-Cannot-read-property-‘init’-of-undefined"><a href="#echarts-js-5fd2-7-Uncaught-in-promise-TypeError-Cannot-read-property-‘init’-of-undefined" class="headerlink" title="echarts.js?5fd2:7 Uncaught (in promise) TypeError: Cannot read property ‘init’ of undefined"></a>echarts.js?5fd2:7 Uncaught (in promise) TypeError: Cannot read property ‘init’ of undefined</h3><p><img src="/images/Vue-echarts/image-20210814184516054.png" alt="image-20210814184516054"></p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>对于数据加载和dom初始化过程，如果不加限制 使用echarts 绘图的js方法<strong>有很大机率</strong>先于dom初始完成之前运行，所以造成图表不显示。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>使用setTimeout函数延迟运行绘图的js.时间在500毫秒左右,可根据情况调整；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/util/echarts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">echarts, id, seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(seriesdata)<span class="comment">//echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">        <span class="built_in">this</span>.echarts = echarts;</span><br><span class="line">        <span class="keyword">let</span> option = <span class="built_in">this</span>.getOption(seriesdata, answerTotal)  <span class="comment">//把参数传递给方法</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改的地方👇👇👇</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myChart = <span class="built_in">this</span>.echarts.init(<span class="built_in">document</span>.getElementById(id));<span class="comment">//获取dom</span></span><br><span class="line">        myChart.setOption(option);     <span class="comment">//暴露出去</span></span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">        <span class="comment">// 修改的地方👆👆👆</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOption</span>(<span class="params">seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> option = &#123;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ...(中间均未发生改变)</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">                    &#125;,</span><br><span class="line">                    data: seriesdata,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Vue项目中封装echarts&quot;&gt;&lt;a href=&quot;#在Vue项目中封装echarts&quot; class=&quot;headerlink&quot; title=&quot;在Vue项目中封装echarts&quot;&gt;&lt;/a&gt;在Vue项目中封装echarts&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;文</summary>
      
    
    
    
    <category term="项目学习" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue+Echarts" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/Vue-Echarts/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Project" scheme="http://example.com/tags/Project/"/>
    
    <category term="echarts" scheme="http://example.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>前端面试exp01</title>
    <link href="http://example.com/2021/07/15/interview-exp01/"/>
    <id>http://example.com/2021/07/15/interview-exp01/</id>
    <published>2021-07-15T06:33:12.000Z</published>
    <updated>2021-09-17T06:54:53.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍-amp-项目介绍"><a href="#自我介绍-amp-项目介绍" class="headerlink" title="自我介绍 &amp; 项目介绍"></a>自我介绍 &amp; 项目介绍</h2><h2 id="从用户输入URL到看到页面，这个过程中都发生了什么？"><a href="#从用户输入URL到看到页面，这个过程中都发生了什么？" class="headerlink" title="从用户输入URL到看到页面，这个过程中都发生了什么？"></a>从用户输入URL到看到页面，这个过程中都发生了什么？</h2><p><img src="/images/interview-exp01/image-20210904205421204.png" alt="image-20210904205421204"></p><h2 id="defer-amp-async-的区别"><a href="#defer-amp-async-的区别" class="headerlink" title="defer &amp; async 的区别"></a>defer &amp; async 的区别</h2><p> defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 一句话，defer是“渲染完再执行”，async是“下载完就执行”。 另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p><h2 id="为什么加载同步script标签中的内容会阻塞文档渲染？"><a href="#为什么加载同步script标签中的内容会阻塞文档渲染？" class="headerlink" title="为什么加载同步script标签中的内容会阻塞文档渲染？"></a>为什么加载同步script标签中的内容会阻塞文档渲染？</h2><p>JavaScript是单线程的语言。</p><p>单线程意味着什麽呢？意味着一次只能干一件事。这条线程，被JavaScript的执行和浏览器的渲染所共享（也就是说两者用的均是这一条线程，浏览器在某个时间点只能执行JS或渲染UI一个动作）。</p><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><p><img src="/images/interview-exp01/image-20210917144847187.png" alt="image-20210917144847187"></p><p><img src="/images/interview-exp01/image-20210917144858432.png" alt="image-20210917144858432"></p><h2 id="对BFC语法规范的理解？"><a href="#对BFC语法规范的理解？" class="headerlink" title="对BFC语法规范的理解？"></a>对BFC语法规范的理解？</h2><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。可以把它理解成一个独立的区域</p><p>另外还有个概念叫<code>IFC</code>（IFC的line box（线框高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响）。不过，<code>BFC</code>问得更多。</p><p><strong>如何生成BFC</strong></p><p>1、overflow<code>: 不为</code>visible</p><p>2、浮动中：不为none</p><p>3、定位中：不为static</p><p>4、display：flex，inline-block</p><h2 id="对“闭包”的理解？"><a href="#对“闭包”的理解？" class="headerlink" title="对“闭包”的理解？"></a>对“闭包”的理解？</h2><p>　　在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。</p><p><strong>优点：</strong></p><p>1、可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用。</p><p>2、避免变量污染全局。</p><p>3、把变量存到独立的作用域，作为私有成员存在。</p><p><strong>缺点：</strong></p><p>1、对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。</p><p>2、对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域长度。</p><h2 id="防抖-amp-节流-的原理及应用场景？"><a href="#防抖-amp-节流-的原理及应用场景？" class="headerlink" title="防抖 &amp; 节流 的原理及应用场景？"></a>防抖 &amp; 节流 的原理及应用场景？</h2><p>1、基本概念</p><p> 防抖：最后一次点击事件后time过后才会执行</p><p>节流：持续触发事件时，保证一定time内执行一次</p><p>2、分别适合用在什么场景：</p><p>防抖：input   </p><p>节流：resize   scroll</p><h2 id="滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景"><a href="#滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景" class="headerlink" title="滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景"></a>滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景</h2><p>①scrollTop/scrollLeft:滚动的距离，一开始默认都是0，往下滚动scrollTop增加，往右scrollLeft增加。</p><p>②scrollHeight/scrollWidth:整个页面内容的大小，包括被隐藏的部分。</p><p>③clientHeight/clientWidth:视图显示部分的大小</p><p>①判断滚动方向，记录之前的scrollTop，scrollLeft，然后触发后进行比较判断</p><p>②判断是否到达顶部底部，scrollTop+clientHeight == scrollHeight到达底部</p><h2 id="JS的异步处理函数有哪些？（具体阐述，ES5-–-gt-ES6）"><a href="#JS的异步处理函数有哪些？（具体阐述，ES5-–-gt-ES6）" class="headerlink" title="JS的异步处理函数有哪些？（具体阐述，ES5 –&gt; ES6）"></a>JS的异步处理函数有哪些？（具体阐述，ES5 –&gt; ES6）</h2><p>setTimeout、setInterval、promise、async await</p><h2 id="关于async和await的应用场景题"><a href="#关于async和await的应用场景题" class="headerlink" title="关于async和await的应用场景题"></a>关于async和await的应用场景题</h2><p> 一个请求接着一个请求：后一个请求依赖前一个请求返回值</p><p> 请求后的错误处理：使用 try/catch 直接捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">imageCrawler</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">await</span> getImage(url)</span><br><span class="line">        <span class="keyword">return</span> img</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）"><a href="#浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）" class="headerlink" title="浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）"></a>浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）</h2><p>宏任务：整体代码，setTimeout，setInterval，I/O操作</p><p>微任务：new Promise().then ，MutaionObserver（前端的回溯）</p><p>Node V10以后和浏览器的行为统一了：先执行完一轮宏任务，再去清空微任务队列.</p><h2 id="Vue的双向数据绑定原理"><a href="#Vue的双向数据绑定原理" class="headerlink" title="Vue的双向数据绑定原理"></a>Vue的双向数据绑定原理</h2><p>利用Object.defineProperty()数据劫持，结合发布者-订阅者模式实现的。</p><p><strong>数据劫持</strong>：Object.defineProperty()：简单的说 就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法，当我们给这个属性赋值的时候，又用到了它里面的set方法</p><p><strong>发布者-订阅者</strong>：</p><p> 前面所讲的数据劫持，其实就是为属性创建了一个观察者对象，监听数据的变化。接下来就是创建发布类和订阅类，如下：</p><p><img src="https://img-blog.csdnimg.cn/20190420173653318.png" alt="img"></p><p><strong>observer</strong>，创建数据监听，并为每个属性建立一个发布类。</p><p><strong>Dep</strong>是发布类，维护与该属性相关的订阅实例，当数据发生更新时，会通知所有的订阅实例。</p><p><strong>Watcher</strong>是订阅类，注册到所有相关属性的Dep发布类中，接受发布类的数据变更通知，通过回调，实现视图的更新。</p><h2 id="Vue的diff算法"><a href="#Vue的diff算法" class="headerlink" title="Vue的diff算法"></a>Vue的diff算法</h2><p><code>diff</code> 算法只对同级节点进行对比</p><p>都用key做为唯一标识，进行查找，只有key和标签类型相同时才会复用老节点（遍历前都会根据老的节点构建一个map，方便根据key快速查找）</p><p>ps：与react不同的是，react 采用从左向右进行遍历</p><h2 id="使用v-for渲染列表是key值的作用？"><a href="#使用v-for渲染列表是key值的作用？" class="headerlink" title="使用v-for渲染列表是key值的作用？"></a>使用v-for渲染列表是key值的作用？</h2><p>key的作用让列表中每个item都有一个唯一的识别身份，可以下标值index或者id, 主要是为了vue精准的追踪到每一个元素，高效的更新虚拟DOM。</p><h2 id="项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）"><a href="#项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）" class="headerlink" title="项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）"></a>项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）</h2><p><strong>原理：</strong>首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。<br><strong>优点：</strong>页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p><p><strong>不足：</strong>数据量大的时候，加载速度依旧很慢</p><p><strong>优化：</strong>缩略图格式（压缩资源大小）</p><h2 id="项目中遇到的问题？"><a href="#项目中遇到的问题？" class="headerlink" title="项目中遇到的问题？"></a>项目中遇到的问题？</h2><h3 id="使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义"><a href="#使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义" class="headerlink" title="使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义"></a>使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义</h3><p>this.$nextTick()将回调延迟到下次 DOM 更新之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p><p>由于dom元素还没有更新， 因此打印出来的还是未改变之前的值，而通过this.$nextTick()获取到的值为dom更新之后的值</p><h2 id="小程序的样式适配怎么做的"><a href="#小程序的样式适配怎么做的" class="headerlink" title="小程序的样式适配怎么做的"></a>小程序的样式适配怎么做的</h2><p>小程序的适配原理，提出了一种新单位rpx，可以根据屏幕宽度进行自适应，规定屏幕宽为750rpx</p><p><strong>微信官方提供的换算方式</strong>：rpx = px * (目标设备宽 px 值 / 750)</p><p>在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p><p><strong>一般情况设计稿是按照iphone6尺寸设计的，设计稿上尺寸大小可以直接等于rpx</strong></p><h2 id="CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置"><a href="#CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置" class="headerlink" title="CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置"></a>CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置</h2><p>flex布局下的一个属性：align-self</p><h2 id="CSS选择器（常见的，伪类选择器用过哪些，-before-after应用场景）"><a href="#CSS选择器（常见的，伪类选择器用过哪些，-before-after应用场景）" class="headerlink" title="CSS选择器（常见的，伪类选择器用过哪些，::before ::after应用场景）"></a>CSS选择器（常见的，伪类选择器用过哪些，::before ::after应用场景）</h2><p>常见伪类——:hover,:link,:active,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让超链接点击之前是红色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*让超链接点击之后是橙色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: orange;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标悬停，放到标签上的时候是绿色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标点击链接，但是不松手的时候*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: black;&#125;</span><br></pre></td></tr></table></figure><p>常见伪元素——::before,::after,</p><p>::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。</p><p>这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。</p><p>所以不要用:before或:after展示有实际意义的内容，尽量使用它们显示修饰性内容，例如图标。</p><p>举例：网站有些联系电话，希望在它们前加一个icon☎，就可以使用:before伪元素，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.phoneNumber</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;\260E&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;phoneNumber&quot;</span>&gt;</span>12345645654<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最常用的就是清除浮动</p><h2 id="选择器优先级排列"><a href="#选择器优先级排列" class="headerlink" title="选择器优先级排列"></a>选择器优先级排列</h2><p>内联样式 =&gt; id(id选择器) =&gt; class(类选择器) =&gt; div(标签选择器) =&gt; ul&gt;li子选择器() =&gt; li a(后代选择器) =&gt; a:hover(伪类选择器) </p><p><strong>选择器的权值加到一起，大的优先；如果权值相同，后定义的优先</strong> </p><h2 id="CSS函数用过嘛？常见的calc-函数-计算长度值，-var"><a href="#CSS函数用过嘛？常见的calc-函数-计算长度值，-var" class="headerlink" title="CSS函数用过嘛？常见的calc()函数 计算长度值， var()"></a>CSS函数用过嘛？常见的calc()函数 计算长度值， var()</h2><h3 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h3><p>这个函数使我们能够计算CSS值，而不是指定确切的值。通常用于计算元素的大小或位置。它支持加法、减法、乘法和除法。</p><p><strong>需要特别注意重要一点</strong>是<code>+</code>和<code>-</code>运算符<strong>必须用空格隔开</strong>，不然无法正常工作。<code>*</code>和<code>/</code>运算符不有这限制，但出于一致性的考虑，建议添加空格。</p><p>实践例子：水平居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;calc&quot;</span>&gt;</span>Centered with calc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.calc</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">100px</span>)//页面总长度的一半减去自身长度的一半</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h3><p>通过这个函数，我们可以使用一个自定义属性的值作为另一个CSS属性的值。简单地说，可以定义一个颜色，放在自定义属性(CSS变量)中，然后通过调用var函数重用该属性值。</p><p>此函数接受两个参数，即自定义属性和一个默认值，如果出现问题，将使用默认值。</p><p>实践例子：一个网站的主题色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --bg-<span class="attribute">color</span>: green;//通过 --前缀来实现自定义</span><br><span class="line">  --<span class="attribute">color</span>: white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.var</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg-color);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js如何判断数组-Array-isArray-instanceof-原理"><a href="#js如何判断数组-Array-isArray-instanceof-原理" class="headerlink" title="js如何判断数组  Array.isArray()   instanceof 原理"></a>js如何判断数组  Array.isArray()   instanceof 原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理解就是运用对象原型的toString方法将Array转换为字符串，之后进行比对，下面我们来详细分析下各个部分的组成。<br>Object.prototype.toString代表这个toString方法本来是对象原型上面的，之后call方法将toString方法中的this转换为参数value，这样传进的参数value（实际上对于此方法应该是个数组[]）就可以通过原型的方法来转换为字符串。</p><h3 id="value-instanceof-Type-true-false"><a href="#value-instanceof-Type-true-false" class="headerlink" title="value instanceof Type == true/false"></a>value instanceof Type == true/false</h3><p> instanceof实现原理：看左边实例的–proto–指向的原型链上，有没有跟右侧类型的prototype指向同一个对象</p><h2 id="JS对象深拷贝"><a href="#JS对象深拷贝" class="headerlink" title="JS对象深拷贝"></a>JS对象深拷贝</h2><p>使用JSON.parse（）和 JSON.stringify（）对对象进行深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(会忽略function和undefined的字段，只能克隆原始对象自身的值，不能克隆它继承的值)</p><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="事件循环（Event-Loop）机制"><a href="#事件循环（Event-Loop）机制" class="headerlink" title="事件循环（Event Loop）机制"></a>事件循环（Event Loop）机制</h2><p>js是单线程的 </p><p>宏任务：整体代码，setTimeout，setInterval，I/O操作</p><p>微任务：new Promise（）.then ，MutaionObserver（前端的回溯）</p><h2 id="二分法查找时间复杂度O-logn-、-快排时间复杂度O-nlogn"><a href="#二分法查找时间复杂度O-logn-、-快排时间复杂度O-nlogn" class="headerlink" title="二分法查找时间复杂度O(logn)、 快排时间复杂度O(nlogn)"></a>二分法查找时间复杂度O(logn)、 快排时间复杂度O(nlogn)</h2><p>二分查找：假设一个数组长度为n,每次查找后数据长度减半，第一次查找后数据长度为n/2,第二次查找后数据长度为n/(2的2次方)，第k次查找后数据长度为n/(2的k次方)，最坏情况下数数据长度为1时找到该数，即n/(2的k次方)=1, 解得k=log2n</p><p>快排基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>冒泡排序：O(n^2)</p><h2 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h2><p>栈：先进后出</p><p>队列：先进先出</p><h2 id="打印二叉树用什么数据结构"><a href="#打印二叉树用什么数据结构" class="headerlink" title="打印二叉树用什么数据结构"></a>打印二叉树用什么数据结构</h2><p> 队列</p><h2 id="遍历对象和数组的方法"><a href="#遍历对象和数组的方法" class="headerlink" title="遍历对象和数组的方法"></a>遍历对象和数组的方法</h2><p>遍历对象：for…in、Object.keys().forEach()</p><p>遍历数组：forEach、map、for循环遍历、for…in、for…of(只能遍历出value，无下标)</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><h3 id="大概多久出面试结果？"><a href="#大概多久出面试结果？" class="headerlink" title="大概多久出面试结果？"></a>大概多久出面试结果？</h3><h3 id="对我此次面试表现的评价？"><a href="#对我此次面试表现的评价？" class="headerlink" title="对我此次面试表现的评价？"></a>对我此次面试表现的评价？</h3><h3 id="跟同批次同学相比优点和缺点？对于缺点有什么建议？"><a href="#跟同批次同学相比优点和缺点？对于缺点有什么建议？" class="headerlink" title="跟同批次同学相比优点和缺点？对于缺点有什么建议？"></a>跟同批次同学相比优点和缺点？对于缺点有什么建议？</h3><h3 id="主要技术栈是什么？新人是怎么进行培养的呢？"><a href="#主要技术栈是什么？新人是怎么进行培养的呢？" class="headerlink" title="主要技术栈是什么？新人是怎么进行培养的呢？"></a>主要技术栈是什么？新人是怎么进行培养的呢？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自我介绍-amp-项目介绍&quot;&gt;&lt;a href=&quot;#自我介绍-amp-项目介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍 &amp;amp; 项目介绍&quot;&gt;&lt;/a&gt;自我介绍 &amp;amp; 项目介绍&lt;/h2&gt;&lt;h2 id=&quot;从用户输入URL到看到页面，这个过</summary>
      
    
    
    
    <category term="FE-Interview" scheme="http://example.com/categories/FE-Interview/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue3-Vue2</title>
    <link href="http://example.com/2021/06/16/vue3-vue2/"/>
    <id>http://example.com/2021/06/16/vue3-vue2/</id>
    <published>2021-06-16T11:01:24.000Z</published>
    <updated>2021-09-17T06:55:21.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue3-相比-vue2-的十项优点"><a href="#vue3-相比-vue2-的十项优点" class="headerlink" title="vue3 相比 vue2 的十项优点"></a>vue3 相比 vue2 的十项优点</h1><p>本文章转载自华为云社区《<a href="https://www.oschina.net/action/GoToLink?url=https://bbs.huaweicloud.com/blogs/300280?utm_source=oschina&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">【云驻共创】vue3 相比 vue2 的十项优点</a>》，作者：海拥</p><p>Vue3新版本的理念成型于 2018 年末，当时的 Vue 2 已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，Vue3在2020年正式推出，在源码和API都有较大变化，性能得到了显著的提升，比Vue2.x快1.2~2倍。</p><p><strong>其中，一些比较重要的优点有：</strong></p><p>diff算法的优化；hoistStatic 静态提升；cacheHandlers 事件侦听器缓存；ssr渲染；更好的Ts支持；Compostion API: 组合API/注入API；更先进的组件；自定义渲染API；按需编译，体积比vue2.x更小；支持多根节点组件等。下面我们就来具体说说vue3 的优点：</p><h2 id="优点1：diff算法的优化"><a href="#优点1：diff算法的优化" class="headerlink" title="优点1：diff算法的优化"></a><strong>优点1：diff算法的优化</strong></h2><p>vue2中的虚拟dom是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上）</p><p>vue3新增了静态标记（patchflag）与上次虚拟节点对比时，只对比带有patch flag的节点（动态数据所在的节点）；可通过flag信息得知当前节点要对比的具体内容。</p><p>例如：下面的模板包含一个div，div内包含三个段落，其中前两个段落是静态固定不变的，而第三个段落的内容绑定的msg属性，当msg改变的时候，Vue会生成新的虚拟DOM然后和旧的进行对比。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>云驻共创<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>如何评价 vue3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当视图更新时，只对动态节点部分进行diff运算，减少了资源的损耗。Patchflag是个枚举，取值为1代表这个元素的文本是动态绑定的，取值为2代表元素的class是动态绑定的。</p><h2 id="优点2：hoistStatic-静态提升"><a href="#优点2：hoistStatic-静态提升" class="headerlink" title="优点2：hoistStatic 静态提升"></a><strong>优点2：hoistStatic 静态提升</strong></h2><p>vue2无论元素是否参与更新，每次都会重新创建然后再渲染。</p><p>vue3对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可。<br>例如：下面我们利用Vue 3 Template Explorer,来直观的感受一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>共创1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>共创2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>静态提升之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        _openBlock(),</span><br><span class="line">        _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;共创1&#x27;</span>),</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;共创2&#x27;</span>),</span><br><span class="line">            _createVNode(</span><br><span class="line">                <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                _toDisplayString(_ctx.name),</span><br><span class="line">                <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">            ),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态提升之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;共创1&#x27;</span>,</span><br><span class="line">    -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;共创2&#x27;</span>,</span><br><span class="line">    -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        _openBlock(),</span><br><span class="line">        _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _hoisted_1,</span><br><span class="line">            _hoisted_2,</span><br><span class="line">            _createVNode(</span><br><span class="line">                <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                _toDisplayString(_ctx.name),</span><br><span class="line">                <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">            ),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看出，_hoisted_1 和_hoisted_2 两个方法被提升到了渲染函数 render 之外，也就是我们说的静态提升。通过静态提升可以避免每次渲染的时候都要重新创建这些对象，从而大大提高了渲染效率。</p><h2 id="优点3：cacheHandlers-事件侦听器缓存"><a href="#优点3：cacheHandlers-事件侦听器缓存" class="headerlink" title="优点3：cacheHandlers 事件侦听器缓存"></a><strong>优点3：cacheHandlers 事件侦听器缓存</strong></h2><p>vue2.x中，绑定事件每次触发都要重新生成全新的function去更新，cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新。</p><p>默认情况下onClick会被视为动态绑定，所以每次都会追踪它的变化，但是同一个函数没必要追踪变化，直接缓存起来复用即可。</p><p>例如：下面我们同样是通过Vue 3 Template Explorer，来看一下事件监听器缓存的作用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;todo&quot;</span>&gt;</span>做点有趣的事<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该段 html 经过编译后变成我们下面的结构(未开启事件监听缓存)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_openBlock(),_createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>,&#123; <span class="attr">onClick</span>: _ctx.todo&#125;, <span class="string">&#x27;做点有趣的事&#x27;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>,</span><br><span class="line">                [<span class="string">&#x27;onClick&#x27;</span>]),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们开启事件监听器缓存后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_openBlock(),_createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>,&#123;</span><br><span class="line">                    onClick:    <span class="comment">//开启监听后</span></span><br><span class="line">                        _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span>_ctx.todo(...args)),</span><br><span class="line">                &#125;,<span class="string">&#x27;做点有趣的事&#x27;</span>),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对比开启事件监听缓存前后的代码，转换之后的代码, 大家可能还看不懂, 但是不要紧，我们只需要观察有没有静态标记即可，在Vue3的diff算法中, 只有有静态标记的才会进行比较, 才会进行追踪。</p><h2 id="优点4：ssr渲染"><a href="#优点4：ssr渲染" class="headerlink" title="优点4：ssr渲染"></a><strong>优点4：ssr渲染</strong></h2><p>Vue2 中也是有 SSR 渲染的，但是 Vue3 中的 SSR 渲染相对于 Vue2 来说，性能方面也有对应的提升。</p><p>当存在大量静态内容时，这些内容会被当作纯字符串推进一个 buffer 里面，即使存在动态的绑定，会通过模版插值潜入进去。这样会比通过虚拟 dmo 来渲染的快上很多。</p><p>当静态内容大到一个量级的时候，会用_createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml，就不需要再创建对象，然后根据对象渲染。</p><h2 id="优点5：更好的Ts支持"><a href="#优点5：更好的Ts支持" class="headerlink" title="优点5：更好的Ts支持"></a><strong>优点5：更好的Ts支持</strong></h2><p>vue2不适合使用ts，原因在于vue2的Option API风格。options是个简单对象，而ts是一种类型系统、面向对象的语法。两者有点不匹配。</p><p>在vue2结合ts的具体实践中，要用 vue-class-component 强化 vue 组件，让 Script 支持 TypeScript 装饰器，用 vue-property-decorator 来增加更多结合 Vue 特性的装饰器，最终搞的ts的组件写法和js的组件写法差别挺大。</p><p>在vue3中，量身打造了defineComponent函数，使组件在ts下，更好的利用参数类型推断 。Composition API 代码风格中，比较有代表性的api就是 ref 和 reactive，也很好的支持了类型声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Component = defineComponent(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        success: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">        student: &#123;</span><br><span class="line">          type: <span class="built_in">Object</span> <span class="keyword">as</span> PropType&lt;Student&gt;,</span><br><span class="line">          required: <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> year = ref(<span class="number">2020</span>)</span><br><span class="line">      <span class="keyword">const</span> month = ref&lt;string | number&gt;(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">      month.value = <span class="number">9</span> <span class="comment">// OK</span></span><br><span class="line">     <span class="keyword">const</span> result = year.value.split(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="优点6：Compostion-API-组合API-注入API"><a href="#优点6：Compostion-API-组合API-注入API" class="headerlink" title="优点6：Compostion API: 组合API/注入API"></a><strong>优点6：Compostion API: 组合API/注入API</strong></h2><p>传统的网页是html/css/javascript（结构/样式/逻辑）分离。vue通过组件化的方式，将联系紧密的结构/样式/逻辑放在一起，有利于代码的维护。compostion api更进一步，着力于JS（逻辑）部分，将逻辑相关的代码放在一起，这样更有利于代码的维护。</p><p>在vue2的组件内使用的是Option API风格(data/methods/mounted)来组织的代码，这样会让逻辑分散，举个例子就是我们完成一个计数器功能，要在data里声明变量，在methods定义响应函数，在mounted里初始化变量，如果在一个功能比较多、代码量比较大的组件里，你要维护这样一个功能，就需要在data/methods/mounted反复的切换到对应位置，然后进行代码的更改。</p><p>而在vue3中，使用setup函数。如下所示跟count相关的逻辑，都放到counter.js文件里，跟todo相关的逻辑放到todos.js里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useTodo <span class="keyword">from</span> <span class="string">&#x27;./todos&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> &#123; val, todos, addTodo &#125; = useTodo()</span><br><span class="line"><span class="keyword">let</span> &#123;count,add&#125; = useCounter() </span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">val, todos, addTodo,</span><br><span class="line">count,add,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点7：更先进的组件"><a href="#优点7：更先进的组件" class="headerlink" title="优点7：更先进的组件"></a><strong>优点7：更先进的组件</strong></h2><p>vue2是不允许这样写的，组件必须有一个跟节点，现在可以这样写，vue将为我们创建一个虚拟的Fragment节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;华为云享专家&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;全栈领域博主&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>在Suspended-component完全渲染之前，备用内容会被显示出来。如果是异步组件，Suspense可以等待组件被下载，或者在设置函数中执行一些异步操作。</p><h2 id="优点8：自定义渲染API"><a href="#优点8：自定义渲染API" class="headerlink" title="优点8：自定义渲染API"></a><strong>优点8：自定义渲染API</strong></h2><p>vue2.x项目架构对于weex（移动端跨平台方案）和myvue（小程序上使用）等渲染到不同平台不太友好，vue3.0推出了自定义渲染API解决了该问题。下面我们先看vue2和vue3的入口写法有哪些不同。</p><p>vue2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; =&gt; h(App)&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./src/App&quot;</span></span><br><span class="line">createApp(App).mount((<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue官方实现的 createApp 会给我们的 template 映射生成 html 代码，但是要是你不想渲染生成到 html ，而是要渲染生成到 canvas 之类的不是html的代码的时候，那就需要用到 Custom Renderer API 来定义自己的 render 渲染生成函数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime-render&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./src/App&quot;</span>; <span class="comment">// 根组件</span></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用自定义渲染API，如weex和myvue这类方案的问题就得到了完美解决。只需重写createApp即可。</p><h2 id="优点9：按需编译，体积比vue2-x更小"><a href="#优点9：按需编译，体积比vue2-x更小" class="headerlink" title="优点9：按需编译，体积比vue2.x更小"></a><strong>优点9：按需编译，体积比vue2.x更小</strong></h2><p>框架的大小也会影响其性能。这是 Web 应用程序的唯一关注点，因为需要即时下载资源，在浏览器解析必要的 JavaScript 之前该应用程序是不可交互的。对于单页应用程序尤其如此。尽管 Vue 一直是相对轻量级的（Vue 2 的运行时大小压缩为 23 KB）。</p><p>在 Vue 3 中，通过将大多数全局 API 和内部帮助程序移至 ES 模块导出来，实现了这一目标。这使现代的打包工具可以静态分析模块依赖性并删除未使用的导出相关的代码。模板编译器还会生成友好的 Tree-shaking 代码，在模板中实际使用了该功能时才导入该功能的帮助程序。</p><p>框架的某些部分永远不会 Tree-shaking，因为它们对于任何类型的应用都是必不可少的。我们将这些必不可少的部分的度量标准称为基准尺寸。尽管增加了许多新功能，但 Vue 3 的基准大小压缩后约为 10 KB，还不到 Vue 2 的一半。</p><h2 id="优点10：支持多根节点组件"><a href="#优点10：支持多根节点组件" class="headerlink" title="优点10：支持多根节点组件"></a><strong>优点10：支持多根节点组件</strong></h2><p>Vue3 一个模板不再限制有多个根节点，(多个根节点上的 Attribute 继承) 需要显式定义 attribute 应该分布在哪里。否则控制台会给出警告提示。</p><p>在 Vue 3 中，组件现在正式支持多根节点组件，即片段！</p><p>在 2.x 中，不支持多根组件，当用户意外创建多根组件时会发出警告，因此，为了修复此错误，许多组件被包装在一个中。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;header&gt;...&lt;&#x2F;header&gt;</span><br><span class="line">    &lt;main&gt;...&lt;&#x2F;main&gt;</span><br><span class="line">    &lt;footer&gt;...&lt;&#x2F;footer&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>在 3.x 中，组件现在可以有多个根节点！但是，这确实要求开发者明确定义属性应该分布在哪里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;&#x2F;header&gt;</span><br><span class="line">  &lt;main v-bind&#x3D;&quot;$attrs&quot;&gt;...&lt;&#x2F;main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="结尾想说的"><a href="#结尾想说的" class="headerlink" title="结尾想说的"></a><strong>结尾想说的</strong></h2><p>Vue是国内最火的前端框架之一。性能提升，运行速度是vue2的1.2-2倍。</p><ul><li>体积更小，按需编译体积vue2要更小。</li><li>类型推断，更好的支持ts这个也是趋势。</li><li>高级给予，暴露了更底层的API和提供更先进的内置组件。</li><li>组合API，能够更好的组织逻辑，封装逻辑，复用逻辑</li></ul><h2 id="对未来的展望："><a href="#对未来的展望：" class="headerlink" title="对未来的展望："></a><strong>对未来的展望：</strong></h2><p>技术总是越新越好，越来越多的企业都升级了vue3；</p><p>大型项目，由于对TS的友好越来越多的大型项目可以使用vue3；</p><p>作为程序员，我们就应该适应市场，提高自己的竞争力，为加薪提供空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue3-相比-vue2-的十项优点&quot;&gt;&lt;a href=&quot;#vue3-相比-vue2-的十项优点&quot; class=&quot;headerlink&quot; title=&quot;vue3 相比 vue2 的十项优点&quot;&gt;&lt;/a&gt;vue3 相比 vue2 的十项优点&lt;/h1&gt;&lt;p&gt;本文章转载自</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>koa2-demo</title>
    <link href="http://example.com/2021/06/12/koa2-demo/"/>
    <id>http://example.com/2021/06/12/koa2-demo/</id>
    <published>2021-06-12T12:53:10.000Z</published>
    <updated>2021-09-17T06:59:40.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Koa2框架的简单项目搭建及实战开发"><a href="#基于Koa2框架的简单项目搭建及实战开发" class="headerlink" title="[基于Koa2框架的简单项目搭建及实战开发]"></a>[基于Koa2框架的简单项目搭建及实战开发]</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://koa.bootcss.com/">Koa</a>是基于 Node.js 平台的下一代 web 开发框架，由express原班人马打造，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p><p>此文是简单介绍使用kos2进行项目的基本搭建以及api的简单开发</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1、Koa框架是基于node.js的，安装node是必须进行的第一步，这里就不在赘述了</p><p>2、安装koa（推荐使用淘宝镜像进行安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa --save</span><br></pre></td></tr></table></figure><p>3、全局安装Koa2的项目生成器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa-generator -g</span><br></pre></td></tr></table></figure><p>4、创建一个项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koa2 myProject</span><br></pre></td></tr></table></figure><p>5、进入这个项目文件夹，下载依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myProject</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure><blockquote><p>koa2 myProject 是用来生成项目的几门架构的</p></blockquote><p><img src="/images/koa2-demo/image-20210628200133834.png" alt="image-20210628200133834"></p><p>6、接下来，我们就可以启动项目服务了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">or</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:3000/%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%9E%E5%86%B5">http://localhost:3000/即可查看项目的运行实况</a></p><p><img src="/images/koa2-demo/image-20210628200448515.png" alt="image-20210628200448515"></p><h2 id="安装sequelize"><a href="#安装sequelize" class="headerlink" title="安装sequelize"></a>安装sequelize</h2><p>（Sequelize是一个基于promise的nodejs ORM，目前支持Postgres、mysql、SQLite和Microsoft SQL Server。它具有强大的事务支持，关联关系，读取和复制等功能。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install sequelize --save</span><br></pre></td></tr></table></figure><h2 id="安装mysql、mysql2"><a href="#安装mysql、mysql2" class="headerlink" title="安装mysql、mysql2"></a>安装mysql、mysql2</h2><p>项目使用的是mysql的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install mysql mysql2 --save</span><br></pre></td></tr></table></figure><h2 id="配置Sequelize的数据库链接"><a href="#配置Sequelize的数据库链接" class="headerlink" title="配置Sequelize的数据库链接"></a>配置Sequelize的数据库链接</h2><p>在项目的根目录下创建一个config目录，config目录中创建db.js，该文件主要用来创建mysql的数据库链接的。<br><code>/config/db.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;koa_demo&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, &#123;</span><br><span class="line">    host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    dialect: <span class="string">&#x27;mysql&#x27;</span>,</span><br><span class="line">    operatorsAliases: <span class="literal">false</span>,</span><br><span class="line">    dialectOptions: &#123;</span><br><span class="line">        <span class="comment">// 字符集</span></span><br><span class="line">        charset: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">        collate: <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">        supportBigNumbers: <span class="literal">true</span>,</span><br><span class="line">        bigNumberStrings: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    poll: &#123;</span><br><span class="line">        max: <span class="number">5</span>,</span><br><span class="line">        min: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 信号量：对特定资源的允许同时访问的操作数量进行控制（并发数）</span></span><br><span class="line">        acquire: <span class="number">30000</span>,</span><br><span class="line">        <span class="comment">// 空闲数</span></span><br><span class="line">        idle: <span class="number">10000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 东八时区 （&#x27;:08:00&#x27;）</span></span><br><span class="line">    timezone: <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sequelize</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其中koa_demo为数据库名称，root为数据库用户名，123456为数据库密码，这是我自己本地的默认数据库信息</p></blockquote><h2 id="创建schema、modules、controllers"><a href="#创建schema、modules、controllers" class="headerlink" title="创建schema、modules、controllers"></a>创建schema、modules、controllers</h2><p>schema:数据表模型实例<br>modules：实体模型<br>controllers：控制器</p><p>3个目录下分别创建student.js</p><p><img src="/images/koa2-demo/image-20210628200827484.png" alt="image-20210628200827484"></p><h3 id="schema数据表模型"><a href="#schema数据表模型" class="headerlink" title="schema数据表模型"></a>schema数据表模型</h3><p>在schema目录下新建一个student.js文件，该文件的主要作用就是建立与数据表的对应关系，也可以理解为代码的建表。<br><code>schema/student.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const moment = require(&quot;moment&quot;);</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">sequelize, DataTypes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sequelize.define(<span class="string">&#x27;student&#x27;</span>, &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: DataTypes.INTEGER,</span><br><span class="line">            primaryKey: <span class="literal">true</span>,</span><br><span class="line">            allowNull: <span class="literal">true</span>,</span><br><span class="line">            autoIncrement: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//学生姓名</span></span><br><span class="line">        name: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 婚否</span></span><br><span class="line">        married: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">true</span>,</span><br><span class="line">            field: <span class="string">&#x27;married&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//年龄</span></span><br><span class="line">        age: &#123;</span><br><span class="line">            type: DataTypes.INTEGER,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;age&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//性别</span></span><br><span class="line">        gender: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;gender&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//分数</span></span><br><span class="line">        grade: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;grade&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 创建时间</span></span><br><span class="line">        createdAt: &#123;</span><br><span class="line">            type: DataTypes.DATE</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 更新时间</span></span><br><span class="line">        updatedAt: &#123;</span><br><span class="line">            type: DataTypes.DATE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果为true，则表示名称和model相同，即user</span></span><br><span class="line"><span class="comment">         * 如果为fasle，mysql创建的表名称会是复数，即users</span></span><br><span class="line"><span class="comment">         * 如果指定的表名称本身就是复数，则形式不变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        freezeTableName: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模型应用、使用"><a href="#模型应用、使用" class="headerlink" title="模型应用、使用"></a>模型应用、使用</h3><p>在项目中modules目录下创建student.js文件，为学生信息表，该文件为文章的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mysql的配置文件</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../config/db&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; QueryTypes, DataTypes &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入sequelize对象</span></span><br><span class="line"><span class="keyword">const</span> Sequelize = db.sequelize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入数据表模型</span></span><br><span class="line"><span class="comment">// const student = Sequelize.import(&#x27;../schema/student&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;../schema/student&#x27;</span>)(Sequelize, DataTypes);</span><br><span class="line">student.sync(&#123; <span class="attr">force</span>: <span class="literal">false</span> &#125;); <span class="comment">//自动创建表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">studentModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   创建学生表模型</span></span><br><span class="line">    <span class="comment">//   @param data</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">createStudent</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> student.create(&#123;</span><br><span class="line">            name: data.name, <span class="comment">//姓名</span></span><br><span class="line">            age: data.age,  <span class="comment">//年龄</span></span><br><span class="line">            gender: data.gender,  <span class="comment">//性别</span></span><br><span class="line">            grade: data.grade, <span class="comment">//分数</span></span><br><span class="line">            married: data.married,  <span class="comment">//婚否</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   查询学生信息的详情</span></span><br><span class="line">    <span class="comment">//   @param id 学生信息ID</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise&lt;Model&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">getStudentDetail</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> student.findOne(&#123;</span><br><span class="line">            where: &#123;</span><br><span class="line">                id</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = studentModel;</span><br></pre></td></tr></table></figure><h3 id="controllers-控制器"><a href="#controllers-控制器" class="headerlink" title="controllers 控制器"></a>controllers 控制器</h3><p>控制器的主要作用为功能的处理，项目中controllers目录下创建student.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StudentModel = <span class="built_in">require</span>(<span class="string">&quot;../modules/student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">studentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   创建学生信息</span></span><br><span class="line">    <span class="comment">//   @param ctx</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise.&lt;void&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//接收客服端</span></span><br><span class="line">        <span class="keyword">let</span> req = ctx.request.body;</span><br><span class="line">        <span class="keyword">if</span> (req.name &amp;&amp; req.age &amp;&amp; req.gender &amp;&amp; req.grade &amp;&amp; req.married) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建学生信息模型</span></span><br><span class="line">                <span class="keyword">const</span> ret = <span class="keyword">await</span> StudentModel.createStudent(req);</span><br><span class="line">                <span class="comment">//使用刚刚创建的学生信息ID查询学生信息详情，且返回学生信息详情信息</span></span><br><span class="line">                <span class="keyword">const</span> data = <span class="keyword">await</span> StudentModel.getStudentDetail(ret.id);</span><br><span class="line"></span><br><span class="line">                ctx.response.status = <span class="number">200</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">200</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;创建学生信息成功&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                ctx.response.status = <span class="number">412</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">412</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;创建学生信息失败&#x27;</span>,</span><br><span class="line">                    data: err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.response.status = <span class="number">416</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                code: <span class="number">200</span>,</span><br><span class="line">                msg: <span class="string">&#x27;参数不齐全&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   获取学生详情</span></span><br><span class="line">    <span class="comment">//   @param ctx</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise.&lt;void&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">detail</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> id = ctx.params.id;</span><br><span class="line">        <span class="keyword">if</span> (id) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 查询学生信息详情模型</span></span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">await</span> StudentModel.getStudentDetail(id);</span><br><span class="line">                ctx.response.status = <span class="number">200</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">200</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                ctx.response.status = <span class="number">412</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">412</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;查询失败&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.response.status = <span class="number">416</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                code: <span class="number">416</span>,</span><br><span class="line">                msg: <span class="string">&#x27;学生ID必须传&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = studentController;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由，也可以简单理解为路径，主要是作为请求的url，请求的路径来处理一些请求，返回数据。一般情况下，基于node的项目，路由都是在一个叫做routes的目录下面。</p><p>routes目录下创建student.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)()</span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">const</span> StudentController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/student&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由前置</span></span><br><span class="line">router.prefix(<span class="string">&#x27;/student&#x27;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建学生</span></span><br><span class="line">router.post(<span class="string">&#x27;/student/create&#x27;</span>, StudentController.create);</span><br><span class="line"><span class="comment">//获取某个学生详情</span></span><br><span class="line">router.get(<span class="string">&#x27;/student/:id&#x27;</span>, StudentController.detail)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>然后在app.js添加如下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;./routes/student&#x27;</span>)</span><br><span class="line">app.use(student.routes(), student.allowedMethods())</span><br></pre></td></tr></table></figure><blockquote><p>注意koa框架的洋葱圈模型，不懂得可以去自行查询</p></blockquote><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><p>跨域是web开发中不可避免的一个必须要解决的问题了。跨域问题，主要是要解决服务器端的通信问题。在node的开发中，只需要实现一个CORS标准就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa-cors --save</span><br></pre></td></tr></table></figure><p>然后在根目录下的app.js加入koa-cors的引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const cors = require(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line">app.use(cors()) //使用cors</span><br></pre></td></tr></table></figure><blockquote><p>同理：注意koa框架的洋葱圈模型，不懂得可以去自行查询</p></blockquote><p>完整的app.js文件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">require</span>(<span class="string">&#x27;koa-json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> onerror = <span class="built_in">require</span>(<span class="string">&#x27;koa-onerror&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> users = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;./routes/student&#x27;</span>)</span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">onerror(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">// middlewares</span></span><br><span class="line">app.use(bodyparser(&#123;</span><br><span class="line">    enableTypes: [<span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;form&#x27;</span>, <span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">&#125;))</span><br><span class="line">app.use(json())</span><br><span class="line">app.use(logger())</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)(__dirname + <span class="string">&#x27;/public&#x27;</span>))</span><br><span class="line"></span><br><span class="line">app.use(views(__dirname + <span class="string">&#x27;/views&#x27;</span>, &#123;</span><br><span class="line">    extension: <span class="string">&#x27;pug&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span>() - start</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">// error-handling</span></span><br><span class="line">app.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;server error&#x27;</span>, err, ctx)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(student.routes(), student.allowedMethods())</span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="然后重启项目"><a href="#然后重启项目" class="headerlink" title="然后重启项目"></a>然后重启项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="/images/koa2-demo/image-20210628201511106.png" alt="image-20210628201511106"></p><p>如果启动过程中出现上图的结果，说明服务启动成功</p><h2 id="使用Postman软件进行接口的测试"><a href="#使用Postman软件进行接口的测试" class="headerlink" title="使用Postman软件进行接口的测试"></a>使用Postman软件进行接口的测试</h2><h4 id="创建一个student的测试接口为："><a href="#创建一个student的测试接口为：" class="headerlink" title="创建一个student的测试接口为："></a>创建一个student的测试接口为：</h4><p><a href="http://127.0.0.1:3000/student/student/create">http://127.0.0.1:3000/student/student/create</a></p><h4 id="查询一个student的测试接口为："><a href="#查询一个student的测试接口为：" class="headerlink" title="查询一个student的测试接口为："></a>查询一个student的测试接口为：</h4><p><a href="http://localhost:3000/student/student/1">http://localhost:3000/student/student/1</a></p><p>####请求条件选择为：</p><p>POST请求<br>Body ===&gt; x-www-form-rulencoded</p><h4 id="如下图所示"><a href="#如下图所示" class="headerlink" title="如下图所示"></a>如下图所示</h4><p><img src="/images/koa2-demo/image-20210628201654659.png" alt="image-20210628201654659"></p><p>点击《send》请求后，返回的信息如下：</p><p><img src="/images/koa2-demo/image-20210628201947721.png" alt="image-20210628201947721"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;创建学生信息成功&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jungle&quot;</span>,</span><br><span class="line">        <span class="string">&quot;married&quot;</span>: <span class="string">&quot;未婚&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createdAt&quot;</span>: <span class="string">&quot;2021-06-10T12:19:20.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updatedAt&quot;</span>: <span class="string">&quot;2021-06-10T12:19:20.000Z&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口返回成功后，我们去数据库里看一下这个表</p><p><img src="/images/koa2-demo/image-20210628202210099.png" alt="image-20210628202210099"></p><p>可以看到，已经在下koa_demo这个数据库中创建了一张student新表，且内容也是我们刚才进行添加的信息</p><h2 id="over"><a href="#over" class="headerlink" title="over"></a>over</h2><p>关于koa2的项目搭建先简单介绍到这里吧，算是对简单所学知识的一个小总结。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于Koa2框架的简单项目搭建及实战开发&quot;&gt;&lt;a href=&quot;#基于Koa2框架的简单项目搭建及实战开发&quot; class=&quot;headerlink&quot; title=&quot;[基于Koa2框架的简单项目搭建及实战开发]&quot;&gt;&lt;/a&gt;[基于Koa2框架的简单项目搭建及实战开发]&lt;/</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Node/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>koa2-core</title>
    <link href="http://example.com/2021/06/08/koa2-core/"/>
    <id>http://example.com/2021/06/08/koa2-core/</id>
    <published>2021-06-08T11:33:21.000Z</published>
    <updated>2021-09-17T06:59:21.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa2核心（洋葱圈模型）简介和实践理解"><a href="#Koa2核心（洋葱圈模型）简介和实践理解" class="headerlink" title="[Koa2核心（洋葱圈模型）简介和实践理解]"></a>[Koa2核心（洋葱圈模型）简介和实践理解]</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Koa2概述"><a href="#Koa2概述" class="headerlink" title="Koa2概述:"></a>Koa2概述:</h3><ul><li>基于Node.js平台的web开发框架</li><li>由Express原班人马打造：Express Koa Koa2</li></ul><p><img src="/images/koa2-core/1672451-20210511111549887-1302388100.png" alt="img"></p><ul><li> async/await 要求环境依赖Node v7.6.0及以上</li></ul><h3 id="Koa2特点"><a href="#Koa2特点" class="headerlink" title="Koa2特点"></a>Koa2特点</h3><ul><li>支持 async/await</li><li>洋葱模型中间件：当客户端发起一个请求到达第一层中间件并处理后，服务器处理请求，将处理结果传递给第二层中间件，到达第二层中间件后再处理，再将处理结果传递给第三层中间件，之后再进入第三层中间件处理；第三层处理后，依次将处理结果向上返回给第二层处理、第一层处理，最后第一层再响应给客户端</li></ul><p><img src="/images/koa2-core/1672451-20210511123621900-1538897783.png" alt="img"></p><h2 id="二、快速上手"><a href="#二、快速上手" class="headerlink" title="二、快速上手"></a>二、快速上手</h2><ul><li> <strong>检查Node的环境，要求环境依赖Node v7.6.0及以上</strong></li></ul><p>　　　　node -v</p><ul><li><strong>安装Koa</strong></li></ul><p>　　　　npm init -y</p><p>　　　　npm install koa</p><ul><li><strong>创建并编写app.js文件</strong></li></ul><p>　　　　1.创建Koa对象</p><p>　　　　2.编写相应函数(中间件)</p><p>　　　　3.监听窗口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建koa对象</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="comment">//编写响应函数(中间件)，ctx是应用上下文提供request和response方法接受和相应；</span></span><br><span class="line"><span class="comment">//参考洋葱模型，第二层中间件是否执行取决于第一层中间件的next()是否执行</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa1&quot;</span>) </span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span> next() <span class="comment">//执行第二层中间件，并且是异步的，next()返回一个Promise对象，在此等待第二层中间件返回后才继续往下执行；</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa1.1&quot;</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第二层中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx,next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa2&quot;</span>) </span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span> next(); <span class="comment">//执行第三层中间件，next()的返回值来自于第三层中间件的return，并且是一个Promise&#123;I love The dog!&#125;对象，　　　　　　　　　　　　　　　　　　//想要获取Promise对象中的数据，需要用await，则箭头函数要用async修饰；</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa2.1&quot;</span>) </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第三层中间件</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;koa3&quot;</span>)</span><br><span class="line">    ctx.response.body = <span class="string">&quot;hello koa3!&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I love The dog!&quot;</span>  <span class="comment">//向第二层中间件返回执行结果</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定端口号</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>在浏览器中输入：<a href="http://localhost:3000发起请求">http://localhost:3000发起请求</a></strong></li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在控制台可以看到这样的输出顺序</p><p><img src="/images/koa2-core/1672451-20210511123440580-1266972367.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Koa2核心（洋葱圈模型）简介和实践理解&quot;&gt;&lt;a href=&quot;#Koa2核心（洋葱圈模型）简介和实践理解&quot; class=&quot;headerlink&quot; title=&quot;[Koa2核心（洋葱圈模型）简介和实践理解]&quot;&gt;&lt;/a&gt;[Koa2核心（洋葱圈模型）简介和实践理解]&lt;/</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Node" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Node/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>vue中使用vue-qr生成并下载二维码</title>
    <link href="http://example.com/2021/05/26/Vue-qr/"/>
    <id>http://example.com/2021/05/26/Vue-qr/</id>
    <published>2021-05-26T01:42:04.000Z</published>
    <updated>2021-05-26T04:01:34.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue中使用vue-qr生成并下载二维码"><a href="#vue中使用vue-qr生成并下载二维码" class="headerlink" title="vue中使用vue-qr生成并下载二维码"></a>vue中使用vue-qr生成并下载二维码</h1><p>最近在项目中遇到一个生成二维码的需求，并且二维码上要带上logo和背景。</p><p>另一种二维码生成<strong>qrcode</strong>只能单纯的生成二维码，不能带logo及其它一些自定义。</p><p>于是选择了<strong>vue-qr</strong>。它具有自定义二维码背景、logo、实点颜色等等特性，能够生成更炫酷的二维码。</p><h2 id="vue中使用vue-qr生成二维码"><a href="#vue中使用vue-qr生成二维码" class="headerlink" title="vue中使用vue-qr生成二维码"></a>vue中使用vue-qr生成二维码</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-qr --save</span><br></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;basic-setting&quot;</span>&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;qrcode&quot;</span>&gt;</span><br><span class="line">        &lt;vue-qr :correctLevel=<span class="string">&quot;3&quot;</span> :autoColor=<span class="string">&quot;false&quot;</span> colorDark=<span class="string">&quot;#313a90&quot;</span> :bgSrc=<span class="string">&quot;bgSrc&quot;</span> :logoSrc=<span class="string">&quot;logoSrc&quot;</span> :text=<span class="string">&quot;codeUrl&quot;</span> :size=<span class="string">&quot;95&quot;</span> :margin=<span class="string">&quot;0&quot;</span> :logoMargin=<span class="string">&quot;3&quot;</span>&gt;&lt;/vue-qr&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">&quot;downloadImg&quot;</span>&gt;下载该二维码&#123;&#123; imgurl &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> VueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;vue-qr&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      imgurl: <span class="string">&quot;https://www.baidu.com/&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueQr,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="参数及说明"><a href="#参数及说明" class="headerlink" title="参数及说明"></a>参数及说明</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>text</td><td>二维码内容</td><td>是</td></tr><tr><td>size</td><td>尺寸, 长宽一致, 包含外边距</td><td>是</td></tr><tr><td>margin</td><td>二维码图像的外边距, 默认 20px</td><td>否</td></tr><tr><td>dotScale</td><td>数据区域点缩小比例,默认为0.35</td><td>否</td></tr><tr><td>correctLevel</td><td>容错级别 0-3</td><td>否</td></tr><tr><td>whiteMargin</td><td>若设为 true, 背景图外将绘制白色边框（默认是true）</td><td>否</td></tr><tr><td>bindElement</td><td>指定是否需要自动将生成的二维码绑定到HTML上（默认是true）</td><td>否</td></tr><tr><td>callback</td><td>生成的二维码 Data URI 可以在回调中取得,第一个参数为二维码 data URL, 第二个参数为 props 传过来的 qid(因为二维码生成是异步的,所以加个 id 用于排序)</td><td>否</td></tr></tbody></table><blockquote><p>可以使用 <code>bindElement</code> 来指定要自动填入二维码图像的元素的 ID（不含前导「#」），支持 <code>&lt;div&gt;</code> 或是 <code>&lt;img&gt;</code>。</p></blockquote><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><table><thead><tr><th>参数</th><th>说明</th><th>是否必要</th></tr></thead><tbody><tr><td>colorDark</td><td>黑点的颜色</td><td>否</td></tr><tr><td>colorLight</td><td>空白区域的颜色</td><td>否</td></tr><tr><td>autoColor</td><td>若为 true, 背景图的主要颜色将作为实点的颜色, 即 colorDark,默认 true</td><td>否</td></tr></tbody></table><blockquote><p>若设置了 <code>autoColor</code>，则 <code>colorDark</code> 和 <code>colorLight</code> 都将被忽略。</p></blockquote><h3 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h3><table><thead><tr><th><strong>参数</strong></th><th>说明</th><th>是否必要</th></tr></thead><tbody><tr><td>bgSrc</td><td>欲嵌入的背景图地址</td><td>否</td></tr><tr><td>gifBgSrc</td><td>欲嵌入的背景图 gif 地址,设置后普通的背景图将失效。设置此选项会影响性能</td><td>否</td></tr><tr><td>backgroundColor</td><td>背景色</td><td>否</td></tr><tr><td>backgroundDimming</td><td>叠加在背景图上的颜色, 在解码有难度的时有一定帮助</td><td>否</td></tr></tbody></table><blockquote><p>若设定了 <code>gifBackground</code> ，则 <code>backgroundImage</code> 将会被忽略。</p></blockquote><h3 id="logo图像"><a href="#logo图像" class="headerlink" title="logo图像"></a>logo图像</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>logoSrc</td><td>嵌入至二维码中心的 LOGO 地址</td><td>否</td></tr><tr><td>logoScale</td><td>用于计算 LOGO 大小的值, 过大将导致解码失败, LOGO 尺寸计算公式 logoScale*(size-2*margin), 默认 0.2</td><td>否</td></tr><tr><td>logoMargin</td><td>标识周围的空白边框, 默认为0</td><td>否</td></tr><tr><td>logoBackgroundColor</td><td>背景色,需要设置 logo margin</td><td>否</td></tr><tr><td>logoCornerRadius</td><td>标识及其边框的圆角半径, 默认为0</td><td>否</td></tr></tbody></table><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>binarize</td><td>若为 true, 图像将被二值化处理, 未指定阈值则使用默认值，默认是false</td><td>否</td></tr><tr><td>binarizeThreshold</td><td>(0 &lt; threshold &lt; 255) 二值化处理的阈值</td><td>否</td></tr></tbody></table><h2 id="vue中下载生成的二维码"><a href="#vue中下载生成的二维码" class="headerlink" title="vue中下载生成的二维码"></a>vue中下载生成的二维码</h2><h3 id="添加下载事件"><a href="#添加下载事件" class="headerlink" title="添加下载事件"></a>添加下载事件</h3><p>生成二维码&amp;下载二维码完整版代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;basic-setting&quot;</span>&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;qrcode&quot;</span>&gt;</span><br><span class="line">        &lt;vue-qr :correctLevel=<span class="string">&quot;3&quot;</span> :autoColor=<span class="string">&quot;false&quot;</span> colorDark=<span class="string">&quot;#313a90&quot;</span> :bgSrc=<span class="string">&quot;bgSrc&quot;</span> :logoSrc=<span class="string">&quot;logoSrc&quot;</span> :text=<span class="string">&quot;codeUrl&quot;</span> :size=<span class="string">&quot;95&quot;</span> :margin=<span class="string">&quot;0&quot;</span> :logoMargin=<span class="string">&quot;3&quot;</span>&gt;&lt;/vue-qr&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">&quot;downloadImg&quot;</span>&gt;下载该二维码&#123;&#123; imgurl &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> VueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;vue-qr&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义二维码扫描的地址</span></span><br><span class="line">      imgurl: <span class="string">&quot;https://www.baidu.com/&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueQr,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">downloadImg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> oQrcode = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#qrcode img&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> url = oQrcode.src;</span><br><span class="line">      <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">      <span class="comment">// 自定义下载二维码图片的名字</span></span><br><span class="line">      a.download = <span class="string">&quot;download二维码&quot;</span>;</span><br><span class="line">      <span class="comment">//url地址</span></span><br><span class="line">      a.href = url;</span><br><span class="line">      <span class="comment">//进行下载</span></span><br><span class="line">      a.dispatchEvent(event);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h3><p><img src="/images/Vue-qr/directive.gif" alt="directive"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue中使用vue-qr生成并下载二维码&quot;&gt;&lt;a href=&quot;#vue中使用vue-qr生成并下载二维码&quot; class=&quot;headerlink&quot; title=&quot;vue中使用vue-qr生成并下载二维码&quot;&gt;&lt;/a&gt;vue中使用vue-qr生成并下载二维码&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue-qr" scheme="http://example.com/tags/Vue-qr/"/>
    
  </entry>
  
  <entry>
    <title>ElementUI中gutter和offset的区别</title>
    <link href="http://example.com/2021/05/22/ElementUI-gutter&amp;offset/"/>
    <id>http://example.com/2021/05/22/ElementUI-gutter&amp;offset/</id>
    <published>2021-05-22T12:12:02.000Z</published>
    <updated>2021-05-22T12:23:57.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="elementui中gutter和offset的区别"><a href="#elementui中gutter和offset的区别" class="headerlink" title="elementui中gutter和offset的区别"></a>elementui中gutter和offset的区别</h1><blockquote><p> gutter是指栅格间间隔，offset是指栅格左侧的间隔格数</p></blockquote><h2 id="分栏间隔"><a href="#分栏间隔" class="headerlink" title="分栏间隔"></a><strong>分栏间隔</strong></h2><p>el-row配置行，el-col配置列，像是一个个单行的表格</p><p>el-row上的属性gutter，默认值为0，可以设置大于0的任意数字</p><p>在PC端，设置的这个gutter值为该单元格左右的padding之和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-row :gutter=<span class="string">&quot;20&quot;</span>&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure><p>上图代表的是<code>&quot;padding-left: 10px; padding-right: 10px;&quot;</code></p><p><img src="/images/ElementUI-gutter&offset/20200810154559866.png" alt="在这里插入图片描述"></p><h2 id="分栏偏移"><a href="#分栏偏移" class="headerlink" title="分栏偏移"></a><strong>分栏偏移</strong></h2><p>el-col的offset属性，设置某个el-col元素左侧<strong>空多少份</strong>的位置，默认为0</p><p>如果其offset和span之和大于<strong>24</strong>，则该行剩余元素移到下一行，同时这个元素只显示一部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">&lt;el-col :span=<span class="string">&quot;6&quot;</span> :offset=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/ElementUI-gutter&offset/20200810154943500.png" alt="在这里插入图片描述"></p><p>即：中间会偏移原先6份大小的位置~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;elementui中gutter和offset的区别&quot;&gt;&lt;a href=&quot;#elementui中gutter和offset的区别&quot; class=&quot;headerlink&quot; title=&quot;elementui中gutter和offset的区别&quot;&gt;&lt;/a&gt;elementu</summary>
      
    
    
    
    <category term="Css" scheme="http://example.com/categories/Css/"/>
    
    
    <category term="ElementUI" scheme="http://example.com/tags/ElementUI/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>内卷之下|拒绝个人内卷化</title>
    <link href="http://example.com/2021/05/10/Perception-03/"/>
    <id>http://example.com/2021/05/10/Perception-03/</id>
    <published>2021-05-10T02:44:27.000Z</published>
    <updated>2021-05-10T10:43:34.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>总结：</strong>内卷不但不会创造价值，而且会危害每一个人。</p></blockquote><p>不知道从什么时候开始，“内卷”这个概念变得很火炎焱燚。</p><p>什么是内卷？什么是内卷化？内卷究竟卷的是什么？众说纷纭。</p><p><strong>随着网络的发酵，“内卷”的使用场景不断扩大，“万物皆可内卷”。</strong>人们对内卷这个概念原本的语义价值已经不太在意，更多只是用来描述当下的“难”，借以表达对各自行业和处境的不满。</p><p><strong>内卷，渐渐成为“标签化”的情绪攻讦。</strong></p><p>如此，就太可惜了。我们连最开始讨论“内卷”的意义都失去了。</p><p>我们需要的是，冷静地审视“内卷”：社会的内卷，个人的内卷；更需要的是，冷静地思考：内卷之下，如何寻求突破？</p><h2 id="但无论如何我们都要去清楚的了解，什么才是“内卷”！"><a href="#但无论如何我们都要去清楚的了解，什么才是“内卷”！" class="headerlink" title="但无论如何我们都要去清楚的了解，什么才是“内卷”！"></a>但无论如何我们都要去清楚的了解，什么才是“内卷”！</h2><h3 id="1-什么是内卷"><a href="#1-什么是内卷" class="headerlink" title="1. 什么是内卷"></a><strong>1. 什么是内卷</strong></h3><p>很久很久以前，地球上有一个小镇。小镇上有很多鞋店，这些鞋店每天上午10点开门，中午12点到下午2点午休，下午2点到晚上6点继续营业；每周一至周五营业5天，周末休息。</p><p>天最热的那几天，鞋店老板们会纷纷把店关掉，去南方的海边度假；冬天最冷的那几天，鞋店老板们也会纷纷把店关掉，去北方的山里滑雪。</p><p>多年以来，小镇上的常住人口没有什么变化，鞋的品质一直优秀，供货也稳定，所以，<strong>小镇上的鞋的供需关系一直处于一个近乎完美的平衡状态。</strong></p><p>后来有一天，一户人家出于不明原因从大城市搬来小镇上，并且也开了一家鞋店。小镇虽然小，但也算具有一定规模，鞋的供需平衡还不至于因为新增一家鞋店而被打破。</p><p>但是，那座大城市的人民以勤奋、能吃苦著称。果然，这户来自大城市的人家也具备这些特点。他们家的鞋店每天早晨7点就开门了，中午也不午休，晚上直到11点才关门；周末他们也正常营业，夏天和冬天他们也从不去度假。</p><p>渐渐地，他们的“勤奋”得到了回报，他们鞋店的生意明显好于小镇上的其他鞋店。以前小镇人民吃完晚饭后是无法买鞋的，但现在，他们几乎随时可以去大城市人的鞋店买鞋，也就没什么必要光顾其他鞋店了。</p><p>但小镇老板们也不服输，他们纷纷效仿大城市人民的作息时间，每周工作7天，每天工作16小时。他们的“勤奋”也得到了“回报”：他们的营业收入恢复到了以前的状态。</p><p>那么，此时的小镇生活发生了什么样的变化呢？由于小镇人口并没有增加，鞋的需求量保持恒定，跟以前一样，所以每家鞋店最终的营业收入没什么变化，并不会增长。但营业时间从原来的每周5天，每天6小时变成了每周7天，每天16小时。</p><p>也就是说，<strong>他们的工作时间变长了，但收入却没有增加。</strong></p><p>这就是传说中的内卷（involution）。同时，这也是传说中的囚徒困境。</p><h3 id="2-什么是囚徒困境"><a href="#2-什么是囚徒困境" class="headerlink" title="2. 什么是囚徒困境"></a><strong>2. 什么是囚徒困境</strong></h3><p>我们可以把鞋店简化为两家：大城市鞋店和小镇鞋店。他们工作模式也可简化为996和955。小镇上鞋的需求不变。根据以上条件可知：</p><ul><li><strong>如果两家鞋店都选择955</strong>，会平分市场需求，同时也保证了休息时间，这种情况下总体收益最高，假设两家的收益分别是5, 5。</li><li><strong>如果两家鞋店都采取996</strong>工作模式，最终仍然会平分市场，但由于休息时间减少，幸福感降低，收益不能再是5, 5而应该是3, 3。</li><li><strong>而如果一家店选择了996而另一家店选择了955</strong>，那么996鞋店最终可能会独占市场，而955鞋店会没生意，于是两家的收益可假设为8, 0。</li></ul><p>这场博弈中两位鞋店的<strong>赢利表</strong>如下：</p><p><img src="/images/Perception-03/640" alt="图片"></p><p>两位鞋店老板彼此不知道对方是怎么想的，但他们都是“聪明”人，很容易算出：如果对方996，那么我955的收益是0，我也996的收益是3，所以我应该996；如果对方955，那么我也955的收益是5，我996的收益8，所以我应该996。</p><p>最终，两家鞋店都选择了996，这场博弈达到<strong>纳什均衡</strong>，<strong>两位老板都成了996的“囚徒”。</strong></p><blockquote><p>纳什均衡是这样一种状态，在该状态下每个参与人所采取的策略都是对于其他参与人的策略的最优反应。</p><p>——摘自董志强 《身边的博弈》，机械工业出版社·华章经管</p></blockquote><h3 id="3-什么是勤劳和公平"><a href="#3-什么是勤劳和公平" class="headerlink" title="3. 什么是勤劳和公平"></a><strong>3. 什么是勤劳和公平</strong></h3><p>任何一个行业都不是孤立存在的。鞋店老板们工作时间变长了，娱乐时间就变少了，他们光顾餐馆、咖啡馆的次数就少了，于是小镇上的餐饮业变得冷清了。虽然鞋店的营业时间延长，他们的耗电量增加，但餐馆、咖啡馆却在一些生意冷清的时段进入了节电模式，所以发电厂的生意也没有变好。</p><p><strong>总体算下来，小镇的经济不但没有变好，反而变差了一些。</strong>所以，我们可以看到，<strong>内卷不但有危害，而且会危害到看似无辜的每一个人。</strong></p><p>疲惫的小镇鞋店老板们也很快意识到了这个问题，于是他们成立鞋业协会，联合小镇政府制定强制性的行业规则和劳动法：每日工作时间不得超过8小时、每周营业时间不得超过5天，法定节假日必须休息……鞋业协会有权要求不遵守规定的鞋店关门，对屡教不改者，鞋业协会将联合小镇政府将其驱逐出小镇……</p><p>行规一出，来自大城市的人家就立即抗议，他们觉得这是对勤劳致富者的不尊重，也是对消费者的不尊重，这是干涉他们的自由，这是对他们的不公平对待和地域歧视……</p><p>鞋业协会立即怼了回去：你们所谓的勤劳并没有真正致富，反而对社会造成了危害。鞋店又不是急救中心，消费者早一天买鞋还是晚一天买鞋往往并没有区别。你们只顾着自己的作息时间而不管他人，这不是自由，而是自私，这才是真正的不公平……劳动法面前人人平等，并没针对谁、歧视谁，对违法的人采取强制措施也是天经地义……</p><h3 id="4、大城市社会工作中"><a href="#4、大城市社会工作中" class="headerlink" title="4、大城市社会工作中"></a>4、大城市社会工作中</h3><p>如果你觉得内卷是老板们才要关心的问题，跟打工人无关，那么我们离开小镇，来看看大城市里发生的故事。</p><p>大城市里有一家皮鞋款式设计公司，原本每一位打工人都是9点上班5点下班。后来，一位从小镇来的打工人进入这家公司，他本没有从业经验，为了得到这份工作在简历上和面试时都说了谎。于是开始打工时，他非常吃力，每天5点下班时他都无法完成工作，只好继续加班到9点才离开。</p><p>有一天，老板买了一个跑步机放在自己办公室里。从那天起，老板都会在完成工作后跑步健身，要在8点左右才离开办公室。所以他发现，这位小镇青年每天在8点时还没下班。于是，在下一个月的公司例会上，他表扬了小镇青年的刻苦精神，并宣布要他发奖金。</p><p>此后，其他打工人也发生了变化。有些人想，反正我下班之后也没什么事情，不如等8点以后再走，让老板也看到我加班，也给我发奖金。于是，加班的人逐渐多了起来。</p><p>起初，他们获得奖金，但一段时间过后，<strong>随着加班的人变成了大多数</strong>，老板对这些“勤奋刻苦”的人见怪不怪了，<strong>奖金的事也不再提了</strong>……。反而是那些下班后有事要做不能加班的人经常被老板批评，甚至被扣工资。</p><p>于是，打工人的工作时间延长了，但收入并没有增加，内卷害了每一个人。</p><p>要打破囚徒困境，打工人可以像小镇鞋店老板那样，成立工会争取自己合法权利。但他们其实还有另一种办法，就是辞掉这份工作，去另一家不需要加班的公司。</p><p>而对于老板来说，如果选择满足工会要求，其实并没有什么损失，大家只是回到以前的状态而已，公司的业绩就算不增长，也不会下降。但如果他选择拒绝，那么那些本来能力优秀的打工人很可能选择离开，留下像小镇青年那样不得不加班的低效率打工人，这就是<strong>劣币驱逐良币</strong>，毫无疑问，良币被驱逐意味着企业将蒙受损失。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>因此，内卷不会创造价值，而且会危害每一个人。如果打工人不觉醒、不抗争，管理者不制定有效措施防止内卷，而任由内卷的发生，我们每一个人都将是受害者，每个人的幸福感都会降低。</p><h2 id="内卷之下｜如何解决个人的内卷化问题？"><a href="#内卷之下｜如何解决个人的内卷化问题？" class="headerlink" title="内卷之下｜如何解决个人的内卷化问题？"></a><strong>内卷之下｜如何解决个人的内卷化问题？</strong></h2><h3 id="1、解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。"><a href="#1、解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。" class="headerlink" title="1、解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。"></a>1、<strong>解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。</strong></h3><p>中国传统文化给了我们很多精神财富，同时也给了我们很多包袱：热衷道德宣判，没事喜欢评价别人，又特别害怕别人评价自己；随大流受魅惑，没有独立的眼光，独立的判断能力；功利意识爆棚，满口仁义道德，真到做事，功利为上；贪多求全责备，恨不得拿下所有证书；多元眼光为零，对社会的观察完全没有多元的眼光。</p><p>当下又被管理主义、教条主义、科学主义折腾得够呛。每天做无数的规定动作，在其中消耗生命。</p><p>这种情况下，我们需要一个坚定的心态来实现个人的反内卷。</p><ul><li><p><strong>第一，面对嘈嘈杂杂的意见，要有战略性躺平的意识。</strong></p></li><li><p><strong>第二，对于重重叠叠的要求，要明白它们的机制性来由。</strong></p></li><li><p><strong>第三，对于社会提倡的林林总总的能力，你要集中一切精力和资历，培养行业的核心能力。</strong></p></li></ul><h3 id="2、善于用智慧的方式实现个人成长。"><a href="#2、善于用智慧的方式实现个人成长。" class="headerlink" title="2、善于用智慧的方式实现个人成长。"></a>2、善于用智慧的方式实现个人成长。</h3><ul><li><strong>第一，培养独立人格。你要有独立的眼光，要把自己立起来，站稳脚跟。这是成长的起点。</strong></li></ul><p>如果你心里装的全是别人塞给你的各种各样的观点，身受各种各样的枷锁，你怎么可能观察这样的社会？你连你自己都认识不了，你怎么认识社会？你连你自己都立不起来，你怎么样去做事业？</p><ul><li><strong>第二，进行系统化修身。</strong></li></ul><p>你要明白自身这个相对独立的小系统的运作，掌握身心两个层面的结构调试能力，在自我调试中悟道。这是成长的基础。</p><ul><li><strong>第三，实现人生的开放式演化。</strong></li></ul><p>你要找到你自身这个小系统与社会大系统、天地超系统之间的关联点，锚定价值点。</p><h3 id="何谓成长之道？"><a href="#何谓成长之道？" class="headerlink" title="何谓成长之道？"></a>何谓成长之道？</h3><p>就是去做只有你才能做的事，或者你能比别人做得更好的事。只要你能为社会做出贡献，你就有权利得到回报。同时培养自己轨道放开的能力，就是在具体问题上，不要锁死在一个轨道上，或者锁死在某一个目标上，某一个情绪上。心灵是开放的，思维方式是开放的，即所谓成长之道！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;内卷不但不会创造价值，而且会危害每一个人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道从什么时候开始，“内卷”这个概念变得很火炎焱燚。&lt;/p&gt;
&lt;p&gt;什么是内卷？什么是内卷化？内卷究竟卷的是什么？众说纷</summary>
      
    
    
    
    <category term="随笔感悟" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="Perception" scheme="http://example.com/tags/Perception/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-Vuex</title>
    <link href="http://example.com/2021/05/07/VueBasis-Vuex/"/>
    <id>http://example.com/2021/05/07/VueBasis-Vuex/</id>
    <published>2021-05-07T11:13:15.000Z</published>
    <updated>2021-05-07T08:32:09.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="1、什么是vuex？"><a href="#1、什么是vuex？" class="headerlink" title="1、什么是vuex？"></a>1、什么是vuex？</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态， 并以相应的规则保证状态以一种可预测的方式发生改变简单来说，就是用来集中管理数据；</p><h4 id="2、使用vuex的核心概念"><a href="#2、使用vuex的核心概念" class="headerlink" title="2、使用vuex的核心概念"></a>2、使用vuex的核心概念</h4><h5 id="1）store"><a href="#1）store" class="headerlink" title="1）store"></a>1）store</h5><p>vuex 中最关键的是store对象，这是vuex的核心。可以说，vuex这个插件其实就是一个store对象，每个vue应用仅且仅有一个store对象。</p><p>（1）创建store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;...&#125;);</span><br></pre></td></tr></table></figure><p>可见，store是Vuex.Store这个构造函数new出来的实例。在构造函数中可以传一个对象参数。这个参数中可以包含5个对象：</p><ul><li><p>state – 存放状态</p></li><li><p>getters – state的计算属性</p></li><li><p>mutations – 更改状态的逻辑，同步操作</p></li><li><p>actions – 提交mutation，异步操作</p></li><li><p>mudules – 将store模块化</p></li></ul><p>关于store，需要先记住两点：</p><ul><li><p>store 中存储的状态是响应式的，当组件从store中读取状态时，如果store中的状态发生了改变，那么相应的组件也会得到更新；</p></li><li><p>不能直接改变store中的状态。改变store中的状态的唯一途径是提交(commit)mutations。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><p>（2）完整的store的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line"><span class="comment">// 存放状态</span></span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line"><span class="comment">// state的计算属性</span></span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">    <span class="comment">// 更改state中状态的逻辑，同步操作</span></span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line"><span class="comment">// 提交mutation，异步操作</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 如果将store分成一个个的模块的话，则需要用到modules。</span></span><br><span class="line"><span class="comment">//然后在每一个module中写state, getters, mutations, actions等。</span></span><br><span class="line">modules: &#123;</span><br><span class="line">a: moduleA,</span><br><span class="line">b: moduleB,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）-state"><a href="#2）-state" class="headerlink" title="2） state"></a>2） state</h5><p>state上存放的，说的简单一些就是变量，也就是所谓的状态。没有使用 state 的时候，我们都是直接在data 中进行初始化的，但是有了 state 之后，我们就把 data 上的数据转移到 state 上去了。另外有些状态是组件私有的状态，称为组件的局部状态，我们不需要把这部分状态放在store中去。</p><p>（1）如何在组件中获取vuex状态</p><p>由于vuex的状态是响应式的，所以从store中读取状态的的方法是在组件的计算属性中返回某个状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;store&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">computed: &#123;</span><br><span class="line">count () &#123;</span><br><span class="line"><span class="comment">// 获取store中的状态</span></span><br><span class="line"><span class="keyword">return</span> store.state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，组件中的状态就与store中的状态关联起来了。每当store.state.count发生变化时，都会重新求取计算属性，从而更新DOM。<br>然而，每个组件中都需要反复倒入store。<strong>可以将store注入到vue实例对象中去</strong>，这样每一个子组件中都可以直接获取store中的状态，而不需要反复的倒入store了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="comment">// 把 store 对象注入到了</span></span><br><span class="line">store,</span><br><span class="line">components: &#123; Counter &#125;,</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样可以在子组件中使用<code>this.$store.state.count</code>访问到state里面的count这个状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">computed: &#123;</span><br><span class="line">count () &#123;</span><br><span class="line"><span class="comment">// 获取store中的状态</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） mapState<br>当一个组件获取多种状态的时候，则在计算属性中要写多个函数。为了方便，可以使用mapState辅助函<br>数来帮我们生成计算属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">data ()&#123;</span><br><span class="line">localState: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">computed: mapState(&#123;</span><br><span class="line"><span class="comment">// 此处的state即为store里面的state</span></span><br><span class="line">count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"><span class="comment">// 当计算属性的名称与state的状态名称一样时，可以省写</span></span><br><span class="line"><span class="comment">// 映射 this.count1 为 store.state.count1</span></span><br><span class="line">count1,</span><br><span class="line"><span class="comment">//&#x27;count&#x27;等同于 ‘state =&gt; state.count’</span></span><br><span class="line">countAlias: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">countPlus (state)&#123;</span><br><span class="line"><span class="comment">// 使用普通函数是为了保证this指向组件对象</span></span><br><span class="line"><span class="keyword">return</span> state.count + <span class="built_in">this</span>.localState;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面是通过mapState的对象来赋值的，还可以通过mapState的数组来赋值</span></span><br><span class="line">computed: mapState([<span class="string">&#x27;count&#x27;</span>]);</span><br><span class="line"><span class="comment">//这种方式很简洁，但是组件中的state的名称就跟store中映射过来的同名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象扩展运算符<br>mapState 函数返回的是一个对象，为了将它里面的计算属性与组件本身的局部计算属性组合起来，需<br>要用到对象扩展运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">localState () &#123;</span><br><span class="line">...mapState (&#123;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，mapState中的计算属性就与localState计算属性混合一起了</p><h5 id="3）getters"><a href="#3）getters" class="headerlink" title="3）getters"></a>3）getters</h5><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表表进行过滤并计数。此时可以用到<br>getters，getters可以看作是store的计算属性，其参数为state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line">todos: [</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;reading&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;playBastketball&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>获取getters里面的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// [&#123; id: 1, text: &#x27;reading&#x27;, done: true &#125;]</span></span><br><span class="line"><span class="comment">//在组件中，则要写在计算属性中，</span></span><br><span class="line">computed: &#123;</span><br><span class="line">doneTodos () &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）mutations"><a href="#4）mutations" class="headerlink" title="4）mutations"></a>4）mutations</h5><p>mutations里面是如何更改state中状态的逻辑。更改Vuex中的state的唯一方法是，提交mutation，即<br>store.commit(‘increment’)。</p><blockquote><p>注意：mutation必须是同步函数，不能是异步的，这是为了调试的方便。</p></blockquote><h5 id="5）actions"><a href="#5）actions" class="headerlink" title="5）actions"></a>5）actions</h5><p>因为mutations中只能是同步操作，但是在实际的项目中，会有异步操作，那么actions就是为了异步操<br>作而设置的。这样，就变成了在action中去提交mutation，然后在组件的methods中去提交action。只<br>是提交actions的时候使用的是dispatch函数，而mutations则是用commit函数。</p><h4 id="3、Vuex在Vue-Cli中的实践使用"><a href="#3、Vuex在Vue-Cli中的实践使用" class="headerlink" title="3、Vuex在Vue-Cli中的实践使用"></a>3、Vuex在Vue-Cli中的实践使用</h4><p>项目搭建及添加vuex<br>当我们使用vue-cli搭建一个vue项目的时候，搭建完成后的文件目录是这样子的</p><p><img src="/images/VueBasis-Vuex/image-20210507161550120.png" alt="image-20210507161550120"></p><p>首先使用 <code>npm install --save-dev vuex </code>把vuex添加到依赖，接下来就是如何在组件中使用vuex，大<br>体上来说有以下两种形式。</p><h5 id="1、通过-store-选项"><a href="#1、通过-store-选项" class="headerlink" title="1、通过 store 选项"></a>1、通过 store 选项</h5><p>如果vue-cli搭建成功，在src目录下会有一个main.js文件，main.js的主要作用是把项目中最顶层的<br>app.vue组件挂载到DOM中，其他所有的组件都可以看做是app.vue的子组件。<br>在main.js中，做如下操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意下面的代码</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state： &#123;&#125;，</span><br><span class="line">getters: &#123;&#125;,</span><br><span class="line">actions: &#123;&#125;,</span><br><span class="line">mutations: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意router选项，此处的写法等同于store: store</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件中，就可以通过 this.$store 来使用store实例；<br>如果在项目中需要配置的vuex选项很多，我们则应该把vuex的相关代码分割到不同模块<br>在src下新建store文件夹，在文件夹中创建如下几个文件</p><p><img src="/images/VueBasis-Vuex/image-20210507161924220.png" alt="image-20210507161924220"></p><p>我们可以随意设置文件名，但最好可以通过文件名就能判断出这个文件是用来干嘛的<br><code>index.js</code>：整合各个模块，创建并导出vuex实例<br><code>rootState.js</code>：配置vuex实例的state选项<br><code>getters.js</code>：getter选项<br><code>mutations.js</code>：mutations选项<br><code>actions.js</code>：actions选项</p><p>在index.js中，我们需要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./rootState.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">&#x27;./mutations.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&#x27;./actions.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state,</span><br><span class="line">getters,</span><br><span class="line">actions,</span><br><span class="line">mutations</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的四个文件配置都差不多一样，以<code>rootState.js</code>为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">count: <span class="number">0</span>,</span><br><span class="line">arr: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state;</span><br></pre></td></tr></table></figure><p>如此这般，在main.js中，我们需要编写的代码就减少了很多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>将vuex实例挂载到vue原型链上</strong></p><p>这是一种非主流的方式，主要是受axios启发，在这种方法中，我们需要这样修改main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在vue中使用vuex必须先调用vue.use方法</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="comment">//具体挂载到vue原型的哪个属性上，可以由我们自行决定</span></span><br><span class="line"><span class="comment">//遇到配置繁多的情况也可以进行分割</span></span><br><span class="line">Vue.prototype.$store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state： &#123;&#125;，</span><br><span class="line">getters: &#123;&#125;,</span><br><span class="line">actions: &#123;&#125;,</span><br><span class="line">mutations: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有了store选项</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">router,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如此这般，还是可以通过 <code>this.$store</code> 来使用vuex。</p><h4 id="4、实践操作，修改state的值"><a href="#4、实践操作，修改state的值" class="headerlink" title="4、实践操作，修改state的值"></a>4、实践操作，修改state的值</h4><p>1）安装 vuex</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex -S</span><br></pre></td></tr></table></figure><p>2）在目录下创建store文件,并进行如下编辑</p><p><img src="/images/VueBasis-Vuex/image-20210507162519056.png" alt="image-20210507162519056"></p><p>3）然后再main.js中全局引入</p><p><img src="/images/VueBasis-Vuex/image-20210507162618400.png" alt="image-20210507162618400"></p><p>4）最后在组件中使用</p><p><img src="/images/VueBasis-Vuex/image-20210507162745928.png" alt="image-20210507162745928"></p><p>这个的功能是运用mutations 修改state中的值，演示效果如下：</p><p><img src="/images/VueBasis-Vuex/directive.gif" alt="directive"></p><h4 id="5、vuex-actions异步修改状态"><a href="#5、vuex-actions异步修改状态" class="headerlink" title="5、vuex actions异步修改状态"></a>5、vuex actions异步修改状态</h4><p>1）在store.js中声明actions</p><p>actions是可以调用Mutations里的方法的，我们还是继续在上节课的代码基础上进行学习，在actions里<br>调用add和reduce两个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions =&#123;</span><br><span class="line"><span class="function"><span class="title">addAction</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">context.commit(<span class="string">&#x27;add&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">reduceAction</span>(<span class="params">&#123;commit&#125;</span>)</span>&#123;</span><br><span class="line">commit(<span class="string">&#x27;reduce&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations<br>里边的方法。细心的小伙伴会发现这两个方法传递的参数也不一样。</p><ul><li><p>context：上下文对象，这里你可以理解称store本身。</p></li><li><p>{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。</p></li></ul><p>2）模板中的使用</p><p>我们需要在count.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的<br>actions里的方法名，分别是：addAction和reduceAction。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addAction&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;reduceAction&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">...mapMutations([</span><br><span class="line"><span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;reduce&#x27;</span></span><br><span class="line">]),</span><br><span class="line">...mapActions([<span class="string">&#x27;addAction&#x27;</span>,<span class="string">&#x27;reduceAction&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>得用import把我们的mapActions引入才可以使用。</p></blockquote><p>3）增加异步检验</p><p>我们现在看的效果和我们用Mutations作的一模一样，肯定有的小伙伴会好奇，那actions有什么用，我<br>们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用<br>setTimeOut进行延迟执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeOut(<span class="function">()=&gt;</span>&#123;context.commit(reduce)&#125;,<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我比reduce提前执行&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h3&gt;&lt;h4 id=&quot;1、什么是vuex？&quot;&gt;&lt;a href=&quot;#1、什么是vuex？&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vuex" scheme="http://example.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-VueRouter</title>
    <link href="http://example.com/2021/05/05/VueBasis-VueRouter/"/>
    <id>http://example.com/2021/05/05/VueBasis-VueRouter/</id>
    <published>2021-05-05T06:32:25.000Z</published>
    <updated>2021-05-07T03:02:05.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="1、vue-router如何响应-路由参数-的变化？"><a href="#1、vue-router如何响应-路由参数-的变化？" class="headerlink" title="1、vue-router如何响应 路由参数 的变化？"></a>1、vue-router如何响应 路由参数 的变化？</h4><p>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这<strong>也意味着组件的生命周期钩子不会再被调用。</strong></p><p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地<strong>watch (监测变化) $route 对象</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">watch: &#123;</span><br><span class="line"><span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line"><span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// react to route changes...</span></span><br><span class="line"><span class="comment">// don&#x27;t forget to call next()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意是：</span><br><span class="line">（<span class="number">1</span>）从同一个组件跳转到同一个组件。</span><br><span class="line">（<span class="number">2</span>）生命周期钩子created和mounted都不会调用。</span><br></pre></td></tr></table></figure><h4 id="2、完整的-vue-router-导航解析流"><a href="#2、完整的-vue-router-导航解析流" class="headerlink" title="2、完整的 vue-router 导航解析流"></a>2、完整的 vue-router 导航解析流</h4><p>1）导航被触发。</p><p>2）在失活的组件里调用离开守卫。</p><p>3）调用全局的 beforeEach 守卫。</p><p>4）在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p><p>5）在路由配置里调用 beforeEnter 。</p><p>6）解析异步路由组件。</p><p>7）在被激活的组件里调用 beforeRouteEnter 。</p><p>8）调用全局的 beforeResolve 守卫 (2.5+)。</p><p>9）导航被确认。</p><p>10）调用全局的 afterEach 钩子。</p><p>11）触发 DOM 更新。</p><p>12）用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p><p><img src="/images/VueBasis-VueRouter/image-20210429173157369.png" alt="image-20210429173157369"></p><h4 id="3、vue-router有哪几种导航钩子（-导航守卫-）？"><a href="#3、vue-router有哪几种导航钩子（-导航守卫-）？" class="headerlink" title="3、vue-router有哪几种导航钩子（ 导航守卫 ）？"></a>3、vue-router有哪几种导航钩子（ 导航守卫 ）？</h4><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p><p>例如判断登录信息：没登录全部跳到登录页。判断必要操作是否进行没进行的话中断跳转。<br><strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察 <code>$route</code> 对象响应路由参数的变<br>化)来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。</p><p><strong>分为三大类：全局守卫、路由守卫、组件守卫</strong></p><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><p>可以使用 router.beforeEach 注册一个全局前置守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫<br>resolve 完之前一直处于 等待中。<br>    &nbsp; 每个守卫方法接收三个参数：</p><ul><li><code>to: Route</code> : 即将要进入的目标 路由对象</li><li><code>from: Route</code> : 当前导航正要离开的路由</li><li><code>next: Function</code> : 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</li><li><code>next()</code> : 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li><code>next(false</code>) : 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</li><li><code>next(&#39;/&#39;) </code><strong>或者</strong> <code>next(&#123; path: &#39;/&#39; &#125;)</code> : 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 <code>replace: true</code> 、 <code>name:&#39;home&#39; </code>之类的选项以及任何用在 <code>router-link </code>的 <code>to </code>prop或 <code>router.push</code> `中的选项。</li><li><code>next(error) :</code> (2.4.0+) 如果传入 <code>next </code>的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError() </code>注册过的回调。</li></ul><p><strong>确保要调用 <code>next </code>方法，否则钩子就不会被 resolved。</strong></p><h5 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h5><p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 router.beforeEach 类似，区<br>别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。</p><h5 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h5><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next </code>函数也不会改变导航本<br>身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h5><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">component: Foo,</span><br><span class="line">beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h5 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h5><p>最后，可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">template: <span class="string">`...`</span>,</span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line"><span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line"><span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line"><span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line"><span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line"><span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line"><span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beforeRouteEnter </code>守卫 <strong>不能</strong> 访问 <code>this</code> ，因为守卫在导航确认前被调用,因此即将登场的新组件还没<br>被创建。<br>不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实<br>例作为回调方法的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next </code>传递回调的唯一守卫。对于 <code>beforeRouteUpdate </code>和<br><code>beforeRouteLeave</code> 来说， <code>this</code> 已经可用了，所以不支持传递回调，因为没有必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// just use `this`</span></span><br><span class="line"><span class="built_in">this</span>.name = to.params.name</span><br><span class="line">next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span> , next) &#123;</span><br><span class="line"><span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to leave? you have unsaved</span></span><br><span class="line"><span class="string">changes!&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (answer) &#123;</span><br><span class="line">next()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、vue-router传递参数的几种方式"><a href="#4、vue-router传递参数的几种方式" class="headerlink" title="4、vue-router传递参数的几种方式"></a>4、vue-router传递参数的几种方式</h4><h5 id="1）使用name传递"><a href="#1）使用name传递" class="headerlink" title="1）使用name传递"></a>1）使用name传递</h5><p>之前一直在配置路由的时候出现一个name,但不知道他具体有什么用，在路由里他可以用来传递参数。<br>在index.js中将路由的name都写好</p><p><img src="/images/VueBasis-VueRouter/image-20210429213649393.png" alt="image-20210429213649393"></p><p>接收参数：</p><p>在我们需要接收它的页面里添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是router-name:&#123;&#123;$route.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/VueBasis-VueRouter/image-20210429213719976.png" alt="image-20210429213719976"></p><p>比如我在这里是在APP.vue中接收的，我希望切换每个页面都能看见参数。<br>但这种方法不太常用，因为我们觉得它不太规整。</p><h5 id="2）to来传递"><a href="#2）to来传递" class="headerlink" title="2）to来传递"></a>2）to来传递</h5><p>利用router-link 中的to来传参，看语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link v-bind:to&#x3D;&quot;&#123;name:&#39;xxx&#39;,params:&#123;key:value&#125;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li><p>a.首先：to需要绑定；</p></li><li><p>b.传参使用类似与对象的形式；</p></li><li><p>c.name就是我们在配置路由时候取的名字；</p></li><li><p>d.参数也是采用对象的形式。</p></li><li><p>实际操作一下：</p><p>=&gt; a.在APP.vue中将to里面的路径改成上面那样</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:&#39;hellovue&#39;,params:&#123;username:&#39;tomcat&#39;&#125;&#125;&quot;&gt;hellovue页面</span><br><span class="line">&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>这里我们注意to的写法，前面加了冒号，因为那是绑定的，传递一个username过去，值为tomcat</p><p>​    =&gt; b.在index.js里面给hellovue配置名字叫hellovue,与上面name相对应</p><p><img src="/images/VueBasis-VueRouter/image-20210429214048560.png" alt="image-20210429214048560"></p><p>​    =&gt; c、在hellovue.vue中接收参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>传递的名字是：&#123;&#123;$route.params.username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3）采用url传参"><a href="#3）采用url传参" class="headerlink" title="3）采用url传参"></a>3）采用url传参</h5><p>在路由文件里采用冒号的形式传参，这就是对参数的绑定</p><ul><li><p>a、修改index.js里的path，这里我们修改myjob.vue组件</p><p><img src="/images/VueBasis-VueRouter/image-20210429214435188.png" alt="image-20210429214435188"></p></li><li><p>b、在App.vue组件里传递参数</p><p><img src="/images/VueBasis-VueRouter/image-20210429214445901.png" alt="image-20210429214445901"></p></li><li><p>c、在myjob.vue组件里显示我们要展示的内容（接收参数）</p></li></ul><p><img src="/images/VueBasis-VueRouter/image-20210429214453495.png" alt="image-20210429214453495"></p><h4 id="5、vue-router的动态路由匹配"><a href="#5、vue-router的动态路由匹配" class="headerlink" title="5、vue-router的动态路由匹配"></a>5、vue-router的动态路由匹配</h4><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对<br>于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中<br>使用“动态路径参数”(dynamic segment) 来达到这个效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line"><span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在呢，像<code>/user/foo</code>和 <code>/user/bar</code> 都将映射到相同的路由。</p><p>一个“路径参数”使用冒号 <code>: </code>标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，<br>可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 ID：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>/user/:username</td><td>/user/evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>/user/:username/post/:post_id</td><td>/user/evan/post/123</td><td><code>&#123; username: &#39;evan&#39;, post_id:&#39;123&#39; &#125;</code></td></tr></tbody></table><p>除了 <code>$route.params</code> 外， <code>$route</code> 对象还提供了其它有用的信息，例如， <code>$route.query</code> (如果 URL<br>中有查询参数)、 <code>$route.hash</code> 等等。</p><h4 id="6、vue-router如何定义嵌套路由？"><a href="#6、vue-router如何定义嵌套路由？" class="headerlink" title="6、vue-router如何定义嵌套路由？"></a>6、vue-router如何定义嵌套路由？</h4><p>任何子路由都是在其父路由的组件中切换显示，不管是多少层的路由嵌套，都是这样的理解，所以父路由需要有以下两点，二者缺一不可</p><blockquote><p>有组件引用<br>组件中有router-view组件</p></blockquote><p>父路由没有引用组件，导致子路由没有承载容器，自然而然就出现了两层路由跳不起来等不起效的情况</p><h4 id="7、-lt-router-link-gt-lt-router-link-gt-组件及其属性"><a href="#7、-lt-router-link-gt-lt-router-link-gt-组件及其属性" class="headerlink" title="7、 &lt;router-link&gt; &lt;/router-link&gt; 组件及其属性"></a>7、 <code>&lt;router-link&gt; &lt;/router-link&gt;</code> 组件及其属性</h4><p>支持用户在具有路由功能的应用中 (点击) 导航 通过 to 属性指定目标地址<br>一：router-link组件的props：</p><ul><li><strong>to</strong></li></ul><p>表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&#39;&#x2F;Home&#39;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">渲染结果：</span><br><span class="line">&lt;a href&#x3D;&quot;Home&quot;&gt;Home&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;register&#39;, query: &#123; name: &#39;fjw&#39; &#125;&#125;&quot;&gt;router&lt;&#x2F;routerlink&gt;</span><br><span class="line">渲染结果：</span><br><span class="line">&lt;a href&#x3D;&quot;&#x2F;register?name&#x3D;fjw&quot;&gt;router&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>tag</strong></li></ul><p>指定<code>&lt;router-link&gt;</code>组件最终被渲染成什么标签；非必须；如果没有tag属性，<code>router-link</code>默认会被渲染成a标签。在下面的例子中，渲染成了li标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&#39;&#x2F;Home&#39; tag&#x3D;&quot;li&quot; &gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">渲染结果：</span><br><span class="line">&lt;li&gt;Home&lt;&#x2F;li&gt;</span><br><span class="line">此时依旧会监听点击事件，触发导航</span><br></pre></td></tr></table></figure><ul><li><strong>replace</strong></li></ul><p>当点击时，会调用 <code>router.replace() </code>而不是 <code>router.push()</code>，于是导航后不会留下 history 记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;abc&#39;&#125;&quot; replace&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>append</strong></li></ul><p>则在当前 (相对) 路径前添加基路径。/a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;relative&#x2F;path&#39;&#125;&quot; append&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>active-class</strong></li></ul><p>表示激活这个链接时，添加的class，默认是<code>router-link-class</code>。默认值可以通过路由的构造选项<br><code>linkActiveClass</code> 来全局配置。</p><ul><li><strong>exact</strong></li></ul><p>“是否激活” 默认类名的依据是 inclusive match (全包含匹配)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个链接只会在地址为 &#x2F; 的时候被激活 --&gt;</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;&quot; exact&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>event</strong></li></ul><p>默认值: ‘click’ 声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。</p><ul><li><strong>exact-active-class</strong></li></ul><p>默认值: “router-link-exact-active” 配置当链接被精确匹配的时候应该激活的 class。</p><h4 id="8、vue-router实现路由懒加载"><a href="#8、vue-router实现路由懒加载" class="headerlink" title="8、vue-router实现路由懒加载"></a>8、vue-router实现路由懒加载</h4><p>在项目router/index.js文件中将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../views/About.vue&#x27;</span></span><br></pre></td></tr></table></figure><p>更改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：</span></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/About&#x27;</span>)</span><br><span class="line"><span class="comment">//方法2：</span></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;../views/About&#x27;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="built_in">module</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可实现路由懒加载的效果</p><h4 id="9、vue-router路由的两种模式"><a href="#9、vue-router路由的两种模式" class="headerlink" title="9、vue-router路由的两种模式"></a>9、vue-router路由的两种模式</h4><p>类型: <code>string</code></p><p>默认值: <code>&quot;hash&quot; (浏览器环境) | &quot;abstract&quot; (Node.js 环境)</code></p><p>可选值: <code>&quot;hash&quot; | &quot;history&quot; | &quot;abstract</code></p><p>配置路由模式:</p><ul><li><p><code>hash </code>: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</p></li><li><p><code>history </code>: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p></li><li><p><code>abstract </code>: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。<strong>如果发现没有浏览器的 API，路由会自动强制进入这个模式</strong></p></li></ul><h5 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a><strong>Hash模式</strong></h5><p>Hash 模式是 Vue-Router 的默认模式，具体的体现是在浏览器地址栏上 URL 路径永远带着一个「#」号。在浏览器支持度上面，Hash 模式是比较强势的，甚至能兼容低版本的 IE 浏览器。「#」号后面内容的改变，不会引起页面对服务端的请求，所以也就不会重新加载页面。在部署服务器方面，个人认为 Hash 模式比 History 模式来得更为方便，因为 History 有 URL 重定向问题，需要在服务端去配置 url 重定向，否则会报 404 错误。市面上也有不少大厂是使用 Hash 模式进行开发的，比如网易云音乐</p><h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a><strong>History 模式</strong></h5><p>HTML5 History API 提供了一个 <code>history.pushState</code> 和 <code>history.reolaceState</code> 方法（浏览器支持情况不是很乐观），它能让开发人员在不刷新网页的情况下改变站点的 URL。因为 Hash 模式会带上一个「#」号，会让 URL 地址变得比较难看，所以很多开发者都会选择 History 模式开发。但有个缺点，前端的 URL 必须和实际向服务端发起的请求的 URL 保持一致，如果服务端没有对相应的路由做处理，则会返回 404 错误页面。</p><blockquote><p>拓展：前进，后退，跳转操作方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.go(-<span class="number">3</span>);<span class="comment">//后退3次</span></span><br><span class="line">history.go(<span class="number">2</span>);<span class="comment">//前进2次</span></span><br><span class="line">history.go(<span class="number">0</span>);<span class="comment">//刷新当前页面</span></span><br><span class="line">history.back(); <span class="comment">//后退</span></span><br><span class="line">history.forward(); <span class="comment">//前进</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a><strong>abstract 模式</strong></h5><p>abstract 模式针对的是没有浏览器环境的情况，比如 Weex 客户端开发，内部是没有浏览器 API 的，那么 Vue-Router 自身会对环境做校验，强制切换到 abstract 模式，如果默认在 Vue-Router 的配置项中不写 mode 的值，在浏览器环境下会默认启用 Hash 模式，在移动客户端下使用 abstract 模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h3&gt;&lt;h4 id=&quot;1、vue-router如何响应-路由参数-的变化？&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue Router" scheme="http://example.com/tags/Vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-Vue-cli工程</title>
    <link href="http://example.com/2021/05/03/VueBasis-VueCli/"/>
    <id>http://example.com/2021/05/03/VueBasis-VueCli/</id>
    <published>2021-05-03T04:22:45.000Z</published>
    <updated>2021-05-07T03:01:46.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-cli工程"><a href="#vue-cli工程" class="headerlink" title="vue-cli工程"></a>vue-cli工程</h3><h4 id="1、构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？"><a href="#1、构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？" class="headerlink" title="1、构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？"></a>1、构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</h4><p>(1) <code>vue.js</code>：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。<br>(2) <code>vue-route</code>r：vue官方推荐使用的路由框架。<br>(3) <code>vuex</code>：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。<br>(4) <code>axios</code>（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。<br>(5) <code>vux</code>等：一个专为vue设计的移动端UI组件库。<br>(6) 创建一个emit.js文件，用于vue事件机制的管理。<br>(7) <code>webpack</code>：模块加载和vue-cli工程打包器。</p><h4 id="2、vue-cli-工程常用的-npm-命令有哪些？"><a href="#2、vue-cli-工程常用的-npm-命令有哪些？" class="headerlink" title="2、vue-cli 工程常用的 npm 命令有哪些？"></a>2、vue-cli 工程常用的 npm 命令有哪些？</h4><p>下载 node_modules 资源包的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>启动 vue-cli 开发环境的 npm命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>vue-cli 生成 生产环境部署资源 的 npm命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build --report</span><br></pre></td></tr></table></figure><h4 id="3、请说出vue-cli工程中每个文件夹和文件的用处"><a href="#3、请说出vue-cli工程中每个文件夹和文件的用处" class="headerlink" title="3、请说出vue-cli工程中每个文件夹和文件的用处"></a>3、请说出vue-cli工程中每个文件夹和文件的用处</h4><p>vue-cli目录解析：<br>(1) <code>build </code>文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下<br>webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。<br>(2) <code>config </code>文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下<br>config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启<br>gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。<br>(3) <code>dist </code>文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。<br>(4) <code>node_modules</code>：存放npm命令下载的开发环境和生产环境的依赖包。<br>(5) <code>src</code>: 存放项目源码及需要引用的资源文件。<br>(6) src下<code>assets</code>：存放项目中需要用到的资源文件，css、js、images等。<br>(7) src下<code>componets</code>：存放vue开发中一些公共组件：header.vue、footer.vue等。<br>(8) src下<code>emit</code>：自己配置的vue集中式事件管理机制。<br>(9) src下<code>router：vue</code>-router vue路由的配置文件。<br>(10) src下<code>service</code>：自己配置的vue请求后台接口方法。<br>(11) src下<code>page</code>：存在vue页面组件的文件夹。<br>(12) src下<code>util</code>：存放vue开发过程中一些公共的.js方法。<br>(13) src下<code>vuex</code>：存放 vuex 为vue专门开发的状态管理器。<br>(14) src下<code>app.vue</code>：使用标签 <code>&lt;route-view&gt;</code>  <code>&lt;/router-view&gt; </code>渲染整个工程的.vue组件。<br>(15) src下<code>main.js</code>：vue-cli工程的入口文件。<br>(16) <code>index.html</code>：设置项目的一些meta头信息和提供 <code>&lt;div id=&quot;app&quot;&gt;</code> <code>&lt;/div&gt;</code> 用于挂载 vue 节点。<br>(17) <code>package.json</code>：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。</p><h4 id="4、config文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置"><a href="#4、config文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置" class="headerlink" title="4、config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置"></a>4、config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置</h4><p>(1) <code>index</code>：配置打包后入口.html文件的名称以及文件夹名称<br>(2) <code>assetsRoot</code>：配置打包后生成的文件名称和路径<br>(3) <code>assetsPublicPath</code>：配置 打包后 .html 引用静态资源的路径，一般要设置成 “./“<br>(4) <code>productionGzip</code>：是否开发 gzip 压缩，以提升加载速度</p><h5 id="dev-对象下对于开发环境的配置："><a href="#dev-对象下对于开发环境的配置：" class="headerlink" title="dev 对象下对于开发环境的配置："></a>dev 对象下对于开发环境的配置：</h5><p>(1) <code>port</code>：设置端口号<br>(2) <code>autoOpenBrowser</code>：启动工程时，自动打开浏览器<br>(3) <code>proxyTable</code>：vue设置的代理，用以解决 跨域 问题</p><h4 id="5、详细介绍一些-package-json-里面的配置"><a href="#5、详细介绍一些-package-json-里面的配置" class="headerlink" title="5、详细介绍一些 package.json 里面的配置"></a>5、详细介绍一些 package.json 里面的配置</h4><p>常用对象解析：<br>(1) <code>scripts</code>：npm run xxx 命令调用node执行的 .js 文件<br>(2) <code>dependencies</code>：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里面<br>(3) <code>devDependencies</code>：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不<br>会打包进 生产环境js文件 里面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-cli工程&quot;&gt;&lt;a href=&quot;#vue-cli工程&quot; class=&quot;headerlink&quot; title=&quot;vue-cli工程&quot;&gt;&lt;/a&gt;vue-cli工程&lt;/h3&gt;&lt;h4 id=&quot;1、构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？&quot;&gt;</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue Cli" scheme="http://example.com/tags/Vue-Cli/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-核心知识点</title>
    <link href="http://example.com/2021/05/01/VueBasis-Core/"/>
    <id>http://example.com/2021/05/01/VueBasis-Core/</id>
    <published>2021-05-01T01:13:11.000Z</published>
    <updated>2021-05-07T07:58:30.945Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、对于Vue是一套渐进式框架的理解"><a href="#1、对于Vue是一套渐进式框架的理解" class="headerlink" title="1、对于Vue是一套渐进式框架的理解"></a>1、对于Vue是一套渐进式框架的理解</h4><p>渐进式代表的含义是：没有多做职责之外的事，vue.js只提供了vue-cli生态中最核心的组件系统和双向<br>数据绑定，就好像 vuex、vue-router都属于围绕vue.js开发的库。<br>示例：</p><h5 id="使用Angular，必须接受以下东西："><a href="#使用Angular，必须接受以下东西：" class="headerlink" title="使用Angular，必须接受以下东西："></a>使用Angular，必须接受以下东西：</h5><p>1）必须使用它的模块机制。<br>2）必须使用它的依赖注入。<br>3）必须使用它的特殊形式定义组件（这一点每个视图框架都有，这是难以避免的）<br>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西<br>集成，这些主张会带来一些困扰。</p><h5 id="使用React，你必须理解："><a href="#使用React，你必须理解：" class="headerlink" title="使用React，你必须理解："></a>使用React，你必须理解：</h5><p>1）函数式编程的理念。<br>2）需要知道它的副作用。<br>3）什么是纯函数。<br>4）如何隔离、避免副作用。<br>5）它的侵入性看似没有Angular那么强，主要因为它是属于软性侵入的。</p><h5 id="Vue与React、Angular的不同是，但它是渐进的："><a href="#Vue与React、Angular的不同是，但它是渐进的：" class="headerlink" title="Vue与React、Angular的不同是，但它是渐进的："></a>Vue与React、Angular的不同是，但它是渐进的：</h5><p>1）可以在原有的大系统的上面，把一两个组件改用它实现，就是当成jQuery来使用。<br>2）可以整个用它全家桶开发，当Angular来使用。<br>3）可以用它的视图，搭配你自己设计的整个下层使用。<br>4）可以在底层数据逻辑的地方用OO和设计模式的那套理念。<br>5）可以函数式，它只是个轻量视图而已，只做了最核心的东西。</p><h4 id="2、vue-js的两个核心是什么？"><a href="#2、vue-js的两个核心是什么？" class="headerlink" title="2、vue.js的两个核心是什么？"></a>2、vue.js的两个核心是什么？</h4><p>数据驱动和组件系统：<br><strong>数据驱动</strong>：ViewModel，保证数据和视图的一致性。<br><strong>组件系统</strong>：应用类UI可以看作全部是由组件树构成的。</p><h4 id="3、-v-if-和-v-show-有什么区别"><a href="#3、-v-if-和-v-show-有什么区别" class="headerlink" title="3、 v-if 和 v-show 有什么区别"></a>3、 v-if 和 v-show 有什么区别</h4><p><strong>相同点</strong>：<br>两者都是在判断DOM节点是否要显示。<br><strong>不同点</strong>：<br>(1) 实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。 v-show只是在<br>修改元素的css样式，也就是display的属性值，元素始终在Dom树上。<br>(2) 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子<br>组件； v-show只是简单的基于css切换；<br>(3) 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局<br>部编译； v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被<br>保留；<br>(4) 性能消耗：v-if有更高的切换消耗，不适合做频繁的切换； v-show有更高的初始渲染消耗，适合做频<br>繁的额切换；</p><h4 id="4、vue常用的修饰符"><a href="#4、vue常用的修饰符" class="headerlink" title="4、vue常用的修饰符"></a>4、vue常用的修饰符</h4><h5 id="a、按键修饰符"><a href="#a、按键修饰符" class="headerlink" title="a、按键修饰符"></a>a、按键修饰符</h5><p>如：.delete（捕获“删除”和”退格“键） 用法上和事件修饰符一样，挂载在v-on:后面，<br>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;aaa&#x27;</span> v-model=<span class="string">&quot;inputValue&quot;</span> @keyup.delete=<span class="string">&quot;onKey&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h5 id="b、系统修饰符"><a href="#b、系统修饰符" class="headerlink" title="b、系统修饰符"></a>b、系统修饰符</h5><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器<br>(1) .ctrl<br>(2) .alt<br>(3) .shift<br>(4) .meta</p><h5 id="c、鼠标按钮修饰符"><a href="#c、鼠标按钮修饰符" class="headerlink" title="c、鼠标按钮修饰符"></a>c、鼠标按钮修饰符</h5><p>(1) .left<br>(2) .right<br>(3) .middle<br>这些修饰符会限制处理函数仅响应特定的鼠标按钮。<br>如： 鼠标滚轮单击触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.middle =<span class="string">&quot;onClick&quot;</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Click默认是鼠标左键单击</p></blockquote><h5 id="d、其他修饰符"><a href="#d、其他修饰符" class="headerlink" title="d、其他修饰符"></a>d、其他修饰符</h5><p>(1) .lazy<br>在默认情况下， v-model 在每次 input 事件触发后将输入框的值与数据进行同步 ，我们可以添<br>加 lazy 修饰符，从而转变为使用 change 事件进行同步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.lazy=<span class="string">&quot;msg&quot;</span> &gt;</span><br></pre></td></tr></table></figure><p>(2) .number<br>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 .number 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值<br>无法被 parseFloat() 解析，则会返回原始的值。<br>(3) .trim<br>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=<span class="string">&quot;msg&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>同样前面都有空格加上.trim后 将前后空格都去掉了。</p><h4 id="5、v-on可以监听多个方法"><a href="#5、v-on可以监听多个方法" class="headerlink" title="5、v-on可以监听多个方法"></a>5、v-on可以监听多个方法</h4><p>v-on可以监听多个方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-on在vue2.x中测试,以下两种均可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123;mouseenter: onEnter,mouseleave: onLeave&#125;&quot;</span>&gt;</span>鼠标进来1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseenter</span>=<span class="string">&quot;onEnter&quot;</span> @<span class="attr">mouseleave</span>=<span class="string">&quot;onLeave&quot;</span>&gt;</span>鼠标进来2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;a(),b()&quot;</span>&gt;</span>点我ab<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;one()&quot;</span>&gt;</span>点我onetwothree<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6、vue中-key-值的作用"><a href="#6、vue中-key-值的作用" class="headerlink" title="6、vue中 key 值的作用"></a>6、vue中 key 值的作用</h4><p>使用key来给每个节点做一个<strong>唯一标识</strong><br>key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使<br>用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效<br>果。</p><h4 id="7、vue-cli工程升级vue版本"><a href="#7、vue-cli工程升级vue版本" class="headerlink" title="7、vue-cli工程升级vue版本"></a>7、vue-cli工程升级vue版本</h4><p>npm install -g @vue/cli</p><h4 id="8、vue事件中如何使用event对象？"><a href="#8、vue事件中如何使用event对象？" class="headerlink" title="8、vue事件中如何使用event对象？"></a>8、vue事件中如何使用event对象？</h4><blockquote><p>注意在事件中要使用 $ 符号</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html部分</span></span><br><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0);&quot;</span> data-id=<span class="string">&quot;12&quot;</span> @click=<span class="string">&quot;showEvent($event)&quot;</span>&gt;event&lt;/a&gt;</span><br><span class="line"><span class="comment">//js部分</span></span><br><span class="line"><span class="function"><span class="title">showEvent</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="comment">//获取自定义data-id</span></span><br><span class="line"><span class="built_in">console</span>.log(event.target.dataset.id)</span><br><span class="line"><span class="comment">//阻止事件冒泡</span></span><br><span class="line">event.stopPropagation();</span><br><span class="line"><span class="comment">//阻止默认</span></span><br><span class="line">event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、-nextTick的使用"><a href="#9、-nextTick的使用" class="headerlink" title="9、$nextTick的使用"></a>9、$nextTick的使用</h4><blockquote><p>参数： {Function} [callback]</p></blockquote><p><strong>用法</strong>：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。<br>它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><p><strong>理解</strong>：<strong>nextTick()，是将回调函数延迟在下一次dom更新数据后调用</strong>，简单的理解是：<strong>当数据更新了，在dom中渲染后，自动执行该函数，</strong></p><p>实例：</p><p>未使用this.$nextTick()</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;msgp&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>$nextTick<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">name: <span class="string">&#x27;nextTick&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">msg: <span class="string">&#x27;未更新&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="javascript"><span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 修改数据</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.msg = <span class="string">&#x27;被更新了&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// DOM还没有更新</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.msgp.innerHTML)</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// DOM更新了</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;$nextTick:&#x27;</span> + <span class="built_in">this</span>.$refs.msgp.innerHTML)</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="javascript"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用this.$nextTick()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;    </span><br><span class="line">    testClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">        <span class="keyword">let</span> that=<span class="built_in">this</span>;      </span><br><span class="line">        that.testMsg=<span class="string">&quot;修改后的值&quot;</span>;      </span><br><span class="line">        that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        </span><br><span class="line">            <span class="built_in">console</span>.log(that.$refs.aa.innerText);  /</span><br><span class="line">            /输出：修改后的值      </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。<code>$nextTick</code> 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code>，则可以在回调中获取更新后的 DOM。</p></blockquote><h5 id="nextTick-的应用场景"><a href="#nextTick-的应用场景" class="headerlink" title="$nextTick() 的应用场景:"></a>$nextTick() 的应用场景:</h5><p>在vue的生命周期 <strong>created() 钩子函数中进行 dom 操作</strong>，一定要放在 <code>$nextTick()</code> 函数中执行。在created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p><p><strong>mounted() 钩子函数</strong>，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题，</p><p>在<strong>数据变化后要执行某个操作</strong>，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置<code>$nextTick()</code> 的回调函数中。</p><h4 id="10、Vue-组件中-data-为什么必须是函数"><a href="#10、Vue-组件中-data-为什么必须是函数" class="headerlink" title="10、Vue 组件中 data 为什么必须是函数"></a>10、Vue 组件中 data 为什么必须是函数</h4><p>在 new Vue() 中， data 是可以作为一个对象进行操作的，然而在 component 中， data 只能以函数的形式存在，不能直接将对象赋值给它。</p><p>当data选项是一个函数的时候，每个实例可以维护一份被返回对象的独立的拷贝，这样各个实例中的<br>data不会相互影响，是独立的。</p><h4 id="11、v-for-与-v-if-的优先级"><a href="#11、v-for-与-v-if-的优先级" class="headerlink" title="11、v-for 与 v-if 的优先级"></a>11、v-for 与 v-if 的优先级</h4><p>当它们处于同一节点，v-for的优先级比v-if更高，这意味着 v-if将分别重复运行于每个 v-for循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;todo in todos&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>上面的代码只传递了未完成的 todos。</p><p>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <code>&lt;template&gt;</code> )上。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-<span class="keyword">if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span><br><span class="line">        &#123;&#123; todo &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p v-<span class="keyword">else</span>&gt;No todos left!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="12、vue中子组件调用父组件的方法"><a href="#12、vue中子组件调用父组件的方法" class="headerlink" title="12、vue中子组件调用父组件的方法"></a>12、vue中子组件调用父组件的方法</h4><h5 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h5><p>直接在子组件中通过this.$parent.event来调用父组件的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;    </span><br><span class="line">&lt;div&gt;        </span><br><span class="line">    &lt;child&gt;&lt;/child&gt;    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        components: &#123;        </span><br><span class="line">            child            </span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;        </span><br><span class="line">            <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;测试&#x27;</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;&lt;/</span>template&gt;&lt;script&gt;<span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$parent.fatherMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h5><p>在子组件里用 $emit 向父组件触发一个事件，父组件监听这个事件就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;    </span><br><span class="line">&lt;div&gt;        </span><br><span class="line">    &lt;child @fatherMethod=<span class="string">&quot;fatherMethod&quot;</span>&gt;&lt;/child&gt;    </span><br><span class="line">    &lt;<span class="regexp">/div&gt;&lt;/</span>template&gt;&lt;script&gt;<span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        components: &#123;        </span><br><span class="line">            child            </span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;        </span><br><span class="line">            <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;测试&#x27;</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;fatherMethod&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h5><p>父组件把方法传入子组件中，在子组件里直接调用这个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;    </span><br><span class="line">&lt;div&gt;        </span><br><span class="line">    &lt;child :fatherMethod=<span class="string">&quot;fatherMethod&quot;</span>&gt;&lt;/child&gt;    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        components: &#123;        </span><br><span class="line">            child            </span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;        </span><br><span class="line">            <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> &#123;           </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;测试&#x27;</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;&lt;/</span>template&gt;&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        props: &#123;</span><br><span class="line">            fatherMethod: &#123;</span><br><span class="line">                type: <span class="built_in">Function</span>,</span><br><span class="line">                <span class="keyword">default</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.fatherMethod)&#123;                </span><br><span class="line">                    <span class="built_in">this</span>.fatherMethod();            </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="13、vue中-keep-alive-组件的作用"><a href="#13、vue中-keep-alive-组件的作用" class="headerlink" title="13、vue中 keep-alive 组件的作用"></a>13、vue中 keep-alive 组件的作用</h4><p><strong>作用</strong>：用于保留组件状态或避免重新渲染（缓存的作用）<br><strong>例子</strong>：当一个目录页面与一个详情页面，用户<strong>经常</strong>：打开目录页面**=&gt;<strong>进入详情页面</strong>=&gt;<strong>返回目录页面</strong>=&gt;**打开详情页面，这样目录页面就是一个使用频率很高的页面，那么就可以对目录组件使用 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt; </code>进行缓存，这样用户每次返回目录时，都能从缓存中快速渲染，而不用重新渲染。</p><h4 id="14、vue中如何编写可复用的组件？"><a href="#14、vue中如何编写可复用的组件？" class="headerlink" title="14、vue中如何编写可复用的组件？"></a>14、vue中如何编写可复用的组件？</h4><p><strong>组件定义</strong>：是一个具有一定功能，且不同组件间功能相对独立的模块。高内聚、低耦合。</p><p>开发可复用性的组件应遵循以下<strong>原则</strong>：</p><p>1）规范化命名：组件的命名应该跟业务无关，而是依据组件的功能命名。<br>2）数据扁平化：定义组件接口时，尽量不要将整个对象作为一个 prop 传进来。每个 prop 应该是一个简单类型的数据。这样做有下列几点好处：<br>    (1) 组件接口清晰。<br>    (2) props 校验方便。<br>    (3) 当服务端返回的对象中的 key 名称与组件接口不一样时，不需要重新构造一个对象。扁平化的          props 能让我们更直观地理解组件的接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 反例 --&gt;</span><br><span class="line">&lt;card :item=<span class="string">&quot;&#123; title: item.name, description: item.desc, poster: item.img &#125;&gt;</span></span><br><span class="line"><span class="string">&lt;/card&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正例 --&gt;</span><br><span class="line">&lt;card:title=<span class="string">&quot;item.name&quot;</span>:description=<span class="string">&quot;item.desc&quot;</span>:poster=<span class="string">&quot;item.img&quot;</span>&gt;</span><br><span class="line">&lt;/card&gt;</span><br></pre></td></tr></table></figure><p>3）可复用组件只实现 UI 相关的功能，即展示、交互、动画，如何获取数据跟它无关，因此不要在组件<br>内部去获取数据。<br>4）可复用组件应尽量减少对外部条件的依赖，所有与 vuex 相关的操作都不应在可复用组件中出现。<br>5）组件在功能独立的前提下应该尽量简单，越简单的组件可复用性越强。<br>6）组件应具有一定的容错性。<br>7）组件应当避免对其父组件的依赖，不要通过 this.parent 来操作父组件的示例。父组件也不要通过<br>this.children 来引用子组件的示例，而是通过子组件的接口与之交互。<br>8）可复用组件除了定义一个清晰的公开接口外，还需要有命名空间。命名空间可以避免与浏览器保留标签和其他组件的冲突。特别是当项目引用外部 UI 组件或组件迁移到其他项目时，命名空间可以避免很多命名冲突的问题。</p><h4 id="15、什么是vue生命周期？"><a href="#15、什么是vue生命周期？" class="headerlink" title="15、什么是vue生命周期？"></a>15、什么是vue生命周期？</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行<br>的，在生命周期的不同阶段调用对应的钩子函数实现组件数据管理和DOM渲染两大重要功能。</p><p><img src="/images/VueBasis-Core/11370083-f279314aef6741db.jpg" alt="img"></p><h5 id="八个阶段"><a href="#八个阶段" class="headerlink" title="八个阶段:"></a>八个阶段:</h5><blockquote><p>1）创建前(beforeCreate)<br>对应的钩子函数为beforeCreate。此阶段为实例初始化之后，此时的数据观察和事件机制都未形<br>成，不能获得DOM节点。</p><p>2）创建后（created）<br>对应的钩子函数为created。在这个阶段vue实例已经创建，仍然不能获取DOM元素。</p><p>3，载入前（beforeMount）<br>对应的钩子函数是beforeMount，在这一阶段，我们虽然依然得不到具体的DOM元素，但vue挂<br>载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行；beforeMount这个阶<br>段是过渡性的，一般一个项目只能用到一两次。</p><p>4，载入后（mounted）<br>对应的钩子函数是mounted。mounted是平时我们使用最多的函数了，一般我们的异步请求都写<br>在这里。在这个阶段，数据和DOM都已被渲染出来。</p><p>5，更新前（beforeUpdate）<br>对应的钩子函数是beforeUpdate。在这一阶段，vue遵循数据驱动DOM的原则。beforeUpdate<br>函数在数据更新后虽然没立即更新数据，但是DOM中的数据会改变，这是Vue双向数据绑定的作用。</p><p>6，更新后（updated）<br>对应的钩子函数是updated。在这一阶段DOM会和更改过的内容同步。</p><p>7，销毁前（beforeDestroy）<br>对应的钩子函数是beforeDestroy。在上一阶段Vue已经成功的通过数据驱动DOM更新，当我们不<br>再需要vue操纵DOM时，就要销毁Vue,也就是清除vue实例与DOM的关联，调用destroy方法可以<br>销毁当前组件。在销毁前，会触发beforeDestroy钩子函数。</p><p>8，销毁后(destroyed)对应的钩子函数是destroyed。<br>在销毁后，会触发destroyed钩子函数。<br>vue生命周期的思想贯穿在组件开发的始终,通过熟悉其生命周期调用不同的钩子函数，我们可<br>以准确的控制数据流和其对DOM的影响；vue生命周期的思想是Vnode和MVVM的生动体现和继承。</p></blockquote><h4 id="16、vue生命周期钩子函数有哪些？"><a href="#16、vue生命周期钩子函数有哪些？" class="headerlink" title="16、vue生命周期钩子函数有哪些？"></a>16、vue生命周期钩子函数有哪些？</h4><p> 1）vue生命周期是vue实例化或者组件创建到消亡的过程。<br> 2）beforeCreate 创建前的状态，初始化事件和生命周期。<br> 3）创建完毕状态Init (初始化) injections (依赖注入) &amp; reactivity (开始响应)。<br> 4）beforeMount 挂载前状态， 是否有元素el，是否有模板，是否渲染到了函数内，是否作为模板进行了outerHTML渲染到了页 面，向虚拟DOM上挂载的过程，并且还是把我们的‘#app’生成虚拟DOM，生成完毕后并渲染到view层。<br> 5）mounted 挂载结束状态，渲染到真正的DOM。<br> 6）beforeUpdate可以拿到Vue实例化改变前的状态。<br> 7）Updated拿到变动完成的状态。<br> 8）beforeDestroy消亡前的状态。<br> 9）destroyed实例化或组件被摧毁消亡。</p><h4 id="17、vue如何监听键盘事件中的按键？"><a href="#17、vue如何监听键盘事件中的按键？" class="headerlink" title="17、vue如何监听键盘事件中的按键？"></a>17、vue如何监听键盘事件中的按键？</h4><p>在Vue中，已经为常用的按键设置了别名，这样我们就无需再去匹配 keyCode ，<strong>直接使用别名</strong>就能监听按键的事件。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;function&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应表如下：</p><table><thead><tr><th>别名</th><th>实际键值</th></tr></thead><tbody><tr><td>.delete</td><td>delete（删除）/BackSpace（退格）</td></tr><tr><td>.tab</td><td>Tab</td></tr><tr><td>.enter</td><td>Enter（回车）</td></tr><tr><td>esc</td><td>Esc（退出）</td></tr><tr><td>.space</td><td>Space（空格键）</td></tr><tr><td>.left</td><td>Left（左箭头）</td></tr><tr><td>.up</td><td>Up（上箭头）</td></tr><tr><td>.right</td><td>Right（右箭头）</td></tr><tr><td>.down</td><td>Down（下箭头）</td></tr><tr><td>.ctrl</td><td>Ctrl</td></tr><tr><td>.alt</td><td>Alt</td></tr><tr><td>.shift</td><td>Shift</td></tr><tr><td>.meta</td><td>(window系统下是window键，mac下是command键)</td></tr></tbody></table><p>另外，Vue中还支持<strong>组合写法</strong>：</p><table><thead><tr><th>组合写法</th><th>按键组合</th></tr></thead><tbody><tr><td>@keyup.alt.67=”function”</td><td>Alt + C</td></tr><tr><td>@click.ctrl=”function”</td><td>Ctrl + Click</td></tr></tbody></table><p>但是，如果是在自己封装的组件或者是使用一些<strong>第三方的UI库</strong>时，会发现并不起效果，这时就需要用到 .native 修饰符了，如：(使用Element-UI)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">&quot;inputName&quot;</span><span class="attr">placeholder</span>=<span class="string">&quot;搜索你的文件&quot;</span>@<span class="attr">keyup.enter.native</span>=<span class="string">&quot;searchFile(params)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果遇到 .native 修饰符也无效的情况，可能就需要用到 $listeners 了.</p></blockquote><ul><li><h4 id="18、vue更新数组时触发视图更新的方法"><a href="#18、vue更新数组时触发视图更新的方法" class="headerlink" title="18、vue更新数组时触发视图更新的方法"></a>18、vue更新数组时触发视图更新的方法</h4><h5 id="1）Vue-set-响应式新增与修改数据"><a href="#1）Vue-set-响应式新增与修改数据" class="headerlink" title="1）Vue.set 响应式新增与修改数据"></a>1）<strong>Vue.set</strong> 响应式新增与修改数据</h5><p>可以设置对象或数组的值，通过key或数组索引，可以触发视图更新</p><p>​    Vue.set(target,key,value)</p><ul><li><p>参数：</p><ul><li><p>｛object | Array｝ target</p></li><li><p>{ string | number} key</p></li><li><p>｛any｝ value</p></li></ul></li><li><p>返回值：设置的值</p></li><li><p>用法：设置对象的属性，如果对象是响应式的，确保属性被创建后也是响应式的，同时出发视图更新。这个方法主要用于避开Vue不能检测属性被添加的限制。</p><blockquote><p>对象不能是Vue实例，或者Vue实例的根数据对象。</p></blockquote><p>target：要更改的<strong>数据源</strong>(可以是对象或者数组)<br> key：要更改的<strong>具体数据</strong><br> value ：<strong>重新赋的值</strong></p></li></ul><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组修改</span></span><br><span class="line">Vue.set(array, indexOfItem, newValue)<span class="built_in">this</span>.array.$set(indexOfItem, newValue)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象修改</span></span><br><span class="line">Vue.set(obj, keyOfItem, newValue)<span class="built_in">this</span>.obj.$set(keyOfItem, newValue)</span><br></pre></td></tr></table></figure><h5 id="2）Vue-delete（target，key）"><a href="#2）Vue-delete（target，key）" class="headerlink" title="2）Vue.delete（target，key）"></a>2）Vue.delete（target，key）</h5><ul><li><p>删除对象或数组中元素，通过key或数组索引，可以触发视图更新</p></li><li><p><strong>用法：</strong>删除对象的属性。如果对象是响应式的，确保删除能出发更新视图。这个方法主要用于避开Vue不能检测到属性被删除的限制。（至少会用）</p><blockquote><p>对象不能是Vue实例，或者Vue实例的根数据对象。</p></blockquote></li></ul><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组修改</span></span><br><span class="line">Vue.delete(array, indexOfItem)<span class="built_in">this</span>.array.$delete(indexOfItem)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象修改</span></span><br><span class="line">Vue.delete(obj, keyOfItem)<span class="built_in">this</span>.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure><h5 id="3）数组对象直接修改属性，可以触发视图更新"><a href="#3）数组对象直接修改属性，可以触发视图更新" class="headerlink" title="3）数组对象直接修改属性，可以触发视图更新"></a>3）数组对象直接修改属性，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.array[<span class="number">0</span>].show = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    item.show = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4）splice方法修改数组，可以触发视图更新"><a href="#4）splice方法修改数组，可以触发视图更新" class="headerlink" title="4）splice方法修改数组，可以触发视图更新"></a>4）splice方法修改数组，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.array.splice(indexOfItem, <span class="number">1</span>, newElement)</span><br></pre></td></tr></table></figure><h5 id="5）数组整体修改，可以触发视图更新"><a href="#5）数组整体修改，可以触发视图更新" class="headerlink" title="5）数组整体修改，可以触发视图更新"></a>5）数组整体修改，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempArray = <span class="built_in">this</span>.array;</span><br><span class="line">tempArray[<span class="number">0</span>].show = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.array = tempArray;</span><br></pre></td></tr></table></figure><h5 id="6）用Object-assign或lodash-assign可以为对象添加响应式属性，可以触发视图更新"><a href="#6）用Object-assign或lodash-assign可以为对象添加响应式属性，可以触发视图更新" class="headerlink" title="6）用Object.assign或lodash.assign可以为对象添加响应式属性，可以触发视图更新"></a>6）用Object.assign或lodash.assign可以为对象添加响应式属性，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object.assign的单层的覆盖前面的属性，不会递归的合并属性</span></span><br><span class="line"><span class="built_in">this</span>.obj = <span class="built_in">Object</span>.assign(&#123;&#125;,<span class="built_in">this</span>.obj,&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">//assign与Object.assign一样</span></span><br><span class="line"><span class="built_in">this</span>.obj = _.assign(&#123;&#125;,<span class="built_in">this</span>.obj,&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">//merge会递归的合并属性</span></span><br><span class="line"><span class="built_in">this</span>.obj = _.merge(&#123;&#125;,<span class="built_in">this</span>.obj,&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="7）-Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新"><a href="#7）-Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新" class="headerlink" title="7） Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新"></a>7） Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新</h5><blockquote><ul><li>push() =&gt;向数组的末尾添加一个或多个元素，并返回新的长度。</li><li>pop() =&gt;删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。</li><li>shift() =&gt;把数组的第一个元素从其中删除，并返回第一个元素的值。</li><li>unshift() =&gt;向数组的开头添加一个或更多元素，并返回新的长度。</li><li>splice() =&gt;向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组。</li><li>sort() =&gt;对数组的元素进行排序。</li><li>reverse() =&gt;颠倒数组中元素的顺序。</li></ul></blockquote><p>不变异的方法:</p><blockquote><ul><li>filter()</li><li>concat()</li><li>slice()<br>他们返回的是一个新数组，使用这些方法时，<strong>可以用新数组来替换原始数组</strong></li></ul></blockquote><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><ul><li><p>Vue 在检测到<strong>数组变化时</strong>，并不是直接重新渲染整个列表，而是<strong>最大化复用DOM元素</strong>。替换的数组中，含有<strong>相同元素的项不会被重新渲染</strong>，因此可以大胆的用新数组来替换旧数组，不用担心性能问题。</p></li><li><p>值得注意的是：<br>以下变动的数组中Vue是不能检测到的，也<strong>不会触发视图更新</strong>。<br> 1.通过索引直接设置项， 比如this.books[3]={…}<br> 2.修改数组长度， 比如 this.books.length = 1;</p><blockquote><p>两个问题都可以用splice来解决：<br>第一个问题 还可以用 set方法 this.$set(this.books,3,{…})</p></blockquote></li></ul><h4 id="19、vue中对象更改检测的注意事项"><a href="#19、vue中对象更改检测的注意事项" class="headerlink" title="19、vue中对象更改检测的注意事项"></a>19、vue中对象更改检测的注意事项</h4><p>还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">    &#125;&#125;)</span><br><span class="line"><span class="comment">// `qs.a` 现在是响应式的qs.b = 2</span></span><br><span class="line"><span class="comment">// `qs.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object,<br>propertyName, value) 方法向嵌套对象添加响应式属性。例如，对于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        userProfile: &#123;</span><br><span class="line">            name: <span class="string">&#x27;Jungle&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以添加一个新的 age 属性到嵌套的 userProfile 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(qs.userProfile, <span class="string">&#x27;age&#x27;</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qs.$set(qs.userProfile, <span class="string">&#x27;age&#x27;</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>有时你可能需要<strong>为已有对象赋值多个新属性</strong>，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新，在这种情况下，你应该用两个对象（原对象和要混合进去的对象）的属性创建一个新的对象。所以，如果你想添加新的响应式属性，这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qs.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, qs.userProfile, &#123;</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    favoriteFood: <span class="string">&#x27;Vue huimian&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p><p><strong>Object.assign()</strong> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><p>const target = { a: 1, b: 2 };<br>const source = { b: 4, c: 5 };</p><p>const returnedTarget = Object.assign(target, source);</p><p>console.log(target);<br>// expected output: Object { a: 1, b: 4, c: 5 }</p><p>console.log(returnedTarget);<br>// expected output: Object { a: 1, b: 4, c: 5 }</p></blockquote><h4 id="20、解决非工程化项目初始化页面闪动问题"><a href="#20、解决非工程化项目初始化页面闪动问题" class="headerlink" title="20、解决非工程化项目初始化页面闪动问题"></a>20、解决非工程化项目初始化页面闪动问题</h4><p>vue页面在加载的时候闪烁花括号{}，v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache(前端模板引擎)标签直到实例准备完毕。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--html代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in tabs&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;data.text&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="21、v-for产生的列表，实现active的切换"><a href="#21、v-for产生的列表，实现active的切换" class="headerlink" title="21、v-for产生的列表，实现active的切换"></a>21、v-for产生的列表，实现active的切换</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(desc,tableIndex) in descriptions.firstface&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;controller-checkboxs clearfix&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;currentIndex=index,currentTable=tableIndex&quot;</span>    <span class="attr">class</span>=<span class="string">&quot;controller-checkbox-item&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:class</span>=<span class="string">&quot;&#123;active:index===currentIndex&amp;&amp;tableIndex==currentTable&#125;&quot;</span><span class="attr">v-for</span>=<span class="string">&quot;(ctrlValue,index) in desc.args&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="22、v-model语法糖的组件中的使用"><a href="#22、v-model语法糖的组件中的使用" class="headerlink" title="22、v-model语法糖的组件中的使用"></a>22、v-model语法糖的组件中的使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">此时msg值就与input的值进行双向绑定，实际上上面的代码是下面代码的语法糖。</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;msg= $event.target.value&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>要理解这行代码，首先你要知道 input 元素本身有个 oninput 事件，这是 HTML5 新增加的，类似<br>onchange ，每当输入框内容发生变化，就会触发 oninput ，把最新的value传递给 msg。从而实现了vmodel。</p><h4 id="23、Vue中自定义过滤器"><a href="#23、Vue中自定义过滤器" class="headerlink" title="23、Vue中自定义过滤器"></a>23、Vue中自定义过滤器</h4><p>过滤器是一个通过输入数据，能够及时对数据进行处理并返回一个数据结果的简单函数。Vue有很多很<br>便利的过滤器，过滤器通常会使用管道标志 “ | ”。使用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.ctime | dataFormat(&#x27;yyyy-mm-dd&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>自定义全局过滤器</strong><br>虽然VueJs给我们提供了很多强有力的过滤器，但有时候还是不够。值得庆幸的，Vue给我们提供了一个干净简洁的方式来定义我们自己的过滤器，之后我们就可以利用管道 “ | ” 来完成过滤。</p><p>定义一个全局的自定义过滤器，需要使用 Vue.filter() 构造器。这个构造器需要两个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局过滤器</span></span><br><span class="line">Vue.filter(<span class="string">&#x27;dataFormat&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">input, pattern = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line"><span class="comment">// 获取年月日</span></span><br><span class="line"><span class="keyword">var</span> y = dt.getFullYear();</span><br><span class="line"><span class="keyword">var</span> m = (dt.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d = dt.getDate().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="comment">// 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span></span><br><span class="line"><span class="comment">// 否则，就返回 年-月-日 时：分：秒</span></span><br><span class="line"><span class="keyword">if</span> (pattern.toLowerCase() === <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取时分秒</span></span><br><span class="line"><span class="keyword">var</span> hh = dt.getHours().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mm = dt.getMinutes().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ss = dt.getSeconds().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>拓展</p><p><strong><code>padStart()</code></strong> 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>);          <span class="comment">//&quot;       abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&quot;foo&quot;</span>);  <span class="comment">// &quot;foofoofabc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">6</span>,<span class="string">&quot;123465&quot;</span>); <span class="comment">// &quot;123abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">8</span>, <span class="string">&quot;0&quot;</span>);     <span class="comment">// &quot;00000abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">1</span>);          <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p><strong>返回值：</strong>在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。</p></blockquote><h4 id="24、vue等单页面应用及其优缺点"><a href="#24、vue等单页面应用及其优缺点" class="headerlink" title="24、vue等单页面应用及其优缺点"></a>24、vue等单页面应用及其优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p> 1）用户体验好，快，内容的改变不需要重新加载整个页面，对服务器压力较小。<br> 2）前后端分离，比如vue项目<br> 3）完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方<br>式更加规范化，便于修改 和调整；</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1）首次加载页面的时候需要加载大量的静态资源，这个加载时间相对比较长。<br> 2）不利于 SEO优化，单页页面，数据在前端渲染，就意味着没有 SEO。<br> 3）页面导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进<br>后退功能，所以需要自 己建立堆栈管理）</p><h4 id="25、什么是vue的计算属性？"><a href="#25、什么是vue的计算属性？" class="headerlink" title="25、什么是vue的计算属性？"></a>25、什么是vue的计算属性？</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板<br>过重且难以维护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;翻转字符串</span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这里的表达式包含3个操作，并不是很清晰，所以遇到复杂逻辑时应该使用Vue特带的计算属性<br>computed 来进行处理。</p><h4 id="26、vue-cli提供的几种脚手架模板"><a href="#26、vue-cli提供的几种脚手架模板" class="headerlink" title="26、vue-cli提供的几种脚手架模板"></a>26、vue-cli提供的几种脚手架模板</h4><p>vue-cli 的脚手架项目模板有browserify 和 webpack , 官网给出了两个模板： webpack-simple 和<br>webpack 两种。两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用<br>webpack-simple 就足够了.<br><strong>搭建官方项目模板步骤：</strong></p><ul><li><p>1、npm install vue-cli (安装vue-cli ) 有的时候有看到其它两种写法: –save-dev 和 –save的写法。这两个有一定的区别，我们都知道package.json 中有一个 “dependencies” 和 “devDependencies” 的。<br>dependencies 是用在开发完上线模式的，就是有些东西你上线以后还需要依赖的，比如juqery , 我们这里的vue 和 babel-runtime（Babel 转码器 可以将ES6 转为ES5 ）， 而devDependencies 则是在开发模式执行的，比如我们如果需要安装一个node-sass 等等。</p><blockquote><ul><li>有的时候看到package.json中安装的模块版本号前面有一个波浪线。</li></ul><p>例如: ~1.2.3 这里表示安装1.2.x以上版本。但是不安装1.3以上。</p><ul><li>插入符号^ 更宽松。 它匹配的是最新次要版本号，也就是第二个数字。</li></ul><p>比如：^ 1.2.3将匹配任何1.x.x版本，包括1.3.0，但将在2.0.0上停止。</p></blockquote></li><li><p>2、vue init webpack-simple yourdemoname 下载一个webpack-simple项目，这里的webpacksimple 是固定的，也就是官网的项目模板。youdemoname 这个是你自己项目的名字。 执行这个步骤<br>以后。就会弹出询问 “项目名称..项目描述“等等问题 直接按照提示操作。这个时候对应的项目目录下就<br>出现刚刚建立的项目了。</p></li><li><p>3、我们还需要把项目的依赖下载下来。使用命令: cd youdemoname 然后执行npm install 就可以了，<br>这个时候你的项目中有多了一个node_modules 目录</p></li><li><p>4、使用”npm - run - dev” 命令来运行项目 “npm-run-bulid” 来执行发布，会自动生成dist文件</p></li></ul><h4 id="27、vue父组件如何向子组件中传递数据？"><a href="#27、vue父组件如何向子组件中传递数据？" class="headerlink" title="27、vue父组件如何向子组件中传递数据？"></a>27、vue父组件如何向子组件中传递数据？</h4><ul><li><p>子组件在props中创建一个属性，用以接收父组件传过来的值(也可以是对象)</p></li><li><p>父组件中注册子组件，并在<code>&lt;template&gt;</code>中添加child标签，标签中添加message属性并赋值</p></li><li><p>在子组件标签中添加子组件props中创建的属性</p></li><li><p>把需要传给子组件的值赋给该属性</p></li></ul><h4 id="28、计算属性的缓存和方法调用的区别"><a href="#28、计算属性的缓存和方法调用的区别" class="headerlink" title="28、计算属性的缓存和方法调用的区别"></a>28、计算属性的缓存和方法调用的区别</h4><ul><li><p>计算属性必须返回结果</p></li><li><p>计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值。</p></li><li><p>使用计算属性还是methods取决于是否需要<strong>缓存</strong>，当遍历大数组和做大量计算时，应当使用计算属<br>性，除非你不希望得到缓存。</p></li><li><p>计算属性是根据依赖自动执行的，methods需要事件调用</p></li></ul><h4 id="29、vue-cli中自定义指令的使用"><a href="#29、vue-cli中自定义指令的使用" class="headerlink" title="29、vue-cli中自定义指令的使用"></a>29、vue-cli中自定义指令的使用</h4><ul><li>vue中除了内置的指令（v-show,v-model）还允许我们<strong>自定义指令</strong></li><li>想要创建自定义指令，就要注册指令（以输入框获取焦点为例） 注意：autofocus 在移动版 Safari 上不工作</li></ul><h5 id="一、注册全局指令："><a href="#一、注册全局指令：" class="headerlink" title="一、注册全局指令："></a>一、注册全局指令：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el,binding</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前指令绑定的dom元素</span></span><br><span class="line"><span class="comment">//console.log(el);</span></span><br><span class="line"><span class="comment">// 指令传入的参数、修饰符、值 v-指令名称:参数.修饰符=值</span></span><br><span class="line"><span class="comment">// console.log(binding)</span></span><br><span class="line"><span class="comment">// 聚焦元素</span></span><br><span class="line">el.focus()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="二、注册局部指令：-组件中也接受一个-directives-的选项"><a href="#二、注册局部指令：-组件中也接受一个-directives-的选项" class="headerlink" title="二、注册局部指令： 组件中也接受一个 directives 的选项"></a>二、注册局部指令： 组件中也接受一个 directives 的选项</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">focus: &#123;</span><br><span class="line"><span class="comment">// 指令的定义</span></span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">el.focus()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用也很简单：直接在元素上面使用v-focus即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="三、举一个自定义指令的小例子：拖拽"><a href="#三、举一个自定义指令的小例子：拖拽" class="headerlink" title="三、举一个自定义指令的小例子：拖拽"></a>三、举一个自定义指令的小例子：<strong>拖拽</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;drag&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 当指令绑定到元素上的时候执行</span></span><br><span class="line"><span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;bind&#x27;);</span></span><br><span class="line"><span class="comment">// 当前指令绑定的dom元素</span></span><br><span class="line"><span class="comment">//console.log(el);</span></span><br><span class="line"><span class="comment">// 指令传入的参数、修饰符、值 v-指令名称:参数.修饰符=值</span></span><br><span class="line"><span class="comment">// console.log(binding)</span></span><br><span class="line">el.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = e||event;</span><br><span class="line"><span class="keyword">let</span> disX = e.clientX - el.offsetLeft;</span><br><span class="line"><span class="keyword">let</span> disY = e.clientY - el.offsetTop;</span><br><span class="line">                </span><br><span class="line"><span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = e||event;</span><br><span class="line"><span class="keyword">let</span> L = e.clientX - disX;</span><br><span class="line"><span class="keyword">let</span> T = e.clientY - disY;</span><br><span class="line">                    <span class="keyword">if</span> (binding.modifiers.limit) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt; <span class="number">0</span>) &#123;</span><br><span class="line">L = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">el.style.left = L + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">el.style.top = T + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用也很简单，只用在元素上添加v-drag或者v-drag.limit</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">v-drag.limit</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span> <span class="attr">v-drag</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、对于Vue是一套渐进式框架的理解&quot;&gt;&lt;a href=&quot;#1、对于Vue是一套渐进式框架的理解&quot; class=&quot;headerlink&quot; title=&quot;1、对于Vue是一套渐进式框架的理解&quot;&gt;&lt;/a&gt;1、对于Vue是一套渐进式框架的理解&lt;/h4&gt;&lt;p&gt;渐进式代表的</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue自定义指令</title>
    <link href="http://example.com/2021/04/29/Vue-directive/"/>
    <id>http://example.com/2021/04/29/Vue-directive/</id>
    <published>2021-04-29T04:10:54.000Z</published>
    <updated>2021-05-07T07:52:47.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>全局api</li><li>Vue.directive指令</li><li>自定义指令的生命周期</li></ul><h3 id="全局api概述"><a href="#全局api概述" class="headerlink" title="全局api概述"></a>全局api概述</h3><ul><li>全局api并不在构造器里面，而是先声明全局变量或者直接在vue中定义一些新功能，VUE内置了一些全局api,说简单点就是在构造器外面用vue提供给我们的api函数来定义新的功能.</li></ul><h3 id="Vue-directive-指令"><a href="#Vue-directive-指令" class="headerlink" title="Vue.directive 指令"></a>Vue.directive 指令</h3><ul><li><p>学习了内部指令，但是我们想要定义一个v-hello的指令，其作用就是让文字变成绿色.</p></li><li><p>在开始之前先写一个小DEMO，页面上有一个数字是10，数字的下面有一个按钮，每次点击加1</p></li><li><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0,maximum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.common.dev.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span> 点击开始加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            message: 10,</span><br><span class="line"><span class="javascript">            color: <span class="string">&quot;green&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.message++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>下面让我们用vue.directive来写一个</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0,maximum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.common.dev.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-hello</span>=<span class="string">&quot;color3&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span> 点击开始加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.directive(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        el.style[<span class="string">&quot;color&quot;</span>] = binding.value;</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            message: 10,</span><br><span class="line"><span class="javascript">            color3: <span class="string">&quot;red&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.message++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>这里要说明的就是指令写的是v-hello,但是我们用directive的时候前面不用加v-了，直接输入指令即可<br> 可以看到数字也变成绿色了，说明自定义指令也起作用了。</p></li><li><p>el : 指令所绑定的元素，可以用来直接操作DOM</p></li><li><p>binding: 一个对象，包含指令的很多信息</p></li><li><p>vnode: VUE编译生成的虚拟节点</p></li></ul><h3 id="自定义指令的生命周期"><a href="#自定义指令的生命周期" class="headerlink" title="自定义指令的生命周期"></a>自定义指令的生命周期</h3><p>自定义指令有5个生命周期(也叫作钩子函数)分别是bind ,inserted,update,componentUpdate,unbind</p><ul><li><p>要是想解绑这个vue可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unbind</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  app.$destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bind 只调用一次，指令第一次绑定到元素时候调用，用这个钩子可以定义一个绑定时执行一次的初始化动作。</p></li><li><p>inserted:被绑定的元素插入父节点的时候调用(父节点存在即可调用，不必存在document中)</p></li><li><p>update: 被绑定与元素所在模板更新时调用，而且无论绑定值是否有变化，通过比较更新前后的绑定值，忽略不必要的模板更新</p></li><li><p>componentUpdate :被绑定的元素所在模板完成一次更新更新周期的时候调用</p></li><li><p>unbind: 只调用一次，指令月元素解绑的时候调用</p></li><li><p>见下面代码</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0,maximum-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.common.dev.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-hello</span>=<span class="string">&quot;color3&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span> 点击开始加1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;jiebang()&quot;</span>&gt;</span>解绑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jiebang</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        app.$destroy();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    Vue.directive(<span class="string">&quot;hello&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, bingind, vnode</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            el.style[<span class="string">&quot;color&quot;</span>] = bingind.value;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;1-bind&quot;</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        inserted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;2-insert&quot;</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;3-update&quot;</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        componentUpdated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;4 - componentUpdated&#x27;</span>);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        unbind: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;5 - unbind&#x27;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            message: 10,</span><br><span class="line"><span class="javascript">            color3: <span class="string">&quot;red&quot;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.message++;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>演示图如下：</p><p><a href="https://imgtu.com/i/gF4EKU"><img src="/images/Vue-directive/gF4EKU.gif" alt="gF4EKU.md.gif"></a></p></li></ul><blockquote><p>个人意见：文档的话，说一千道一万，不如来个小Demo来的简洁明了</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;全局api&lt;/li&gt;
&lt;li&gt;Vue.directive指令&lt;/li&gt;
&lt;li&gt;自定义指令的生命周期&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue Cli" scheme="http://example.com/tags/Vue-Cli/"/>
    
  </entry>
  
  <entry>
    <title>Git常用上传文件方式</title>
    <link href="http://example.com/2021/04/27/Git-Used/"/>
    <id>http://example.com/2021/04/27/Git-Used/</id>
    <published>2021-04-27T07:31:47.000Z</published>
    <updated>2021-04-27T08:12:35.402Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多种上传方式"><a href="#多种上传方式" class="headerlink" title="多种上传方式"></a>多种上传方式</h3><h4 id="一、使用HTTPS方式上传本地的文件到Github："><a href="#一、使用HTTPS方式上传本地的文件到Github：" class="headerlink" title="一、使用HTTPS方式上传本地的文件到Github："></a>一、使用HTTPS方式上传本地的文件到Github：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 创建文件/文档</span></span><br><span class="line">mkdir 文件名  / touch 文档名</span><br><span class="line"><span class="comment"># 克隆远程仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/user/仓库名.git</span><br><span class="line"><span class="comment"># 添加文件到暂存区（.代表全部，或者all）</span></span><br><span class="line">git add . </span><br><span class="line"><span class="comment"># 提交文件到工作区  -m 合并</span></span><br><span class="line">git commit –m <span class="string">&#x27;对文件/提交的说明 &#x27;</span></span><br><span class="line"><span class="comment"># 把文件推送到远程仓库</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="comment"># origin -&gt; 远程仓库的名字，</span></span><br><span class="line"><span class="comment"># origin/master -&gt; 远程仓库的master分支。</span></span><br><span class="line"><span class="comment"># git push origin master  就是将本地的master分支</span></span><br><span class="line"><span class="comment"># -&gt;push到远程仓库的与之有追踪关系的分支（通常名字相同）</span></span><br><span class="line"><span class="comment"># -u 用户进程的最大数量</span></span><br></pre></td></tr></table></figure><h4 id="二、使用SSH方式上传本地的文件到Github："><a href="#二、使用SSH方式上传本地的文件到Github：" class="headerlink" title="二、使用SSH方式上传本地的文件到Github："></a>二、使用SSH方式上传本地的文件到Github：</h4><p><strong>（1）查看/配置密钥</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否已经存在本地公钥</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># 没有--&gt; 执行生成本地公钥</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;XXXXX@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 这个指令会要求你提供一个 位置和文件名 去存放键值对和密码，可以一直点击 Enter键去     使用默认值。</span></span><br><span class="line"><span class="comment"># 提示1：最好的情况是一个密码对应一个ssh key，但也不是非得这样去做，就像上面我们跳过   创建密码这个步骤。</span></span><br><span class="line"><span class="comment"># 提示2：设置的密码不能被修改，也不可以被获取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时你按照上述路径 C:/Users/Admin/.ssh，找到该文件夹</span></span><br><span class="line"><span class="comment"># 使用记事本打开 id_rsa.pub 文件，直接选中所有内容复制即可。</span></span><br><span class="line"><span class="comment"># 也可以根据操作系统的不同，选择不同的指令。</span></span><br><span class="line"><span class="comment"># windows clip &lt; ~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="comment"># mac pbcopy &lt; ~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="comment"># 执行命令后，此时公钥已经复制到了粘贴板上。</span></span><br></pre></td></tr></table></figure><p><strong>(2)上传到Github仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 创建文件/文档</span></span><br><span class="line">mkdir 文件名  / touch 文档名</span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">git remote add origin git@github.com:defnngj/hello-world.git  </span><br><span class="line"><span class="comment"># 添加文件到暂存区</span></span><br><span class="line">git add 文件</span><br><span class="line"><span class="comment"># 提交文件到工作区</span></span><br><span class="line">git commit –m <span class="string">&#x27;对文件/提交的说明&#x27;</span></span><br><span class="line"><span class="comment"># 把文件推送到远程仓库</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><strong>(3) 如果你的HTTPS方法需要每次输入密码，那么可以转成SSH传输</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改git的remote url</span></span><br><span class="line"><span class="comment"># 使用命令 git remote -v 查看你当前的 remote url</span></span><br><span class="line">git remote -v</span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。</span></span><br><span class="line">git remote set-url origin git@github.com:someaccount/someproject.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后你可以再用命令 git remote -v 查看一下，url是否已经变成了ssh地址。</span></span><br><span class="line"><span class="comment"># 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了</span></span><br></pre></td></tr></table></figure><h3 id="git上传过程中出现的错误和方法"><a href="#git上传过程中出现的错误和方法" class="headerlink" title="git上传过程中出现的错误和方法"></a>git上传过程中出现的错误和方法</h3><h4 id="1-Github是不传输大文件的-gt-nbsp-否则报错error-failedto-push-som-refs-to-…"><a href="#1-Github是不传输大文件的-gt-nbsp-否则报错error-failedto-push-som-refs-to-…" class="headerlink" title="(1)Github是不传输大文件的==&gt;&nbsp; 否则报错error:failedto push som refs to …"></a>(1)Github是不传输大文件的==&gt;&nbsp; 否则报错<code>error:failedto push som refs to …</code></h4><blockquote><p>git push 时，存在大文件会报错，即使删除大文件后，还会报错。主要是因为大文件存在没有被提交的commit记录里面。</p></blockquote><p>(2)[Git撤销&amp;回滚操作(git reset 和 get revert)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先把远程服务器github上面的文件拉下来</span></span><br><span class="line">git pullorigin master </span><br><span class="line">git pushorigin master</span><br><span class="line"><span class="comment"># 如果出现报错 fatal:Couldn&#x27;t find remote ref master</span></span><br><span class="line"><span class="comment"># 或者fatal: &#x27;origin&#x27; doesnot appear to be a git repository</span></span><br><span class="line"><span class="comment"># 以及fatal: Could notread from remote repository.</span></span><br><span class="line"><span class="comment"># 则需要重新输入</span></span><br><span class="line">git remote add origin git@github.com:defnngj/hello-world.git  </span><br></pre></td></tr></table></figure><h3 id="一张图解决Git操作"><a href="#一张图解决Git操作" class="headerlink" title="一张图解决Git操作"></a>一张图解决Git操作</h3><p><img src="/images/Git-Used/20210125190841921.png" alt="在这里插入图片描述"></p><p>如有错误，敬请及时指正~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多种上传方式&quot;&gt;&lt;a href=&quot;#多种上传方式&quot; class=&quot;headerlink&quot; title=&quot;多种上传方式&quot;&gt;&lt;/a&gt;多种上传方式&lt;/h3&gt;&lt;h4 id=&quot;一、使用HTTPS方式上传本地的文件到Github：&quot;&gt;&lt;a href=&quot;#一、使用HTTPS方式</summary>
      
    
    
    
    <category term="Git" scheme="http://example.com/categories/Git/"/>
    
    
    <category term="Git" scheme="http://example.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>把书念下去，然后走出去！</title>
    <link href="http://example.com/2021/04/24/Perception-02/"/>
    <id>http://example.com/2021/04/24/Perception-02/</id>
    <published>2021-04-24T14:10:47.000Z</published>
    <updated>2021-04-24T14:49:10.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="把书念下去，然后走出去！"><a href="#把书念下去，然后走出去！" class="headerlink" title="把书念下去，然后走出去！"></a>把书念下去，然后走出去！</h1><h2 id="寥寥数字，却是半生总结。"><a href="#寥寥数字，却是半生总结。" class="headerlink" title="寥寥数字，却是半生总结。"></a>寥寥数字，却是半生总结。</h2><p>&nbsp; &nbsp; &nbsp; “我走了很远的路，吃了很多的苦，才将这份博士学位论文送到你的面前。二十二载求学路，一路风雨泥泞，许多不容易。如梦一场，仿佛昨天一家人才团聚过。”</p><p>&nbsp; &nbsp; &nbsp; 上述文字来自于一篇博士论文的《致谢》部分（如下图所示）。这篇情感真挚的《致谢》近日在豆瓣、知乎、微博等多个网络平台走红，作者在文中回顾自己如何一路走出小山坳、和命运抗争的故事打动了大批网友。</p><p>&nbsp; &nbsp; &nbsp; 《致谢》结尾，他写道：“理想不伟大，只愿年过半百，归来仍是少年，希望还有机会重新认识这个世界，不辜负这一生吃过的苦。最后如果还能做出点让别人生活更美好的事，那这辈子就赚了。”</p><p>&nbsp; &nbsp; &nbsp; 我看过也听过太多读书路上的故事，每次都能让自己在一个“状态”里警醒。</p><p>&nbsp; &nbsp;&nbsp;  曾经面前堆砌着一摞摞的书本，老师在讲台上讲课，我手里拿着笔，眼睛里看着窗外，脑子里想着想不通的未来。``</p><blockquote><p> 现在觉得，那时看不清的前路才是最好的前进方向。</p></blockquote><br/><p>&nbsp; &nbsp; &nbsp; 我爸爸常教导我不要和别人的生活作比，其实我是又陷入了看不到路不知道怎么前进的局面中，就想看别人是怎么生活的，且反复焦虑。这样的阶段每个人都会有，很正常，我们要做的不是烦恼，而是想不通的时候就放下，<strong>把目光聚焦在当下，做自己喜欢的事情，学习新的知识，走在成长的路上</strong>。<br>&nbsp; &nbsp; &nbsp; 我的好朋友在这段时间里身心疲惫，这可能是她迈入了社会的第一个小坡儿（她在我心里一直很优秀，所以之前的乱七八糟的事情我都觉得对她不算坎儿），我俩时常鼓劲儿的加油二字，多少都带着点无奈，真想在你爬坡儿路上给你递杯水。总之，<strong>身体健康</strong>，是我对你最优先的祝福。</p><hr/><p>&nbsp; &nbsp; &nbsp; 看完这篇论文的致谢，我突然就悟了，我从来没有期待自己有多出众，我是一个普通人，<strong>普通人有自己世界里不普通的生活</strong>，我庆幸自己现在舒适的学习和生活环境，起码维护了我脆弱的自尊心，我没有勇气像黄国平博士一样抗着生活的压力求学，我之后的路怎么走，我想，就是凭借“信念”，在有限的时间里，描绘自己的人生吧！</p><p><img src="/images/Perception-02/a.jpg" alt="a"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;把书念下去，然后走出去！&quot;&gt;&lt;a href=&quot;#把书念下去，然后走出去！&quot; class=&quot;headerlink&quot; title=&quot;把书念下去，然后走出去！&quot;&gt;&lt;/a&gt;把书念下去，然后走出去！&lt;/h1&gt;&lt;h2 id=&quot;寥寥数字，却是半生总结。&quot;&gt;&lt;a href=&quot;#寥</summary>
      
    
    
    
    <category term="随笔感悟" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="Perception" scheme="http://example.com/tags/Perception/"/>
    
  </entry>
  
  <entry>
    <title>输入URL到页面加载过程</title>
    <link href="http://example.com/2021/04/17/URL-To-Page/"/>
    <id>http://example.com/2021/04/17/URL-To-Page/</id>
    <published>2021-04-17T10:58:22.000Z</published>
    <updated>2021-04-17T11:42:07.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从输入-URL-到页面加载完成，发生了什么？"><a href="#从输入-URL-到页面加载完成，发生了什么？" class="headerlink" title="从输入 URL 到页面加载完成，发生了什么？"></a>从输入 URL 到页面加载完成，发生了什么？</h2><p>这是一个简单的经典的过程：</p><ul><li><p>1️⃣首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，</p></li><li><p>2️⃣然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，</p></li><li><p>3️⃣随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，</p></li><li><p>4️⃣把目标数据放在 HTTP 响应里返回给客户端，</p></li><li><p>5️⃣拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作</p><p>（如下图所示）</p></li></ul><p><img src="/images/URL-To-Page/1.png" alt="img"></p><h3 id="我们将这个过程切分为如下的过程片段："><a href="#我们将这个过程切分为如下的过程片段：" class="headerlink" title="我们将这个过程切分为如下的过程片段："></a>我们将这个过程切分为如下的过程片段：</h3><h4 id="一、基础版"><a href="#一、基础版" class="headerlink" title="一、基础版"></a>一、基础版</h4><ol><li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li><li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li><li>载入解析到的资源文件，渲染页面，完成。</li></ol><h3 id="二、详细版"><a href="#二、详细版" class="headerlink" title="二、详细版"></a>二、详细版</h3><ol><li><p>在浏览器地址栏<strong>输入URL</strong></p></li><li><p>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且<strong>新鲜</strong>，跳转到转码步骤</p><ol><li><p>如果资源未缓存，发起新请求</p></li><li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p></li><li><p>检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：</p><ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p></li><li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p></li><li><p>浏览器<strong>获取主机ip地址</strong>，过程如下：</p><ol><li><p>浏览器缓存</p></li><li><p>本机缓存</p></li><li><p>hosts文件</p></li><li><p>路由器缓存</p></li><li><p>ISP DNS缓存</p></li><li><p>DNS递归查询（可能存在负载均衡导致每次IP不一样）</p></li></ol></li><li><p><strong>打开一个socket与目标IP地址，端口建立TCP链接</strong>，三次握手如下：</p><ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li><p>TCP链接建立后<strong>发送HTTP请求</strong></p></li><li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p></li><li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p></li><li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p></li><li><p>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong>：</p><ol><li><p>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</p></li><li><p>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</p></li><li><p>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</p></li><li><p>主动方发送<strong>ACK=Y， Seq=X</strong>报文</p></li></ol></li><li><p>浏览器检查响应<strong>状态码</strong>：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p></li><li><p>如果资源可缓存，<strong>进行缓存</strong></p></li><li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p></li><li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p></li><li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p></li><li><p><strong>构建DOM树：</strong></p><ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p></li><li><p><strong>构建CSSOM树：</strong></p><ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><p><strong>根据DOM树和CSSOM树构建渲染树 :</strong></p><ol><li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li><li>对每一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容和计算样式</li></ol></li><li><p><strong>js解析如下：</strong></p><ol><li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素</li><li>当文档完成解析，document.readState变成interactive</li><li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li><li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li><li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete，window触发load事件</li></ol></li><li><p><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</p></li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><blockquote><p>在展开性能优化这个话题的时候，此时这个问题就非常的重要，因为后续的性能优化内容都必须以这个问题的答案为骨架展开</p></blockquote><p>而所谓的<strong>性能优化</strong>，其实就是针对这五个过程进行分解，逐个击破，逐个优化。</p><p>我们整个的知识图谱，用思维导图展示如下：</p><p><img src="/images/URL-To-Page/2.png" alt="img"></p><h3 id="比较简洁且常用的优化方式如下："><a href="#比较简洁且常用的优化方式如下：" class="headerlink" title="比较简洁且常用的优化方式如下："></a>比较简洁且常用的优化方式如下：</h3><ul><li><code>content</code>方面<ul><li><strong>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵</strong>、<code>inline Image</code></li><li><strong>减少<code>DNS</code>查询：</strong><code>DNS</code>缓存、将资源分布到恰当数量的主机名</li><li><strong>减少<code>DOM</code>元素数量</strong></li></ul></li><li><code>Server</code>方面<ul><li><strong>使用<code>CDN</code></strong></li><li>配置<code>ETag</code></li><li><strong>对组件使用<code>Gzip</code>压缩</strong></li></ul></li><li><code>Cookie</code>方面<ul><li>减小<code>cookie</code>大小</li></ul></li><li><code>css</code>方面<ul><li><strong>将样式表放到页面顶部</strong></li><li><strong>不使用<code>CSS</code>表达式</strong></li><li><strong>使用<code>&lt;link&gt;</code>不使用<code>@import</code></strong></li></ul></li><li><code>Javascript</code>方面<ul><li><strong>将脚本放到页面底部</strong></li><li><strong>将<code>javascript</code>和<code>css</code>从外部引入</strong></li><li><strong>压缩<code>javascript</code>和<code>css</code></strong></li><li>删除不需要的脚本</li><li><strong>减少<code>DOM</code>访问</strong></li></ul></li><li>图片方面<ul><li>优化图片：根据实际颜色需要选择色深、压缩</li><li><strong>优化<code>css</code>精灵</strong></li><li>不要在<code>HTML</code>中拉伸图片</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从输入-URL-到页面加载完成，发生了什么？&quot;&gt;&lt;a href=&quot;#从输入-URL-到页面加载完成，发生了什么？&quot; class=&quot;headerlink&quot; title=&quot;从输入 URL 到页面加载完成，发生了什么？&quot;&gt;&lt;/a&gt;从输入 URL 到页面加载完成，发生了什</summary>
      
    
    
    
    <category term="FE-Interview" scheme="http://example.com/categories/FE-Interview/"/>
    
    
    <category term="URL" scheme="http://example.com/tags/URL/"/>
    
  </entry>
  
  <entry>
    <title>宏任务&amp;微任务</title>
    <link href="http://example.com/2021/04/12/FE-Interview01/"/>
    <id>http://example.com/2021/04/12/FE-Interview01/</id>
    <published>2021-04-12T08:12:09.000Z</published>
    <updated>2021-04-12T08:31:01.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是宏任务"><a href="#什么是宏任务" class="headerlink" title="什么是宏任务"></a>什么是宏任务</h3><ul><li>我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li><li>每一个宏任务会从头到尾执行完毕，不会执行其他。</li></ul><blockquote><p>我们知道 JS引擎线程和 GUI渲染线程是互斥的关系，浏览器为了能够使 宏任务和 DOM任务有序的进行，会在一个 宏任务执行结果后，在下一个 宏任务执行前， GUI渲染线程开始工作，对页面进行渲染。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏任务--&gt;渲染--&gt;宏任务--&gt;宏任务--&gt;渲染．．</span></span><br></pre></td></tr></table></figure><blockquote><p>主代码块，<code>setTimeout</code>，<code>setInterval</code>等，都属于宏任务</p></blockquote><p><strong>第一个例子：</strong></p><p>我们可以将这段代码放到浏览器的控制台执行以下，看一下效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">&#x27;background:black&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">&#x27;background:red&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">&#x27;background:blue&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">&#x27;background:grey&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/FE-Interview01/5.gif" alt="img"></p><blockquote><p>我们会看到的结果是，页面背景会在瞬间变成白色，以上代码属于同一次 宏任务，所以全部执行完才触发 页面渲染，渲染时 GUI线程会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色</p></blockquote><p><strong>第二个例子：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">&#x27;background:blue&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">document</span>.body.style = <span class="string">&#x27;background:black&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/FE-Interview01/7.gif" alt="img"></p><blockquote><p>我会看到，页面先显示成蓝色背景，然后瞬间变成了黑色背景，这是因为以上代码属于两次 宏任务，第一次 宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色</p></blockquote><h3 id="什么是微任务"><a href="#什么是微任务" class="headerlink" title="什么是微任务"></a>什么是微任务</h3><ul><li>我们已经知道 宏任务结束后，会执行渲染，然后执行下一个 宏任务，</li><li>而微任务可以理解成在当前 宏任务执行后立即执行的任务。</li><li>也就是说，<strong>当 宏任务执行完，会在渲染前，将执行期间所产生的所有 微任务都执行完</strong>。</li></ul><blockquote><p><code>Promise</code>，<code>process.nextTick</code>等，属于 微任务。</p></blockquote><p><strong>第一个例子：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">&#x27;background:blue&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">document</span>.body.style = <span class="string">&#x27;background:black&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>执行后看效果：</p><p><img src="/images/FE-Interview01/9.gif" alt="img"></p><ul><li>控制台输出 1 3 2 , 是因为 promise 对象的 then 方法的回调函数是异步执行，所以 2 最后输出</li><li>页面的背景色直接变成黑色，没有经过蓝色的阶段，是因为，我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务，在微任务中将背景变成了黑色，然后才执行的渲染</li></ul><p><strong>第二个例子：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//1 3 2</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="/images/FE-Interview01/image-20210412162949126.png" alt="image-20210412162949126"></p><blockquote><p>上面代码共包含两个 <code>setTimeout</code> ，也就是说除主代码块外，共有两个 宏任务， 其中第一个 宏任务执行中，输出 1 ，并且创建了 微任务队列，所以在下一个 宏任务队列执行前，先执行 微任务，在 微任务执行中，输出 3 ，微任务执行后，执行下一次 宏任务，执行中输出 2</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>执行一个 宏任务（栈中没有就从 事件队列中获取）</li><li>执行过程中如果遇到 微任务，就将它添加到 微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前 微任务队列中的所有 微任务（依次执行）</li><li>当前 宏任务执行完毕，开始检查渲染，然后 GUI线程接管渲染</li><li>渲染完毕后， JS线程继续接管，开始下一个 宏任务（从事件队列中获取）</li></ul><p><img src="/images/FE-Interview01/image-20210412162902064.png" alt="image-20210412162902064"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是宏任务&quot;&gt;&lt;a href=&quot;#什么是宏任务&quot; class=&quot;headerlink&quot; title=&quot;什么是宏任务&quot;&gt;&lt;/a&gt;什么是宏任务&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;我们可以将每次执行栈执行的代码当做是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈</summary>
      
    
    
    
    <category term="FE-Interview" scheme="http://example.com/categories/FE-Interview/"/>
    
    
    <category term="FE-Interview" scheme="http://example.com/tags/FE-Interview/"/>
    
    <category term="宏任务" scheme="http://example.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"/>
    
    <category term="微任务" scheme="http://example.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Vue-MVVM浅析</title>
    <link href="http://example.com/2021/04/09/Vue-MVVM/"/>
    <id>http://example.com/2021/04/09/Vue-MVVM/</id>
    <published>2021-04-09T12:49:34.000Z</published>
    <updated>2021-04-29T04:17:47.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/Vue-MVVM/89.png" alt="img"></p><h2 id="vue-实现-todo-list"><a href="#vue-实现-todo-list" class="headerlink" title="vue 实现 todo-list"></a>vue 实现 todo-list</h2><p><img src="/images/Vue-MVVM/91.png" alt="img"></p><h2 id="一、对-MVVM-的理解"><a href="#一、对-MVVM-的理解" class="headerlink" title="一、对 MVVM 的理解"></a>一、对 MVVM 的理解</h2><h3 id="1-1-MVC"><a href="#1-1-MVC" class="headerlink" title="1.1 MVC"></a>1.1 MVC</h3><ul><li><code>M - Model</code> 数据</li><li><code>V - View</code> 视图、界面</li><li><code>C - Controller</code> 控制器、逻辑处理</li></ul><p><img src="/images/Vue-MVVM/92.png" alt="img"></p><p><img src="/images/Vue-MVVM/93.png" alt="img"></p><h3 id="1-2-MVVM"><a href="#1-2-MVVM" class="headerlink" title="1.2 MVVM"></a>1.2 MVVM</h3><ul><li><code>Model</code> - 模型、数据</li><li><code>View</code> - 视图、模板（视图和模型是分离的）</li><li><code>ViewModel</code> - 连接 <code>Model</code> 和 <code>View</code></li></ul><p><img src="/images/Vue-MVVM/94.png" alt="img"></p><h3 id="1-3-关于-ViewModel"><a href="#1-3-关于-ViewModel" class="headerlink" title="1.3 关于 ViewModel"></a>1.3 关于 ViewModel</h3><ul><li><code>MVVM</code> 不算是一种创新</li><li>但其中的 <code>ViewModel</code> 确实一种创新</li><li>真正结合前端场景应用的创建</li></ul><p><img src="/images/Vue-MVVM/95.png" alt="img"></p><p><img src="/images/Vue-MVVM/96.png" alt="img"></p><h3 id="1-4-MVVM-框架的三大要素"><a href="#1-4-MVVM-框架的三大要素" class="headerlink" title="1.4 MVVM 框架的三大要素"></a>1.4 MVVM 框架的三大要素</h3><ul><li>响应式：<code>vue</code>如何监听到 <code>data</code> 的每个属性变化？</li><li>模板引擎：<code>vue</code> 的模板如何被解析，指令如何处理？</li><li>渲染：<code>vue</code> 的模板如何被渲染成 <code>html</code> ？以及渲染过程</li></ul><h2 id="二、vue-中如何实现响应式"><a href="#二、vue-中如何实现响应式" class="headerlink" title="二、vue 中如何实现响应式"></a>二、vue 中如何实现响应式</h2><h3 id="2-1-什么是响应式"><a href="#2-1-什么是响应式" class="headerlink" title="2.1 什么是响应式"></a>2.1 什么是响应式</h3><ul><li>修改 data 属性之后，vue 立刻监听到</li><li>data 属性被代理到 vm 上</li></ul><p><img src="/images/Vue-MVVM/97.png" alt="img"></p><h3 id="2-2-Object-defineProperty"><a href="#2-2-Object-defineProperty" class="headerlink" title="2.2 Object.defineProperty"></a>2.2 Object.defineProperty</h3><p><img src="/images/Vue-MVVM/98.png" alt="img"></p><h3 id="2-3-模拟实现"><a href="#2-3-模拟实现" class="headerlink" title="2.3 模拟实现"></a>2.3 模拟实现</h3><p><img src="/images/Vue-MVVM/99.png" alt="img"></p><p><img src="/images/Vue-MVVM/100.png" alt="img"></p><h2 id="三、vue-中如何解析模板"><a href="#三、vue-中如何解析模板" class="headerlink" title="三、vue 中如何解析模板"></a>三、vue 中如何解析模板</h2><h3 id="3-1-模板是什么"><a href="#3-1-模板是什么" class="headerlink" title="3.1 模板是什么"></a>3.1 模板是什么</h3><ul><li>本质：字符串</li><li>有逻辑，如 <code>v-if</code> <code>v-for</code> 等</li><li>与 <code>html</code> 格式很像，但有很大区别</li><li>最终还要转换为 <code>html</code> 来显示</li></ul><blockquote><p> <strong>模板最终必须转换成 JS 代码，因为</strong></p></blockquote><ul><li>有逻辑（<code>v-if</code> <code>v-for</code>），必须用 <code>JS</code>才能实现</li><li>转换为 <code>html</code> 渲染页面，必须用 <code>JS</code> 才能实现</li><li>因此，模板最重要转换成一个 <code>JS</code> 函数（<code>render</code> 函数）</li></ul><p><img src="/images/Vue-MVVM/101.png" alt="img"></p><h3 id="3-2-render-函数"><a href="#3-2-render-函数" class="headerlink" title="3.2 render 函数"></a>3.2 render 函数</h3><ul><li>模板中所有信息都包含在了 <code>render</code> 函数中</li><li><code>this</code> 即<code>vm</code></li><li><code>price</code> 即 <code>this.price</code> 即 <code>vm.price</code>，即 <code>data</code> 中的 <code>price</code></li><li><code>_c</code> 即 <code>this._c</code> 即 <code>vm._c</code></li></ul><p><img src="/images/Vue-MVVM/102.png" alt="img"></p><p><img src="/images/Vue-MVVM/103.png" alt="img"></p><p><img src="/images/Vue-MVVM/104.png" alt="img"></p><h3 id="3-3-render-函数与-vdom"><a href="#3-3-render-函数与-vdom" class="headerlink" title="3.3 render 函数与 vdom"></a>3.3 render 函数与 vdom</h3><ul><li><code>vm._c</code> 其实就相当于 <code>snabbdom</code>中的 <code>h</code> 函数</li><li><code>render</code> 函数执行之后，返回的是 <code>vnode</code></li></ul><p><img src="/images/Vue-MVVM/105.png" alt="img"></p><p><img src="/images/Vue-MVVM/106.png" alt="img"></p><ul><li><code>updateComponent</code>中实现了 <code>vdom</code> 的 <code>patch</code></li><li>页面首次渲染执行 <code>updateComponent</code></li><li><code>data</code> 中每次修改属性，执行<code>updateComponent</code></li></ul><h2 id="四、vue-的整个实现流程"><a href="#四、vue-的整个实现流程" class="headerlink" title="四、vue 的整个实现流程"></a>四、vue 的整个实现流程</h2><ul><li>第一步：解析模板成 render 函数</li><li>第二步：响应式开始监听</li><li>第三步：首次渲染，显示页面，且绑定依赖</li><li>第四步：<code>data</code> 属性变化，触发 <code>rerender</code></li></ul><p><img src="/images/Vue-MVVM/107.png" alt="img"></p><h3 id="4-1-第一步：解析模板成-render-函数"><a href="#4-1-第一步：解析模板成-render-函数" class="headerlink" title="4.1 第一步：解析模板成 render 函数"></a>4.1 第一步：解析模板成 render 函数</h3><p><img src="/images/Vue-MVVM/108.png" alt="img"></p><p><img src="/images/Vue-MVVM/109.png" alt="img"></p><p><img src="/images/Vue-MVVM/110.png" alt="img"></p><p><img src="/images/Vue-MVVM/111.png" alt="img"></p><ul><li>模板中的所有信息都被 <code>render</code>函数包含</li><li>模板中用到的 <code>data</code> 中的属性，都变成了 <code>JS</code> 变量</li><li>模板中的<code>v-model</code> <code>v-for</code> <code>v-on</code> 都变成了 <code>JS</code> 逻辑</li><li><code>render</code> 函数返回 <code>vnode</code></li></ul><h3 id="4-2-第二步：响应式开始监听"><a href="#4-2-第二步：响应式开始监听" class="headerlink" title="4.2 第二步：响应式开始监听"></a>4.2 第二步：响应式开始监听</h3><ul><li><code>Object.defineProperty</code></li><li>将 <code>data</code> 的属性代理到 <code>vm</code>上</li></ul><p><img src="/images/Vue-MVVM/112.png" alt="img"></p><h3 id="4-3-第三步：首次渲染，显示页面，且绑定依赖"><a href="#4-3-第三步：首次渲染，显示页面，且绑定依赖" class="headerlink" title="4.3 第三步：首次渲染，显示页面，且绑定依赖"></a>4.3 第三步：首次渲染，显示页面，且绑定依赖</h3><ul><li>初次渲染，执行 <code>updateComponent</code>，执行 <code>vm._render()</code></li><li>执行 <code>render</code> 函数，会访问到 <code>vm.list vm.title</code></li><li>会被响应式的 <code>get</code> 方法监听到</li><li>执行 <code>updateComponent</code> ，会走到 <code>vdom</code> 的 <code>patch</code> 方法</li><li><code>patch</code> 将 <code>vnode</code>渲染成 <code>DOM</code> ，初次渲染完成</li></ul><p><img src="/images/Vue-MVVM/113.png" alt="img"></p><p><img src="/images/Vue-MVVM/114.png" alt="img"></p><blockquote><p> <strong>为何要监听 get ，直接监听 set 不行吗？</strong></p></blockquote><ul><li><code>data</code> 中有很多属性，有些被用到，有些可能不被用到</li><li>被用到的会走到 <code>get</code> ，不被用到的不会走到 <code>get</code></li><li>未走到 <code>get</code> 中的属性，<code>set</code>的时候我们也无需关心</li><li>避免不必要的重复渲染</li></ul><p><img src="/images/Vue-MVVM/115.png" alt="img"></p><h3 id="4-4-第四步：data-属性变化"><a href="#4-4-第四步：data-属性变化" class="headerlink" title="4.4 第四步：data 属性变化"></a>4.4 第四步：data 属性变化</h3><p><img src="/images/Vue-MVVM/116.png" alt="img"></p><p><img src="/images/Vue-MVVM/117.png" alt="img"></p><ul><li>修改属性，被响应式的 <code>set</code> 监听到</li><li><code>set</code>中执行 <code>updateComponent</code></li><li>updateComponent 重新执行 <code>vm._render()</code></li><li>生成的 <code>vnode</code> 和 <code>prevVnode</code> ，通过 <code>patch</code>进行对比</li><li>渲染到 <code>html</code> 中</li></ul><p><img src="/images/Vue-MVVM/118.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/Vue-MVVM/89.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;vue-实现-todo-list&quot;&gt;&lt;a href=&quot;#vue-实现-todo-list&quot; class=&quot;headerlink&quot; title=&quot;vue 实现 </summary>
      
    
    
    
    <category term="框架学习" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="响应式" scheme="http://example.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
    <category term="render" scheme="http://example.com/tags/render/"/>
    
    <category term="Vue实现流程" scheme="http://example.com/tags/Vue%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Es6常用API整理</title>
    <link href="http://example.com/2021/04/08/Es6-Review/"/>
    <id>http://example.com/2021/04/08/Es6-Review/</id>
    <published>2021-04-08T12:08:09.000Z</published>
    <updated>2021-04-09T13:23:20.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6常用API整理"><a href="#ES6常用API整理" class="headerlink" title="ES6常用API整理"></a>ES6常用API整理</h1><h3 id="ECMAScript-6简介"><a href="#ECMAScript-6简介" class="headerlink" title="ECMAScript 6简介"></a>ECMAScript 6简介</h3><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h3 id="let和const命名"><a href="#let和const命名" class="headerlink" title="let和const命名"></a>let和const命名</h3><h4 id="let基本用法-块级作用域"><a href="#let基本用法-块级作用域" class="headerlink" title="let基本用法-块级作用域"></a>let基本用法-块级作用域</h4><p>在es6中可以使用let声明变量，用法类似于var</p><blockquote><p>⚠️ let声明的变量，只在<code>let</code>命令所在的代码块内有效</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//20</span></span><br></pre></td></tr></table></figure><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p><code>var</code>命令会发生<code>变量提升</code>现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定在声明后使用，否则报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//输出undefined</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//let的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p><code>let</code>不允许在相同作用域内，重复声明同一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>了解的一个名词，说的就是<code>let</code>和<code>const</code>命令声明变量的特征。</p><p>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为<code>暂时性死区</code>(temporal dead zone，简称 TDZ)</p><h4 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h4><h5 id="原因一：内层变量可能会覆盖外层变量"><a href="#原因一：内层变量可能会覆盖外层变量" class="headerlink" title="原因一：内层变量可能会覆盖外层变量"></a>原因一：内层变量可能会覆盖外层变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>===<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">&#x27;hello 小马哥&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">foo(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="原因二：用来计数的循环遍历泄露为全局变量"><a href="#原因二：用来计数的循环遍历泄露为全局变量" class="headerlink" title="原因二：用来计数的循环遍历泄露为全局变量"></a>原因二：用来计数的循环遍历泄露为全局变量</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">5</span>]());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，用于变量提升，泄露成了全局变量。</p><p><strong>解决循环计数问题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决方式一：使用闭包</span></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方式二：使用let声明i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="const基本用法-声明只读的常量"><a href="#const基本用法-声明只读的常量" class="headerlink" title="const基本用法-声明只读的常量"></a>const基本用法-声明只读的常量</h4><p>这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。对于<code>const</code>来说，只声明不赋值，就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b; <span class="comment">//报错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="与let命令相同点"><a href="#与let命令相同点" class="headerlink" title="与let命令相同点"></a>与<code>let</code>命令相同点</h4><ul><li>块级作用域</li><li>暂时性死区</li><li>不可重复声明</li></ul><h4 id="let和const使用建议"><a href="#let和const使用建议" class="headerlink" title="let和const使用建议"></a><code>let</code>和<code>const</code>使用建议</h4><blockquote><p>在默认情况下用const,而只有你在知道变量值需要被修改的情况下使用let</p></blockquote><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统的 JavaScript 语言，输出模板通常是这样写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oBox = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="number">1</span>,name = <span class="string">&#x27;小马哥&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> htmlTel = <span class="string">&quot;&lt;ul&gt;&lt;li&gt;&lt;p&gt;id:&quot;</span> + id + <span class="string">&quot;&lt;/p&gt;&lt;p&gt;name:&quot;</span> + name + <span class="string">&quot;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&quot;</span>;</span><br><span class="line">oBox.innerHTML = htmlTel;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的这种写法相当繁琐不方便,ES6引入了模板字符串解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> htmlTel = <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">    &lt;li&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;id:<span class="subst">$&#123;id&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;name:<span class="subst">$&#123;name&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>解构赋值是对赋值运算符的一种扩展。它通常针对数组和对象进行操作。</p><blockquote><p>优点：代码书写简洁且易读性高</p></blockquote><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><p>在以前，为变量赋值，只能直接指定值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES6允许我们这样写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>如果解构不成功，变量的值就等于<code>undefined</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">foo<span class="string">`的值都会等于`</span><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>解构可以用于对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type:<span class="string">&#x27;identifier&#x27;</span>,</span><br><span class="line">    name:<span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;type,name&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type,name)<span class="comment">//identifier foo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象的解构赋值时，可以对属性忽略和使用剩余运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">        name:<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    b:[],</span><br><span class="line">    c:<span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可忽略 忽略b,c属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;a&#125; = obj;</span><br><span class="line"><span class="comment">//剩余运算符 使用此法将其它属性展开到一个对象中存储</span></span><br><span class="line"><span class="keyword">let</span> &#123;a,...res&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(a,res);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>默认值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,b = <span class="number">10</span>&#125; = &#123;<span class="attr">a</span>:<span class="number">20</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数参数解构赋值"><a href="#函数参数解构赋值" class="headerlink" title="函数参数解构赋值"></a>函数参数解构赋值</h4><p>直接看例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCart</span>(<span class="params">n,num=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n+num;</span><br><span class="line">&#125;</span><br><span class="line">addCart(<span class="number">10</span>);<span class="comment">//10</span></span><br><span class="line">addCart(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//30</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li><p>交换变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> [x,y] = [y,x];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码交换变量<code>x</code>和<code>y</code>的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p></li><li><p>从函数返回多个值</p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>函数参数的定义</p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>提取JSON数据</p><p>解构赋值对提取 JSON 对象中的数据，尤其有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"><span class="comment">//对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</span></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>函数参数的默认值</p></li><li><p>输入模块的指定方法</p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ajax&#125; = <span class="built_in">require</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ajax()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h4><p>ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    y = y || <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>);<span class="comment">//hello world</span></span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;china&#x27;</span>) <span class="comment">//hello china</span></span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;&#x27;</span>)<span class="comment">//hello world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p></blockquote><p><strong>默认的表达式可以是一个函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVal</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">a, b = getVal(<span class="number">5</span>)</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add2(<span class="number">10</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>小练习</strong></p><p>请问下面两种写法有什么区别？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;) <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">z</span>: <span class="number">3</span>&#125;) <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数 ***"></a>箭头函数 ***</h4><p>ES6允许使用箭头<code>=&gt;</code>定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">v</span>=&gt;</span>v;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个参数</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有两个参数</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">value,value2</span>) =&gt;</span> value + value2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">value1,value2</span>)=&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value1 + value2;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无参数</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> doThing = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</span></span><br><span class="line"><span class="keyword">let</span> getId = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;<span class="attr">id</span>: id,<span class="attr">name</span>: <span class="string">&#x27;mjj&#x27;</span>&#125;) <span class="comment">//注意</span></span><br><span class="line"><span class="keyword">let</span> obj = getId(<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="箭头函数的作用"><a href="#箭头函数的作用" class="headerlink" title="箭头函数的作用"></a>箭头函数的作用</h4><ul><li><p>使表达更加简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>简化回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><ul><li><p>没有this绑定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PageHandler = &#123;</span><br><span class="line">    id:<span class="number">123</span>,</span><br><span class="line">    init:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomeThings(event.type);</span><br><span class="line">        &#125;,<span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    doSomeThings:<span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`事件类型:<span class="subst">$&#123;type&#125;</span>,当前id:<span class="subst">$&#123;<span class="built_in">this</span>.id&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PageHandler.init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决this指向问题</span></span><br><span class="line"><span class="keyword">let</span> PageHandler = &#123;</span><br><span class="line">    id: <span class="number">123</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 使用bind来改变内部函数this的指向</span></span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.doSomeThings(event.type);</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    doSomeThings: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`事件类型:<span class="subst">$&#123;type&#125;</span>,当前id:<span class="subst">$&#123;<span class="built_in">this</span>.id&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PageHandler.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> PageHandler = &#123;</span><br><span class="line">    id: <span class="number">123</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 箭头函数没有this的指向，箭头函数内部的this值只能通过查找作用域链来确定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果箭头函数被一个非箭头函数所包括，那么this的值与该函数的所属对象相等，否则 则是全局的window对象</span></span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.doSomeThings(event.type);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    doSomeThings: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`事件类型:<span class="subst">$&#123;type&#125;</span>,当前id:<span class="subst">$&#123;<span class="built_in">this</span>.id&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PageHandler.init();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>箭头函数中没有arguments对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getVal = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getVal(<span class="number">1</span>,<span class="number">2</span>)); <span class="comment">//arguments is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能使用new关键字来实例化对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person();<span class="comment">// Person is not a constructor</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name, <span class="comment">//等同于name:name</span></span><br><span class="line">    age,</span><br><span class="line">    <span class="comment">// 方法也可以简写</span></span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.sayName();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种写法用于函数的返回值，将会非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="对象扩展运算符"><a href="#对象扩展运算符" class="headerlink" title="对象扩展运算符"></a>对象扩展运算符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// [2, 3]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>解构赋值必须是最后一个参数，否则会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = obj; <span class="comment">// 句法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj; <span class="comment">// 句法错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩展运算符可以用于合并两个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><p>异步编程模块在前端开发中，显得越来越重要。从最开始的XHR到封装后的Ajax都在试图解决异步编程过程中的问题。随着ES6新标准的到来，处理异步数据流又有了新的解决方案。在传统的ajax请求中，当异步请求之间的数据存在依赖关系的时候，就可能产生不优雅的多层回调，俗称”回调地域“(callback hell)，这却让人望而生畏，Promise的出现让我们告别回调地域，写出更优雅的异步代码。</p><p>回调地狱带来的负面作用有以下几点：</p><ul><li>代码臃肿。</li><li>可读性差。</li><li>耦合度过高，可维护性差。</li><li>代码复用性差。</li><li>容易滋生 bug。</li><li>只能在回调里处理异常。</li></ul><blockquote><p>在实践过程中，却发现Promise并不完美，Async/Await是近年来JavaScript添加的最革命性的的特性之一，<strong>Async/Await提供了一种使得异步代码看起来像同步代码的替代方法</strong>。接下来我们介绍这两种处理异步编程的方案。</p></blockquote><h4 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h4><blockquote><p>Promise 是异步编程的一种解决方案：</p><p>从语法上讲，Promise是一个对象，通过它可以获取异步操作的消息；</p><p>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p><p>promise有三种<strong>状态</strong>：**pending(等待态)，fulfilled(成功态)，rejected(失败态)**；</p><p>状态一旦改变，就不会再变。</p><p>创造promise实例后，它会立即执行。</p></blockquote><p>看段习以为常的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise是一个构造函数，自己身上有all,reject,resolve,race方法，原型上有then、catch等方法</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 做一些异步操作</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">/* let res = &#123;</span></span><br><span class="line"><span class="comment">ok:1,</span></span><br><span class="line"><span class="comment">data:&#123;</span></span><br><span class="line"><span class="comment">name:&quot;张三&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">let</span> res = &#123;</span><br><span class="line">ok:<span class="number">0</span>,</span><br><span class="line">error:<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;有错&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(res.ok === <span class="number">1</span>)&#123;</span><br><span class="line">resolve(res.data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">reject(res.error.message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Promise的状态和值"><a href="#Promise的状态和值" class="headerlink" title="Promise的状态和值"></a>Promise的状态和值</h4><p><code>Promise</code>对象存在以下三种状态</p><ul><li>Pending(进行中)</li><li>Fulfilled(已成功)</li><li>Rejected(已失败)</li></ul><blockquote><p>状态只能由 <code>Pending</code> 变为 <code>Fulfilled</code> 或由 <code>Pending</code> 变为 <code>Rejected</code> ，且状态改变之后不会在发生变化，会一直保持这个状态。</p></blockquote><p><code>Promise</code>的值是指状态改变时传递给回调函数的值</p><p>上面例子中的参数为resolve和reject，他们都是函数，用他们可以改变Promise的状态和传入的Promise的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve<span class="string">` 和 `</span>reject</span><br></pre></td></tr></table></figure><ul><li><code>resolve</code> : 将Promise对象的状态从 <code>Pending(进行中)</code> 变为 <code>Fulfilled(已成功)</code></li><li><code>reject</code> : 将Promise对象的状态从 <code>Pending(进行中)</code> 变为 <code>Rejected(已失败)</code></li><li><code>resolve</code> 和 <code>reject</code> 都可以传入任意类型的值作为实参，表示 <code>Promise</code> 对象成功<code>（Fulfilled）</code>和失败<code>（Rejected）</code>的值</li></ul><h4 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;,<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>promise的then方法返回一个promise对象，所以可以继续链式调用</p><p>上述代码我们可以继续改造，因为上述代码不能传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        &#125;, ms);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">timeout(<span class="number">1000</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="then方法的规则"><a href="#then方法的规则" class="headerlink" title="then方法的规则"></a>then方法的规则</h4><ul><li><code>then</code>方法下一次的输入需要上一次的输出</li><li>如果一个promise执行完后 返回的还是一个promise，会把这个promise 的执行结果，传递给下一次<code>then</code>中</li><li>如果<code>then</code>中返回的不是Promise对象而是一个普通值，则会将这个结果作为下次then的成功的结果</li><li>如果当前<code>then</code>中失败了 会走下一个<code>then</code>的失败</li><li>如果返回的是undefined 不管当前是成功还是失败 都会走下一次的成功</li><li>catch是错误没有处理的情况下才会走</li><li><code>then</code>中不写方法则值会穿透，传入下一个<code>then</code>中</li></ul><h4 id="Promise封装XHR对象"><a href="#Promise封装XHR对象" class="headerlink" title="Promise封装XHR对象"></a>Promise封装XHR对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">        xhr.onreadystatechange = handler;</span><br><span class="line">        xhr.responseType = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.readyState);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="built_in">this</span>.response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getJSON(<span class="string">&#x27;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#x27;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//then方法的链式调用</span></span><br><span class="line">getJSON(<span class="string">&#x27;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#x27;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res.HeWeather6;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">HeWeather6</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(HeWeather6);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;&#125;)<span class="string">`方法等价于`</span>then(<span class="literal">null</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;&#125;)</span><br><span class="line">getJSON(<span class="string">&#x27;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#x27;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(json);</span><br><span class="line">&#125;).then(<span class="literal">null</span>,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);   </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">getJSON(<span class="string">&#x27;https://free-api.heweather.net/s6/weather/now?location=beijing&amp;key=4693ff5ea653469f8bb0c29638035976&#x27;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(json);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);   </span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="resove"><a href="#resove" class="headerlink" title="resove()"></a>resove()</h4><p><code>resolve()</code>方法将现有对象转换成Promise对象，该实例的状态为fulfilled</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">//等价于 new Promise(resolve=&gt;resolve(&#x27;foo&#x27;));</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h4><p><code>reject()</code>方法返回一个新的Promise实例，该实例的状态为rejected</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>));</span><br><span class="line"><span class="comment">//等价于 let p2 = new Promise((resolve,reject)=&gt;reject(new Error(&#x27;出错了)));</span></span><br><span class="line">p2.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="all-方法"><a href="#all-方法" class="headerlink" title="all()方法"></a>all()方法</h4><p>all()方法提供了并行执行异步操作的能力，并且再所有异步操作执行完后才执行回调</p><p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meInfoPro = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;P1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> youInfoPro = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&#x27;P2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 同时执行p1和p2，并在它们都完成后执行then:</span></span><br><span class="line"><span class="built_in">Promise</span>.all([meInfoPro, youInfoPro]).then( <span class="function">(<span class="params">results</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(results); <span class="comment">// 获得一个Array: [&#x27;P1&#x27;, &#x27;P2&#x27;]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="race-方法"><a href="#race-方法" class="headerlink" title="race()方法"></a>race()方法</h4><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> meInfoPro1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;P1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> meInfoPro2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">600</span>, <span class="string">&#x27;P2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.race([meInfoPro1, meInfoPro2]).then(<span class="function">(<span class="params">result</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// P1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>Promise.all接受一个promise对象的数组，待全部完成之后，统一执行success</strong>;</p><p><strong>Promise.race接受一个包含多个promise对象的数组，只要有一个完成，就执行success</strong></p></blockquote><p>举个更具体的例子，加深对race()方法的理解</p><p>当我们请求某个图片资源，会导致时间过长，给用户反馈</p><p>用race给某个异步请求设置超时时间，并且在超时后执行相应的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestImg</span>(<span class="params">imgSrc</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(img);</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = imgSrc;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;图片请求超时&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.race([requestImg(<span class="string">&#x27;images/2.png&#x27;</span>), timeout()]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h3><p>异步操作是JavaScript编程的麻烦事，很多人认为async函数是异步编程的解决方案</p><h4 id="Async-await介绍"><a href="#Async-await介绍" class="headerlink" title="Async/await介绍"></a>Async/await介绍</h4><ul><li>async/await是写异步代码的新方式，优于回调函数和Promise。</li><li>async/await是基于Promise实现的，它不能用于普通的回调函数。</li><li>async/await与Promise一样，是非阻塞的。</li><li>async/await使得异步代码看起来像同步代码，再也没有回调函数。但是改变不了JS单线程、异步的本质。(<strong>异步代码同步化</strong>)</li></ul><h4 id="Async-await的使用规则"><a href="#Async-await的使用规则" class="headerlink" title="Async/await的使用规则"></a>Async/await的使用规则</h4><ul><li><p><strong>凡是在前面添加了async的函数在执行后都会自动返回一个Promise对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = test()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">//即便代码里test函数什么都没返回，我们依然打出了Promise对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>await必须在async函数里使用，不能单独使用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>await后面需要跟Promise对象，不然就没有意义，而且await后面的Promise对象不必写then，因为await的作用之一就是获取后面Promise对象成功状态传递出来的参数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> fn() <span class="comment">//因为fn会返回一个Promise对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)    <span class="comment">//这里会打出Promise成功后传递过来的&#x27;success&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="Async-Await的用法"><a href="#Async-Await的用法" class="headerlink" title="Async/Await的用法"></a>Async/Await的用法</h4><ul><li>使用await，函数必须用async标识</li><li>await后面跟的是一个Promise实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="string">&#x27;图片加载失败&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> src1 = <span class="string">&#x27;https://hcdn1.luffycity.com/static/frontend/index/banner@2x_1574647618.8112254.png&#x27;</span></span><br><span class="line"><span class="keyword">const</span> src2 = <span class="string">&#x27;https://hcdn2.luffycity.com/media/frontend/index/%E7%94%BB%E6%9D%BF.png&#x27;</span></span><br><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1)</span><br><span class="line">    <span class="built_in">console</span>.log(result1)</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2)</span><br><span class="line">    <span class="built_in">console</span>.log(result2)</span><br><span class="line">&#125;</span><br><span class="line">load()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</strong></p><h4 id="async-await的错误处理"><a href="#async-await的错误处理" class="headerlink" title="async/await的错误处理"></a>async/await的错误处理</h4><p>关于错误处理，如规则三所说，await可以直接获取到后面Promise成功状态传递的参数，但是却捕捉不到失败状态。在这里，我们通过给包裹await的async函数添加then/catch方法来解决，因为根据规则一，async函数本身就会返回一个Promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="keyword">await</span> loadImg(src1)</span><br><span class="line">        <span class="built_in">console</span>.log(result1)</span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="keyword">await</span> loadImg(src2)</span><br><span class="line">        <span class="built_in">console</span>.log(result2)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">load()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="为什么Async-Await更好？"><a href="#为什么Async-Await更好？" class="headerlink" title="为什么Async/Await更好？"></a>为什么Async/Await更好？</h4><p>Async/Await较Promise有诸多好处，以下介绍其中三种优势：</p><ul><li><p><strong>简洁</strong></p><p>使用Async/Await明显节约了不少代码。我们不需要写.then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。</p></li><li><p><strong>中间值</strong></p></li></ul><p>在前端编程中，我们偶尔会遇到这样一个场景：我们需要发送多个请求，而<strong>后面请求的发送总是需要依赖上一个请求返回的数据</strong>。对于这个问题，我们既可以用的Promise的链式调用来解决，也可以用async/await来解决，然而后者会更简洁些</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise1()</span><br><span class="line">    .then(<span class="function"><span class="params">value1</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> promise2(value1)</span><br><span class="line">        .then(<span class="function"><span class="params">value2</span> =&gt;</span> &#123;        </span><br><span class="line">          <span class="keyword">return</span> promise3(value1, value2)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用async/await的话，代码会变得异常简单和直观</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> value1 = <span class="keyword">await</span> promise1()</span><br><span class="line">  <span class="keyword">const</span> value2 = <span class="keyword">await</span> promise2(value1)</span><br><span class="line">  <span class="keyword">return</span> promise3(value1, value2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>提高可读性</strong></li></ul><p>下面示例中，需要获取数据，然后根据返回数据决定是直接返回，还是继续获取更多的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeRequest = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON()</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.needsAnotherRequest) &#123;</span><br><span class="line">        <span class="keyword">return</span> makeAnotherRequest(data)</span><br><span class="line">          .then(<span class="function"><span class="params">moreData</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(moreData)</span><br><span class="line">            <span class="keyword">return</span> moreData</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码嵌套（6层）可读性较差，它们传达的意思只是需要将最终结果传递到最外层的Promise。使用async/await编写可以大大地提高可读性:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeRequest = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getJSON()</span><br><span class="line">  <span class="keyword">if</span> (data.needsAnotherRequest) &#123;</span><br><span class="line">    <span class="keyword">const</span> moreData = <span class="keyword">await</span> makeAnotherRequest(data);</span><br><span class="line">    <span class="built_in">console</span>.log(moreData)</span><br><span class="line">    <span class="keyword">return</span> moreData</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> data    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Class的基本用法"><a href="#Class的基本用法" class="headerlink" title="Class的基本用法"></a>Class的基本用法</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>JavaScript语言中，生成实例对象的传统方法是通过构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;小马哥&#x27;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// constructor方法 是类的默认方法,通过new命令生成对象实例时,自动调用该方法,一个类必须有constructor方法,如果没有定义,会被默认添加</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等同于Person.prototype = function sayName()&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person===Person.prototype.constructor)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例</p></blockquote><h3 id="Module-模块化"><a href="#Module-模块化" class="headerlink" title="Module 模块化"></a>Module 模块化</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p><h4 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h4><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;zhangsan &#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> color = <span class="string">&#x27;red &#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fristName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这样</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;zhangsan &#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">const</span> color = <span class="string">&#x27;red &#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fristName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;name,age,color,sayName&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name,age,color,sayName,fn&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/index.js&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> obj <span class="keyword">from</span> <span class="string">&#x27;./modules/index.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h4><p>使用<code>export default</code>命令为模块指定默认输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在其它模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">&#x27;./export-default.js&#x27;</span></span><br><span class="line">customNmae();<span class="comment">//foo</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想在一条import语句中，同事输入默认方法和其他接口，可以写成下面这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName,&#123;add&#125; <span class="keyword">from</span> <span class="string">&#x27;export-default.js&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应上面<code>export</code>语句如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>export default</code>也可以用来输出类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Person <span class="keyword">from</span> <span class="string">&#x27;MyClass&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6常用API整理&quot;&gt;&lt;a href=&quot;#ES6常用API整理&quot; class=&quot;headerlink&quot; title=&quot;ES6常用API整理&quot;&gt;&lt;/a&gt;ES6常用API整理&lt;/h1&gt;&lt;h3 id=&quot;ECMAScript-6简介&quot;&gt;&lt;a href=&quot;#ECMAScr</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
    <category term="Es6" scheme="http://example.com/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript知识整理</title>
    <link href="http://example.com/2021/04/05/JavaScript-Review/"/>
    <id>http://example.com/2021/04/05/JavaScript-Review/</id>
    <published>2021-04-05T12:06:21.000Z</published>
    <updated>2021-04-09T13:18:35.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、前端知识体系"><a href="#0、前端知识体系" class="headerlink" title="0、前端知识体系"></a>0、前端知识体系</h1><p>想要成为真正的“互联网Java全栈工程师”还有很长的一段路要走，其中前端是绕不开的一门必修课。本阶段课程的主要目的就是带领Java后台程序员认识前端、了解前端、掌握前端，为实现成为“互联网Java全栈工程师”再向前迈进一步。</p><h2 id="0-1、前端三要素"><a href="#0-1、前端三要素" class="headerlink" title="0.1、前端三要素"></a>0.1、前端三要素</h2><ul><li>HTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容</li><li>CSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式。</li><li>JavaScript（行为）：是一种弱类型脚本语言，其源码不需经过编译，而是由浏览器解释运行，用于控制网页的行为</li></ul><blockquote><h2 id="0-2、结构层（HTML）"><a href="#0-2、结构层（HTML）" class="headerlink" title="0.2、结构层（HTML）"></a>0.2、结构层（HTML）</h2></blockquote><p>太简单，略</p><blockquote><h2 id="0-3、表现层（CSS）"><a href="#0-3、表现层（CSS）" class="headerlink" title="0.3、表现层（CSS）"></a>0.3、表现层（CSS）</h2></blockquote><p>CSS层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下：</p><ul><li>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护；<br>这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为【CSS预处理器】的工具,提供CSS缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大的提高了前端在样式上的开发效率。</li></ul><blockquote><p>什么是CSS预处理器</p></blockquote><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只需要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是“<strong>用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用”</strong>。</p><p>常用的CSS预处理器有哪些</p><ul><li>SASS：基于Ruby ，通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。</li><li>LESS：基于NodeJS，通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS，但在实际开发中足够了，所以如果我们后台人员如果需要的话，建议使用LESS。</li></ul><h2 id="0-4、行为层（JavaScript）"><a href="#0-4、行为层（JavaScript）" class="headerlink" title="0.4、行为层（JavaScript）"></a>0.4、行为层（JavaScript）</h2><p>JavaScript一门弱类型脚本语言，其源代码在发往客户端运行之前不需要经过编译，而是将文本格式的字符代码发送给浏览器，由浏览器解释运行。</p><h2 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h2><ul><li>JQuery：大家熟知的JavaScript库，优点就是简化了DOM操作，缺点就是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6，7，8；</li><li>Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了<strong>模块化开发</strong>的理念，与微软合作，采用了TypeScript语法开发；对后台程序员友好，对前端程序员不太友好；最大的缺点是版本迭代不合理（如1代–&gt;2 代，除了名字，基本就是两个东西；截止发表博客时已推出了Angular6）</li><li>React：Facebook 出品，一款高性能的JS前端框架；特点是提出了新概念 【虚拟DOM】用于减少真实 DOM 操作，在内存中模拟 DOM操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】语言；</li><li>Vue：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化）和React(虚拟 DOM) 的优点；</li><li>Axios：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery 提供的AJAX 通信功能；</li></ul><h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><ul><li>Ant-Design：阿里巴巴出品，基于React的UI框架</li><li>ElementUI、iview、ice：饿了么出品，基于Vue的UI框架</li><li>BootStrap：Teitter推出的一个用于前端开发的开源工具包</li><li>AmazeUI：又叫“妹子UI”，一款HTML5跨屏前端框架</li></ul><h2 id="JavaScript构建工具"><a href="#JavaScript构建工具" class="headerlink" title="JavaScript构建工具"></a>JavaScript构建工具</h2><ul><li>Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript</li><li>WebPack：模块打包器，主要作用就是打包、压缩、合并及按序加载</li></ul><blockquote><p>注：以上知识点已将WebApp开发所需技能全部梳理完毕</p></blockquote><h2 id="0-5、三端同一"><a href="#0-5、三端同一" class="headerlink" title="0.5、三端同一"></a>0.5、三端同一</h2><h3 id="混合开发（Hybrid-App）"><a href="#混合开发（Hybrid-App）" class="headerlink" title="混合开发（Hybrid App）"></a>混合开发（Hybrid App）</h3><p>主要目的是实现一套代码三端统一（PC、Android：.apk、iOS：.ipa）并能够调用到设备底层硬件（如：传感器、GPS、摄像头等），打包方式主要有以下两种：</p><ul><li>云打包：HBuild -&gt; HBuildX，DCloud 出品；API Cloud</li><li>本地打包： Cordova（前身是 PhoneGap）</li></ul><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><p>详见微信官网，这里就是介绍一个方便微信小程序UI开发的框架：WeUI</p><h1 id="1、什么是Javascript"><a href="#1、什么是Javascript" class="headerlink" title="1、什么是Javascript"></a>1、什么是Javascript</h1><h1 id="1-1、概述"><a href="#1-1、概述" class="headerlink" title="1.1、概述"></a>1.1、概述</h1><p>javaScript是一门世界上最流行的脚本语言<br>Java，JavaScript<br>10天<br>一个合格的后端人员，必须精通JavaScript</p><h1 id="1-2、历史"><a href="#1-2、历史" class="headerlink" title="1.2、历史"></a>1.2、历史</h1><p>见百度</p><p>ECMAScript它可以理解为JavaScript的一个标准<br>最新版本已经到es6版本~<br>但是大部分浏览器还只停留在支持es5代码上！<br>开发环境–线上环境，版本不一致</p><h1 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h1><h2 id="2-1、引入JavaScript"><a href="#2-1、引入JavaScript" class="headerlink" title="2.1、引入JavaScript"></a>2.1、引入JavaScript</h2><p>1、内部标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript"><span class="comment">//....</span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>2、外部引入<br>hj.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;hello,world&quot;</span>);</span><br></pre></td></tr></table></figure><p>test.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--外部引入</span></span><br><span class="line"><span class="comment">       注意：script必须成对出现</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/hj.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--不用显示定义type，也默认就是javaScript--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--script标签内，写Javascript代码--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;script&gt;</span></span><br><span class="line"><span class="comment">        alert(&quot;hello,world&quot;);</span></span><br><span class="line"><span class="comment">    &lt;/script&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--外部引入</span></span><br><span class="line"><span class="comment">        注意：script必须成对出现</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/hj.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--不用显示定义type，也默认就是javaScript--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里也可以存放--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2、基本语法入门"><a href="#2-2、基本语法入门" class="headerlink" title="2.2、基本语法入门"></a>2.2、基本语法入门</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--JavaScript严格区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. 定义变量   变量类型 变量名 = 变量值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> score = <span class="number">1</span> ;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//alert(num)</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. 条件控制</span></span></span><br><span class="line"></span><br><span class="line">        if (score &gt; 60 &amp;&amp; score &lt; 70)&#123;</span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;60~70&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt; <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span>)&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;70~80&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;other&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器必备调试须知：<br><img src="/images/JavaScript-Review/20200508101436683.png" alt="在这里插入图片描述"></p><h2 id="2-3、数据类型"><a href="#2-3、数据类型" class="headerlink" title="2.3、数据类型"></a>2.3、数据类型</h2><p>数值，文本，图形，音频，视频</p><p>变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a </span><br><span class="line"><span class="keyword">var</span> $<span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> s_j</span><br><span class="line"><span class="keyword">var</span> 王者荣耀=<span class="string">&quot;倔强青铜&quot;</span></span><br><span class="line"><span class="comment">//不能以数字开头</span></span><br></pre></td></tr></table></figure><p>number<br>js不区分小数和整数，Number</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123</span><span class="comment">//整数123</span></span><br><span class="line"><span class="number">123.1</span><span class="comment">//浮点数123.1</span></span><br><span class="line"><span class="number">1.123e3</span><span class="comment">//科学计数法</span></span><br><span class="line">-<span class="number">99</span><span class="comment">//负数</span></span><br><span class="line"><span class="literal">NaN</span><span class="comment">//not a number</span></span><br><span class="line"><span class="literal">Infinity</span> <span class="comment">// 表示无限大</span></span><br></pre></td></tr></table></figure><p>字符串<br>‘abc’ “abc”</p><p>布尔值<br>true，false</p><p>逻辑运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 两个都为真，结果为真</span><br><span class="line"></span><br><span class="line">|| 一个为真，结果为真</span><br><span class="line"></span><br><span class="line">! 真即假，假即真</span><br></pre></td></tr></table></figure><p>比较运算符 ！！！重要！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">=</span><br><span class="line"><span class="number">1</span>，<span class="string">&quot;1&quot;</span></span><br><span class="line">== 等于（类型不一样，值一样，也会判断为<span class="literal">true</span>）</span><br><span class="line">=== 绝对等于（类型一样，值一样，结果为<span class="literal">true</span>）</span><br></pre></td></tr></table></figure><p>这是一个JS的缺陷，坚持不要使用 == 比较<br>须知：</p><ul><li>NaN === NaN，这个与所有的数值都不相等，包括自己</li><li>只能通过isNaN（NaN）来判断这个数是否是NaN</li></ul><p>浮点数问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">1</span>/<span class="number">3</span>) === (<span class="number">1</span>-<span class="number">2</span>/<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>尽量避免使用浮点数进行运算，存在精度问题！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span>/<span class="number">3</span>-(<span class="number">1</span>-<span class="number">2</span>/<span class="number">3</span>))&lt;<span class="number">0.00000001</span></span><br></pre></td></tr></table></figure><p>null 和 undefined</p><ul><li>null 空</li><li>undefined 未定义</li></ul><p>数组<br>Java的数组必须是相同类型的对象~，JS中不需要这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证代码的可读性，尽量使用[]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="literal">null</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="comment">//第二种定义方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&#x27;hello&#x27;</span>);</span><br></pre></td></tr></table></figure><p>取数字下标：如果越界了，就会 报undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>对象<br>对象是大括号，数组是中括号</p><blockquote><p>每个属性之间使用逗号隔开，最后一个属性不需要逗号</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person person = new Person(1,2,3,4,5);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name:<span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">age:<span class="number">3</span>,</span><br><span class="line">tags:[<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;java&#x27;</span>,<span class="string">&#x27;web&#x27;</span>,<span class="string">&#x27;...&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取对象值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.name</span><br><span class="line">&gt; <span class="string">&quot;Tom&quot;</span></span><br><span class="line">person.age</span><br><span class="line">&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="2-4、严格检查格式"><a href="#2-4、严格检查格式" class="headerlink" title="2.4、严格检查格式"></a>2.4、严格检查格式</h2><p><img src="/images/JavaScript-Review/20200508105351996.png" alt="在这里插入图片描述"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    前提：IDEA需要设置支持ES6语法</span></span><br><span class="line"><span class="comment">        &#x27;use strict&#x27;;严格检查模式，预防JavaScript的随意性导致产生的一些问题</span></span><br><span class="line"><span class="comment">        必须写在JavaScript的第一行！</span></span><br><span class="line"><span class="comment">        局部变量建议都使用let去定义~</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="meta">        &#x27;use strict&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//全局变量</span></span></span><br><span class="line"><span class="javascript">         <span class="keyword">let</span> i=<span class="number">1</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//ES6 let</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3、数据类型"><a href="#3、数据类型" class="headerlink" title="3、数据类型"></a>3、数据类型</h1><h2 id="3-1、字符串"><a href="#3-1、字符串" class="headerlink" title="3.1、字符串"></a>3.1、字符串</h2><p>1、正常字符串我们使用 单引号，或者双引号包裹<br>2、注意转义字符 \</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\<span class="string">&#x27;</span></span><br><span class="line"><span class="string">\n</span></span><br><span class="line"><span class="string">\t</span></span><br><span class="line"><span class="string">\u4e2d    \u##### Unicode字符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">\x41Ascall字符</span></span><br></pre></td></tr></table></figure><p>3、多行字符串编写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tab 上面 esc下面</span></span><br><span class="line">        <span class="keyword">var</span> msg =</span><br><span class="line">            <span class="string">`hello</span></span><br><span class="line"><span class="string">            world</span></span><br><span class="line"><span class="string">            你好呀</span></span><br><span class="line"><span class="string">            nihao</span></span><br><span class="line"><span class="string">            `</span></span><br></pre></td></tr></table></figure><p>4、模板字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tab 上面 esc下面</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">`你好，<span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>5、字符串长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.length</span><br></pre></td></tr></table></figure><p>6、字符串的可变性，不可变<br><img src="/images/JavaScript-Review/20200508110738649.png" alt="在这里插入图片描述"><br>7、大小写转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，这里是方法，不是属性了</span></span><br><span class="line">student.toUpperCase();</span><br><span class="line">student.toLowerCase();</span><br></pre></td></tr></table></figure><p>8、student.indexof(‘t’)<br>9、substring，从0开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[)</span><br><span class="line">student.substring(<span class="number">1</span>)<span class="comment">//从第一个字符串截取到最后一个字符串</span></span><br><span class="line">student.substring(<span class="number">1</span>,<span class="number">3</span>)<span class="comment">//[1,3)</span></span><br></pre></td></tr></table></figure><h2 id="3-2、数组"><a href="#3-2、数组" class="headerlink" title="3.2、数组"></a>3.2、数组</h2><p>Array可以包含任意的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];<span class="comment">//通过下标取值和赋值</span></span><br></pre></td></tr></table></figure><p>1、长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.length</span><br></pre></td></tr></table></figure><p>注意：假如给arr.lennth赋值，数组大小就会发生变化~，如果赋值过小，元素就会丢失</p><p>2、indexOf，通过元素获得下标索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.indexOf(<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>字符串的”1”和数字 1 是不同的</p><p><strong>3、slice（）</strong>截取Array的一部分，返回的一个新数组，类似于String中substring<br><strong>4、push()，pop()尾部</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push：压入到尾部</span><br><span class="line">pop：弹出尾部的一个元素</span><br></pre></td></tr></table></figure><p><strong>5、unshift(),shift() 头部</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unshift：压入到头部</span><br><span class="line">shift：弹出头部的一个元素</span><br></pre></td></tr></table></figure><p>6、排序sort()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>)[<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;A&quot;</span>]</span><br><span class="line">arr.sort()</span><br><span class="line">(<span class="number">3</span>)[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>]</span><br></pre></td></tr></table></figure><p>7、元素反转reverse()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>)[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>]</span><br><span class="line">arr.reverse()</span><br><span class="line">(<span class="number">3</span>)[<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;A&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>8、concat()</strong><br><img src="/images/JavaScript-Review/20200508153119816.png" alt="在这里插入图片描述"><br>注意：concat()并没有修改数组，只是会返回一个新的数组</p><p>9、连接符join<br>打印拼接数组，使用特定的字符串连接<br><img src="/images/JavaScript-Review/20200508153243846.png" alt="在这里插入图片描述"><br>10、多维数组<br><img src="/images/JavaScript-Review/20200508153447514.png" alt="在这里插入图片描述"></p><p>数组：存储数据（如何存，如何取，方法都可以自己实现！）</p><h2 id="3-3、对象"><a href="#3-3、对象" class="headerlink" title="3.3、对象"></a>3.3、对象</h2><p>若干个键值对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">属性名：属性值，</span><br><span class="line">属性名：属性值，</span><br><span class="line">属性名：属性值</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了一个person对象，它有四个属性</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name:<span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">age:<span class="number">3</span>,</span><br><span class="line">email:<span class="string">&quot;123456798@QQ.com&quot;</span>,</span><br><span class="line">score:<span class="number">66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Js中对象，{…}表示一个对象，建制对描述属性xxx：xxx，多个属性之间用逗号隔开，最后一个属性不加逗号！<br>JavaScript中的所有的键都是字符串，值是任意对象！<br>1、对象赋值<br><img src="/images/JavaScript-Review/20200508155833832.png" alt="在这里插入图片描述"><br>2、使用一个不存在的对象属性，不会报错！undefined<br><img src="/images/JavaScript-Review/20200508155917394.png" alt="在这里插入图片描述"><br>3、动态的删减属性，通过delete删除对象的属性<br><img src="/images/JavaScript-Review/20200508160429505.png" alt="在这里插入图片描述"><br>4、动态的添加，直接给新的属性添加值即可<br><img src="/images/JavaScript-Review/20200508160409465.png" alt="在这里插入图片描述"><br>5、判断属性值是否在这个对象中！xxx in xxx<br><img src="/images/JavaScript-Review/20200508160704412.png" alt="在这里插入图片描述"><br>6、判断一个属性是否是这个对象自身拥有的 hasOwnProperty()<br><img src="/images/JavaScript-Review/20200508160950801.png" alt="在这里插入图片描述"></p><h2 id="3-4、流程控制"><a href="#3-4、流程控制" class="headerlink" title="3.4、流程控制"></a>3.4、流程控制</h2><p>if判断<br><img src="/images/JavaScript-Review/20200508161158507.png" alt="在这里插入图片描述"></p><p>while循环，避免程序死循环<br><img src="/images/JavaScript-Review/20200508161549241.png" alt="在这里插入图片描述"><br>for循环<br><img src="/images/JavaScript-Review/20200508161625832.png" alt="在这里插入图片描述"><br>forEach循环</p><blockquote><p>ES5.1特性</p></blockquote><p><img src="/images/JavaScript-Review/20200508162100917.png" alt="在这里插入图片描述"><br>for …in——-下标<br><img src="/images/JavaScript-Review/20200508162209421.png" alt="在这里插入图片描述"></p><h2 id="3-5、Map和Set"><a href="#3-5、Map和Set" class="headerlink" title="3.5、Map和Set"></a>3.5、Map和Set</h2><blockquote><p>ES6的新特性~</p></blockquote><p>Map<br><img src="/images/JavaScript-Review/20200508163109596.png" alt="在这里插入图片描述"><br>Set：无序不重复的集合(有重复的话，就会自动去掉！)<br><img src="/images/JavaScript-Review/20200508163211654.png" alt="在这里插入图片描述"></p><h2 id="3-6、iterator"><a href="#3-6、iterator" class="headerlink" title="3.6、iterator"></a>3.6、iterator</h2><blockquote><p>es6新特性</p></blockquote><p>作业：使用iterator来遍历迭代我们Map，Set！</p><p>遍历数组</p><p><img src="/images/JavaScript-Review/2020050816410825.png" alt="在这里插入图片描述"><br>遍历Map<br><img src="/images/JavaScript-Review/20200508164125573.png" alt="在这里插入图片描述"><br>遍历set<br><img src="/images/JavaScript-Review/20200508164144469.png" alt="在这里插入图片描述"></p><h1 id="4、函数"><a href="#4、函数" class="headerlink" title="4、函数"></a>4、函数</h1><h2 id="4-1、定义函数"><a href="#4-1、定义函数" class="headerlink" title="4.1、定义函数"></a>4.1、定义函数</h2><blockquote><p>定义方式一</p></blockquote><p>绝对值函数<br><img src="/images/JavaScript-Review/2020050818170197.png" alt="在这里插入图片描述"><br>一旦执行到return代表函数结束，返回结果！<br>如果没有执行return，函数执行完也会返回结果，结果就是undefined</p><blockquote><p>定义方式二</p></blockquote><p><img src="/images/JavaScript-Review/20200508182120582.png" alt="在这里插入图片描述"><br>function(x){…}这是一个匿名函数。但是可以吧结果赋值给abs，通过abs就可以调用函数！<br>方式一和方式二等价！</p><blockquote><p>调用函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">10</span>)<span class="comment">//10</span></span><br><span class="line">abs(-<span class="number">10</span>) <span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>参数问题：javaScript可以传任意个参数，也可以不传递参数~<br>参数进来是否存在问题？<br>假设不存在参数，如何规避？<br><img src="/images/JavaScript-Review/20200508182908571.png" alt="在这里插入图片描述"></p><blockquote><p>arguments</p></blockquote><p>arguments是一个JS免费赠送的关键字；<br>代表，传递进来的所有参数，是一个数组！<br><img src="/images/JavaScript-Review/20200508183337762.png" alt="在这里插入图片描述"><br>问题：arguments包含所有的参数，我们有时候想使用多余的参数来进行附加操作。需要排除已有参数~</p><blockquote><p>rest</p></blockquote><p>以前：<br><img src="/images/JavaScript-Review/20200508183752806.png" alt="在这里插入图片描述"></p><p>ES6引入的新特性，获取除了已经定义的参数之外的所有参数~…<br><img src="/images/JavaScript-Review/20200508183918899.png" alt="在这里插入图片描述"><br>rest参数只能写在最后面，必须用…标识。</p><h2 id="4-2、变量的作用域"><a href="#4-2、变量的作用域" class="headerlink" title="4.2、变量的作用域"></a>4.2、变量的作用域</h2><p>在javascript中，var定义变量实际是有作用域的。<br>假设在函数体中声明，则在函数体外不可以使用<del>（非要想实现的话，可以研究一下==闭包==）<br><img src="/images/JavaScript-Review/202005081843310.png" alt=" "><br>如果两个函数使用了相同的变量名，只要在函数内部就不冲突<br><img src="/images/JavaScript-Review/20200508213017794.png" alt="在这里插入图片描述"><br>内部函数可以访问外部函数的成员，反之则不行<br><img src="/images/JavaScript-Review/2020050821304022.png" alt="在这里插入图片描述"><br>假设，内部函数变量和外部函数变量，重名！<br><img src="/images/JavaScript-Review/20200508214742767.png" alt="在这里插入图片描述"><br>假设在JavaScript中，函数查找变量从自身函数开始</del>， 由“内”向“外”查找，假设外部存在这个同名的函数变量，则内部函数会屏蔽外部函数的变量。</p><blockquote><p>提升变量的作用域</p></blockquote><p><img src="/images/JavaScript-Review/20200508215241301.png" alt="在这里插入图片描述"><br>结果：x undefined<br>说明：js执行引擎，自动提升了y的声明，但是不会提升变量y的赋值；<br><img src="/images/JavaScript-Review/20200508215909640.png" alt="在这里插入图片描述"><br>这个是在javascript建立之初就存在的特性。 养成规范：所有 的变量定义都放在函数的头部，不要乱放，便于代码维护；<br><img src="/images/JavaScript-Review/2020050822470141.png" alt="在这里插入图片描述"></p><blockquote><p>全局变量</p></blockquote><p><img src="/images/JavaScript-Review/20200508224905458.png" alt="在这里插入图片描述"></p><p>全局对象window<br><img src="/images/JavaScript-Review/20200508225326543.png" alt="在这里插入图片描述"></p><p>alert() 这个函数本身也是一个window的变量；<br><img src="/images/JavaScript-Review/20200508225810801.png" alt="在这里插入图片描述"><br>javascript实际上只有一个全局作用域，任何变量（函数也可以视为变量），假设没有在函数作用范围内找到，就会向外查找，如果在全局作用域都没有找到，就会报错 RefrenceError</p><blockquote><p>规范</p></blockquote><p>由于我们的所有变量都会绑定到window上，。如果不同的js文件，使用了相同的全局变量，就会产生冲突—&gt;如何减少这样的冲突？<br><img src="/images/JavaScript-Review/20200508230620266.png" alt="在这里插入图片描述"><br>把自己的代码全部放入自己定义的唯一空间名字中，降低全局命名冲突问题~<br>jQuery中就是使用的该方法：jQuery.name，简便写法：**$()**</p><blockquote><p>局部作用域</p></blockquote><p><img src="/images/JavaScript-Review/20200508231056855.png" alt="在这里插入图片描述"><br>ES6的let关键字，解决了局部作用域冲突的问题！<br><img src="/images/JavaScript-Review/20200508231207856.png" alt="在这里插入图片描述"><br>建议大家都用let去定义局部作用域的变量；</p><h2 id="4-3、常量"><a href="#4-3、常量" class="headerlink" title="4.3、常量"></a>4.3、常量</h2><p>在ES6之前，怎么定义常量：只有用全部大写字母命名的变量就是常量；建议不要修改这样的值。<br><img src="/images/JavaScript-Review/20200508231525623.png" alt="在这里插入图片描述"><br>在ES6引入了常量关键字 const<br><img src="/images/JavaScript-Review/20200508232049107.png" alt="在这里插入图片描述"></p><h2 id="4-4、方法"><a href="#4-4、方法" class="headerlink" title="4.4、方法"></a>4.4、方法</h2><blockquote><p>定义方法</p></blockquote><p>方法就是把函数放在对象的里面，对象只有两个东西：属性和方法<br><img src="/images/JavaScript-Review/20200508232559873.png" alt="在这里插入图片描述"><br>this.代表什么？拆开上面的代码看看<br><img src="/images/JavaScript-Review/20200508232827102.png" alt="在这里插入图片描述"><br>this是无法指向的，是默认指向调用它的那个对象的；</p><blockquote><p>apply</p></blockquote><p>在js中可以控制this指向<br><img src="/images/JavaScript-Review/image-20201208205004127.png" alt="image-20201208205004127"></p><h1 id="5、内部对象"><a href="#5、内部对象" class="headerlink" title="5、内部对象"></a>5、内部对象</h1><blockquote><p>标准对象</p></blockquote><p><img src="/images/JavaScript-Review/20200508233500524.png" alt="在这里插入图片描述"></p><h2 id="5-1、Date"><a href="#5-1、Date" class="headerlink" title="5.1、Date"></a>5.1、Date</h2><p><strong>基本使用</strong><br><img src="/images/JavaScript-Review/2020050823390552.png" alt="在这里插入图片描述"><br>转换<br><img src="/images/JavaScript-Review/20200508233954136.png" alt="在这里插入图片描述"></p><h2 id="5-2、JSON"><a href="#5-2、JSON" class="headerlink" title="5.2、JSON"></a>5.2、JSON</h2><blockquote><p>JSON是什么</p></blockquote><p><img src="/images/JavaScript-Review/20200508234238700.png" alt="在这里插入图片描述"><br>在javascript中，一切皆为对象，任何js支持的类型都可以用JSON表示<br>格式</p><ul><li>对象都用{}</li><li>数组都用[]</li><li>所有的键值对 都是用key:value</li></ul><p>JSON字符串和js对象转化<br><img src="/images/JavaScript-Review/20200508234804502.png" alt="在这里插入图片描述"><br>很多人搞不清楚，JS对象和JSON的区别</p><p><img src="/images/JavaScript-Review/20200508235017515.png" alt="在这里插入图片描述"></p><h2 id="5-3、AJAX"><a href="#5-3、AJAX" class="headerlink" title="5.3、AJAX"></a>5.3、AJAX</h2><ul><li>原生的js写法 xhr异步请求</li><li>jQuery封装好的方法$(#name).ajax(“”)</li><li>axios请求</li></ul><h1 id="6、面向对象编程"><a href="#6、面向对象编程" class="headerlink" title="6、面向对象编程"></a>6、面向对象编程</h1><blockquote><p>原型对象<br>javascript、java、c#——面向对象；但是javascript有些区别！</p></blockquote><ul><li>类：模板</li><li>对象：具体实例</li></ul><p>在javascript中，需要大家转换一下思维方式！<br>原型：<br><img src="/images/JavaScript-Review/20200509210303742.png" alt="在这里插入图片描述"><br><img src="/images/JavaScript-Review/20200509210627825.png" alt="在这里插入图片描述"></p><blockquote><p>class集继承</p></blockquote><p>class关键字，是在ES6引入的<br>1、定义一个类、属性、方法<br><img src="/images/JavaScript-Review/20200509210756344.png" alt="在这里插入图片描述"><br>2、继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//ES6之后========================</span></span><br><span class="line"><span class="comment">//定义一个学生的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoStudent</span> <span class="keyword">extends</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name,grade</span>)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(name);</span><br><span class="line"><span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;我是一名小学生&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> xiaohong = <span class="keyword">new</span> XiaoStudent(<span class="string">&quot;xiaohong&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>本质：查看对象原型<br><img src="/images/JavaScript-Review/20200509211811667.png" alt="在这里插入图片描述"></p><blockquote><p>原型链</p></blockquote><p><em>proto</em>:<br><img src="/images/JavaScript-Review/20200509212115371.png" alt="在这里插入图片描述"></p><h1 id="7、操作BOM对象（重点）"><a href="#7、操作BOM对象（重点）" class="headerlink" title="7、操作BOM对象（重点）"></a>7、操作BOM对象（重点）</h1><blockquote><p>浏览器介绍</p></blockquote><p>javascript和浏览器关系？<br>BOM：浏览器对象模型</p><ul><li>IE6~11</li><li>Chrome</li><li>Safari</li><li>FireFox（Linux默认）</li><li>Opera</li></ul><p>三方</p><ul><li>QQ浏览器</li><li>360浏览器</li></ul><blockquote><p>window</p></blockquote><p>window代表浏览器窗口<br><img src="/images/JavaScript-Review/20200509224733766.png" alt="在这里插入图片描述"></p><blockquote><p>Navigator（不建议使用）</p></blockquote><p>Navigator封装了浏览器的信息<br><img src="/images/JavaScript-Review/20200509225010877.png" alt="在这里插入图片描述"><br>大多数时候，我们不会使用navigator对象，因为会被认为修改!<br>不建议使用这些属性来判断和编写代码</p><blockquote><p>screen</p></blockquote><p>代表屏幕尺寸</p><p><img src="/images/JavaScript-Review/20200509225316614.png" alt="在这里插入图片描述"></p><blockquote><p>location(重要)</p></blockquote><p>location代表当前页面的URL信息<br><img src="/images/JavaScript-Review/20200509225614305.png" alt="在这里插入图片描述"></p><blockquote><p>document（内容DOM）</p></blockquote><p>document代表当前的页面，HTML DOM文档树<br><img src="/images/JavaScript-Review/20200509225911170.png" alt="在这里插入图片描述"><br>获取具体的文档树节点<br><img src="/images/JavaScript-Review/20200509225947396.png" alt="在这里插入图片描述"><br>获取cookie<br><img src="/images/JavaScript-Review/20200509230037645.png" alt="在这里插入图片描述"><br>劫持cookie原理<br><a href="http://www.taobao.com/">www.taobao.com</a><br><img src="/images/JavaScript-Review/2020050923025532.png" alt="在这里插入图片描述"><br>服务器端可以设置cookie为httpOnly</p><blockquote><p>history（不建议使用 ）</p></blockquote><p>history代表浏览器的历史记录<br><img src="/images/JavaScript-Review/20200509230639949.png" alt="在这里插入图片描述"></p><h1 id="8、操作DOM对象（重点）"><a href="#8、操作DOM对象（重点）" class="headerlink" title="8、操作DOM对象（重点）"></a>8、操作DOM对象（重点）</h1><p>DOM：文档对象模型</p><blockquote><p>核心</p></blockquote><p>浏览器网页就是一个Dom树形结构！</p><ul><li>更新：更新Dom节点</li><li>遍历Dom节点：得到Dom节点</li><li>删除：删除一个Dom节点</li><li>添加：添加一个新的节点</li></ul><p>要操作一个Dom节点，就必须要先获得这个Dom节点</p><blockquote><p>获得Dom节点</p></blockquote><p><img src="/images/JavaScript-Review/20200509231806822.png" alt="在这里插入图片描述"><br>这是原生代码，之后我们尽量都使用jQuery();</p><blockquote><p>更新节点</p></blockquote><p><img src="/images/JavaScript-Review/20200509232232560.png" alt="在这里插入图片描述"><br>操作文本<br><img src="/images/JavaScript-Review/20200509232256674.png" alt="在这里插入图片描述"><br>操作css<br><img src="/images/JavaScript-Review/20200509232439513.png" alt="在这里插入图片描述"></p><blockquote><p>删除节点</p></blockquote><p>删除节点的步骤：先获取父节点，再通过父节点删除自己<br><img src="/images/JavaScript-Review/20200509232903448.png" alt="在这里插入图片描述"><br>注意：删除多个节点的时候，children是在时刻变化的，删除节点的时候一定要注意。</p><blockquote><p>插入节点</p></blockquote><p>我们获得了某个Dom节点，假设这个dom节点是空的，我们通过innerHTML就可以增加一个元素了，但是这个Dom节点已经存在元素了，我们就不能这么干了！会产生覆盖</p><p>追加<br><img src="/images/JavaScript-Review/20200509233556254.png"></p><p>效果：<br><img src="/images/JavaScript-Review/2020050923363290.png" alt="在这里插入图片描述"></p><blockquote><p>创建一个新的标签</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>);<span class="comment">//已经存在的节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//通过JS创建一个新的节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> newP = <span class="built_in">document</span>.creatElement(<span class="string">&#x27;p&#x27;</span>);<span class="comment">//创建一个p标签</span></span></span><br><span class="line"><span class="javascript">    newP.id = <span class="string">&#x27;newP&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    newP.innerText = <span class="string">&#x27;Hello,Kuangshen&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//创建一个标签节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myScript = <span class="built_in">document</span>.creatElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    myScript.setAttribute(<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;text/javascript&#x27;</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//可以创建一个style标签</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> myStyle = <span class="built_in">document</span>.creatElement(<span class="string">&#x27;style&#x27;</span>);<span class="comment">//创建了一个空style标签</span></span></span><br><span class="line"><span class="javascript">    myStyle.setAttribute(<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;text/css&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    myStyle.innerHTML = <span class="string">&#x27;body&#123;background-color:chartreuse;&#125;&#x27;</span>;<span class="comment">//设置标签内容</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(myStyle);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>insertBefore</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ee = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ee&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="comment">//要包含的节点.insertBefore(newNode,targetNode)</span></span><br><span class="line">list.insertBefore(js,ee);</span><br></pre></td></tr></table></figure><h1 id="9、操作表单"><a href="#9、操作表单" class="headerlink" title="9、操作表单"></a>9、操作表单</h1><blockquote><p>表单是什么？form—–DOM树</p></blockquote><ul><li>文本框—-text</li><li>下拉框—-select</li><li>单选框—-radio</li><li>多选框—-checkbox</li><li>隐藏域—-hidden</li><li>密码框—-password</li><li>…</li></ul><p>表单的目的提交信息</p><blockquote><p>获得要提交的信息</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span> = <span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--多选框的值就是定义好的value--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;radio&quot;</span> <span class="attr">name</span> = <span class="string">&quot;sex&quot;</span> <span class="attr">value</span> = <span class="string">&quot;man&quot;</span> <span class="attr">id</span> = <span class="string">&quot;boy&quot;</span>/&gt;</span>男</span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;radio&quot;</span> <span class="attr">name</span> = <span class="string">&quot;sex&quot;</span> <span class="attr">value</span> = <span class="string">&quot;woman&quot;</span> <span class="attr">id</span> = <span class="string">&quot;girl&quot;</span>/&gt;</span>女</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_text = <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> boy_radio = <span class="built_in">document</span>.getElementById(<span class="string">&quot;boy&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> girl_radio = <span class="built_in">document</span>.getElementById(<span class="string">&quot;girl&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//得到输入框的值</span></span></span><br><span class="line">        input_text.value </span><br><span class="line"><span class="javascript">        <span class="comment">//修改输入框的值</span></span></span><br><span class="line"><span class="javascript">        input_text.value  = <span class="string">&quot;value&quot;</span>;</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">//对于单选框，多选框等等固定的值，boy_radio.value只能取到当前的值</span></span></span><br><span class="line"><span class="javascript">        boy_radio.checked;<span class="comment">//查看返回的结果，是否为true，如果为true，则被选中。</span></span></span><br><span class="line"><span class="javascript">        girl_radio.checked = <span class="literal">true</span>;<span class="comment">//赋值</span></span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>提交表单。md5加密密码，表单优化</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--MD5加密工具类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--表单绑定提交事件</span></span><br><span class="line"><span class="comment">οnsubmit= 绑定一个提交检测的函数，true，false</span></span><br><span class="line"><span class="comment">将这个结果返回给表单，使用onsubmit接收</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">method</span> = <span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span> = <span class="string">&quot;return aaa()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span> = <span class="string">&quot;username&quot;</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--没有name的输入框，就不会进行提交--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span> = <span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;hidden&quot;</span> <span class="attr">id</span> = <span class="string">&quot;md5-password&quot;</span> <span class="attr">name</span> = <span class="string">&quot;password&quot;</span>&gt;</span> </span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!--绑定事件 onclick 被点击--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line">                alert(1);</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> username = <span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> md5pwd = <span class="built_in">document</span>.getElementById(<span class="string">&quot;md5-password&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="comment">//pwd.value = md5(pwd,value);</span></span></span><br><span class="line">                md5pwd.value = mad5(pwd.value);</span><br><span class="line"><span class="javascript">                <span class="comment">//可以校验判断表单内容，true就是通过提交，false就是阻止提交</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="10、jQuery"><a href="#10、jQuery" class="headerlink" title="10、jQuery"></a>10、jQuery</h1><p>javaScript和jQuery的关系？</p><p>jQuery库，里面存在大量的JavaScript函数</p><blockquote><p>获取jQuery</p></blockquote><p><img src="/images/JavaScript-Review/2020051021540896.png" alt="在这里插入图片描述"></p><p><strong>公式：$(selector).action()</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span> = <span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span> = <span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;lib/jquery-3.4.1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span> = <span class="string">&quot;test-jquery&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//选择器就是css选择器</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">&#x27;#test-jquery&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&#x27;hello,jQuery!&#x27;</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>选择器</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原生js，选择器少，麻烦不好记</span></span><br><span class="line"><span class="comment">//标签</span></span><br><span class="line"><span class="built_in">document</span>.getElementByTagName();</span><br><span class="line"><span class="comment">//id</span></span><br><span class="line"><span class="built_in">document</span>.getElementById();</span><br><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="built_in">document</span>.getElementByClassName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//jQuery css中的选择器它全部都能用！</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).click();<span class="comment">//标签选择器</span></span><br><span class="line">$(<span class="string">&#x27;#id1&#x27;</span>).click();<span class="comment">//id选择器</span></span><br><span class="line">$(<span class="string">&#x27;.class1&#x27;</span>).click;<span class="comment">//class选择器</span></span><br></pre></td></tr></table></figure><p>文档工具站：<a href="http://jquery.cuishifeng.cn/">http://jquery.cuishifeng.cn/</a></p><blockquote><p>事件</p></blockquote><p>鼠标事件、键盘事件，其他事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mousedown()(jQuery)----按下</span><br><span class="line">mouseenter()(jQuery)</span><br><span class="line">mouseleave()(jQuery)</span><br><span class="line">mousemove()(jQuery)----移动</span><br><span class="line">mouseout()(jQuery)</span><br><span class="line">mouseover()(jQuery)</span><br><span class="line">mouseup()(jQuery)</span><br><span class="line"><span class="number">1234567</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang = <span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset = <span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">        &lt;script src=<span class="string">&quot;lib/jquery-3.4.1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #divMove&#123;</span><br><span class="line">                width:500px;</span><br><span class="line">                height:500px;</span><br><span class="line">                border:1px solid red;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!--要求：获取鼠标当前的一个坐标--&gt;</span><br><span class="line">        mouse：&lt;span id = <span class="string">&quot;mouseMove&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">        &lt;div id = <span class="string">&quot;divMove&quot;</span>&gt;</span><br><span class="line">            在这里移动鼠标试试</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">        <span class="comment">//当网页元素加载完毕之后，响应事件</span></span><br><span class="line">            <span class="comment">//$(document).ready(function()&#123;&#125;)</span></span><br><span class="line">            $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                $(<span class="string">&#x27;#divMove&#x27;</span>).mousemove(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">                    $(<span class="string">&#x27;#mouseMove&#x27;</span>).text(<span class="string">&#x27;x:&#x27;</span>+e.pageX+<span class="string">&quot;y:&quot;</span>+e.pageY)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>操作DOM</p></blockquote><p>节点文本操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[name=python]&#x27;</span>).text();<span class="comment">//获得值</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul li[name=python]&#x27;</span>).text(<span class="string">&#x27;设置值&#x27;</span>);<span class="comment">//设置值</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul&#x27;</span>).html();<span class="comment">//获得值</span></span><br><span class="line">$(<span class="string">&#x27;#test-ul&#x27;</span>).html(<span class="string">&#x27;&lt;strong&gt;123&lt;/strong&gt;&#x27;</span>);<span class="comment">//设置值</span></span><br></pre></td></tr></table></figure><p>CSS的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[name=python]&#x27;</span>).css(&#123;<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><p>元素的显示和隐藏，：本质display:none</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#test-ul li[name=python]&#x27;</span>).show();</span><br><span class="line">$(<span class="string">&#x27;#test-ul li[name=python]&#x27;</span>).hide();</span><br><span class="line">$(<span class="string">&#x27;#test-ul li[name=python]&#x27;</span>).toggle();<span class="comment">//切换</span></span><br></pre></td></tr></table></figure><p>娱乐测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).width()</span><br><span class="line">$(<span class="built_in">window</span>).height()</span><br></pre></td></tr></table></figure><p>未来ajax()；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#form&#x27;</span>).ajax()</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;<span class="attr">url</span>:<span class="string">&quot;test.html&quot;</span>,<span class="attr">context</span>:<span class="built_in">document</span>.body,<span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="built_in">this</span>).addClass(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>小技巧</p></blockquote><p>1、如何巩固JS（看jQuery源码，看游戏源码！）</p><p>2、巩固HTML、CSS（扒网站，全部down下来，然后对应修改看效果~） </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0、前端知识体系&quot;&gt;&lt;a href=&quot;#0、前端知识体系&quot; class=&quot;headerlink&quot; title=&quot;0、前端知识体系&quot;&gt;&lt;/a&gt;0、前端知识体系&lt;/h1&gt;&lt;p&gt;想要成为真正的“互联网Java全栈工程师”还有很长的一段路要走，其中前端是绕不开的一门必修课</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
