<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jungle</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-17T08:07:14.387Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jungle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剖析vue.js内部运行机制09</title>
    <link href="http://example.com/2021/08/24/vue2-core09/"/>
    <id>http://example.com/2021/08/24/vue2-core09/</id>
    <published>2021-08-24T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:14.387Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自<a href="https://www.kancloud.cn/sllyli/vuejs">看云</a>《剖析vue.js内部运行机制》</p><h2 id="总结-amp-常见问题解答"><a href="#总结-amp-常见问题解答" class="headerlink" title="总结 &amp; 常见问题解答"></a>总结 &amp; 常见问题解答</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本小册的第一节中，笔者对 Vue.js 内部运行机制做了一个全局的概览，当时通过下面这张图把 Vue.js 拆分成一个一个小模块来介绍，之后通过这一系列小节的学习，相信大家已经对 Vue.js 内部的原理有了一个更进一步的了解，对这张图也再也不会感觉到那么陌生。</p><p><img src="https://img.kancloud.cn/01/db/01db136b4380b1804c072899e92daa3d_1752x1216.gif" alt="img"></p><p>每个小节中的代码都是笔者根据 Vue.js 原理单独抽离出来写成的 Demo，大家可以在我的 <a href="https://github.com/answershuto">Gtihub</a> 上查看完整的代码 (见 <a href="https://github.com/answershuto/VueDemo">VueDemo</a> 项目)。</p><p>本小册对 Vue.js 原理进行了初步的介绍，希望能够起到一个抛砖引玉的作用，读者读完以后，可以利用这些基础对 Vue.js 进行一个更加深入的探索，相信会有更大的收获。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>怎么实现 <code>this._test</code> 改变而不是 <code>this._data.test</code> 改变触发更新？</li></ol><p>答：其实这中间有一个<strong>代理</strong>的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_proxy(options.data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_proxy</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(that, key, &#123;</span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> that._data[key];</span><br><span class="line">            &#125;,</span><br><span class="line">            set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                that._data[key] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质就是通过 <code>Object.defineProperty</code> 使在访问 <code>this</code> 上的某属性时从 <code>this._data</code> 中读取（写入）。</p><ol><li>能不能将依赖收集中讲到的 <code>dep.addSub(Dep.target)</code> 改成 <code>dep.addSub(new Watcher())</code>呢？</li></ol><p>为了便于读者理解这部分内容，我将代码做了简化，实际上一个 <code>Watcher</code> 对象可能会在多个 <code>Dep</code> 中，并不是每次 <code>addSub</code> 都是一个新的 <code>Watcher</code> 对象，需依赖 <code>Dep.target</code> 进行收集（实际上 <code>Dep.target</code> 也是通过 <code>Watcher</code> 对象的 <code>get</code> 方法调用 <code>pushTarget</code> 将自身赋值给 <code>Dep.target</code>）。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从 2017 年 12 月开始写这本小册到现在差不多 2 个月的时间，虽说之前写过类似的内容，但是将 Vue.js 源码抽离成一个一个 Demo 还是花了很多时间，对于这本小册也是前前后后改了好几次才让自己满意。</p><p>因为读者的基础不一致，而小册的定位是偏向于对新手读者更加友好，所以我尽量用更加浅显易懂的方式去写这本小册的内容。希望大家可以通过这本小册初步掌握 Vue.js 的原理，掌握这些原理以后再去尝试阅读 <a href="https://github.com/vuejs/vue">Vue.js 源码</a>，相信会事半功倍，也会对 Vue.js 有更深一层的理解。</p><p>End</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章转载自&lt;a href=&quot;https://www.kancloud.cn/sllyli/vuejs&quot;&gt;看云&lt;/a&gt;《剖析vue.js内部运行机制》&lt;/p&gt;
&lt;h2 id=&quot;总结-amp-常见问题解答&quot;&gt;&lt;a href=&quot;#总结-amp-常见问题解答&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制08</title>
    <link href="http://example.com/2021/08/21/vue2-core08/"/>
    <id>http://example.com/2021/08/21/vue2-core08/</id>
    <published>2021-08-21T07:17:49.000Z</published>
    <updated>2021-09-17T08:11:05.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex-状态管理的工作原理"><a href="#Vuex-状态管理的工作原理" class="headerlink" title="Vuex 状态管理的工作原理"></a>Vuex 状态管理的工作原理</h2><h2 id="为什么要使用-Vuex"><a href="#为什么要使用-Vuex" class="headerlink" title="为什么要使用 Vuex"></a>为什么要使用 Vuex</h2><p>当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。</p><p><img src="https://img.kancloud.cn/3c/39/3c3996a7b149957fb5aab814bca00147_632x361.gif" alt="img"></p><p>这个时候，我们就需要用到我们的状态管理工具 Vuex 了。Vuex 是一个专门为 Vue.js 框架设计的、专门用来对于 Vue.js 应用进行状态管理的库。它借鉴了 Flux、redux 的基本思想，将状态抽离到全局，形成一个 Store。因为 Vuex 内部采用了 new Vue 来将 Store 内的数据进行「响应式化」，所以 Vuex 是一款利用 Vue 内部机制的库，与 Vue 高度契合，与 Vue 搭配使用显得更加简单高效，但缺点是不能与其他的框架（如 react）配合使用。</p><p>本节将简单介绍 Vuex 最核心的内部机制，起个抛砖引玉的作用，想了解更多细节可以参考笔者 <a href="https://github.com/answershuto">Github</a> 上的另一篇文章 <a href="https://github.com/answershuto/learnVue/blob/master/docs/Vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.MarkDown">《Vuex源码解析》</a>或者直接阅读 <a href="https://github.com/vuejs/vuex">Vuex源码</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Vue.js 提供了一个 <code>Vue.use</code> 的方法来安装插件，内部会调用插件提供的 <code>install</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex);</span><br></pre></td></tr></table></figure><p>所以我们的插件需要提供一个 <code>install</code> 方法来安装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> install (_Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;);</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采用 <code>Vue.mixin</code> 方法将 <code>vuexInit</code> 方法混淆进 <code>beforeCreate</code> 钩子中，并用 <code>Vue</code> 保存 Vue 对象。那么 <code>vuexInit</code> 究竟实现了什么呢？</p><p>我们知道，在使用 Vuex 的时候，我们需要将 <code>store</code> 传入到 Vue 实例中去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将store放入Vue创建时的option中*/</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    store</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是我们却在每一个 vm 中都可以访问该 <code>store</code>，这个就需要靠 <code>vuexInit</code> 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">this</span>.$options;</span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store = options.store;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store = options.parent.$store;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为之前已经用<code>Vue.mixin</code> 方法将 <code>vuexInit</code> 方法混淆进 <code>beforeCreate</code> 钩子中，所以每一个 vm 实例都会调用 <code>vuexInit</code> 方法。</p><p>如果是根节点（<code>$options</code>中存在 <code>store</code> 说明是根节点），则直接将 <code>options.store</code> 赋值给 <code>this.$store</code>。否则则说明不是根节点，从父节点的 <code>$store</code> 中获取。</p><p>通过这步的操作，我们已经可以在任意一个 vm 中通过 <code>this.$store</code> 来访问 <code>Store</code> 的实例啦～</p><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="数据的响应式化"><a href="#数据的响应式化" class="headerlink" title="数据的响应式化"></a>数据的响应式化</h3><p>首先我们需要在 <code>Store</code> 的构造函数中对 <code>state</code> 进行「响应式化」。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        data: &#123;</span><br><span class="line">            $$state: <span class="built_in">this</span>.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟悉「响应式」的同学肯定知道，这个步骤以后，<code>state</code> 会将需要的依赖收集在 <code>Dep</code> 中，在被修改时更新对应视图。我们来看一个小例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalData = &#123;</span><br><span class="line">    d: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            $$state: &#123;</span><br><span class="line">                globalData</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modify */</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    globalData.d = <span class="string">&#x27;hi~&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Vue.prototype.globalData = globalData;</span><br></pre></td></tr></table></figure><p>任意模板中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123;globalData.d&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上述代码在全局有一个 <code>globalData</code>，它被传入一个 <code>Vue</code> 对象的 <code>data</code> 中，之后在任意 Vue 模板中对该变量进行展示，因为此时 <code>globalData</code> 已经在 Vue 的 <code>prototype</code> 上了所以直接通过 <code>this.prototype</code> 访问，也就是在模板中的 <code>&#123;&#123;globalData.d&#125;&#125;</code>。此时，<code>setTimeout</code> 在 1s 之后将 <code>globalData.d</code> 进行修改，我们发现模板中的 <code>globalData.d</code> 发生了变化。其实上述部分就是 Vuex 依赖 Vue 核心实现数据的“响应式化”。</p><p>讲完了 Vuex 最核心的通过 Vue 进行数据的「响应式化」，接下来我们再来介绍两个 <code>Store</code> 的 API。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vuex-状态管理的工作原理&quot;&gt;&lt;a href=&quot;#Vuex-状态管理的工作原理&quot; class=&quot;headerlink&quot; title=&quot;Vuex 状态管理的工作原理&quot;&gt;&lt;/a&gt;Vuex 状态管理的工作原理&lt;/h2&gt;&lt;h2 id=&quot;为什么要使用-Vuex&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制07</title>
    <link href="http://example.com/2021/08/17/vue2-core07/"/>
    <id>http://example.com/2021/08/17/vue2-core07/</id>
    <published>2021-08-17T07:17:49.000Z</published>
    <updated>2021-09-17T08:06:36.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="批量异步更新策略及nextTick原理"><a href="#批量异步更新策略及nextTick原理" class="headerlink" title="批量异步更新策略及nextTick原理"></a>批量异步更新策略及nextTick原理</h2><h2 id="为什么要异步更新"><a href="#为什么要异步更新" class="headerlink" title="为什么要异步更新"></a>为什么要异步更新</h2><p>通过前面几个章节我们介绍，相信大家已经明白了 Vue.js 是如何在我们修改 <code>data</code> 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“<code>setter -&gt; Dep -&gt; Watcher -&gt; patch -&gt; 视图</code>”的过程。</p><p>假设我们有如下这么一种情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div @click=<span class="string">&quot;handleClick&quot;</span>&gt;click&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            number: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.number++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们按下 click 按钮的时候，<code>number</code> 会被循环增加1000次。</p><p>那么按照之前的理解，每次 <code>number</code> 被 +1 的时候，都会触发 <code>number</code> 的 <code>setter</code> 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。</p><p>Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 <code>setter</code> 方法后，对应的 <code>Watcher</code> 对象其实会被 <code>push</code> 进一个队列 <code>queue</code> 中，在下一个 tick 的时候将这个队列 <code>queue</code> 全部拿出来 <code>run</code>（ <code>Watcher</code> 对象的一个方法，用来触发 <code>patch</code> 操作） 一遍。</p><p><img src="https://img.kancloud.cn/84/56/8456483469198b4e046cd583fc847d16_350x404.gif" alt="img"></p><p>那么什么是下一个 tick 呢？</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>Vue.js 实现了一个 <code>nextTick</code> 函数，传入一个 <code>cb</code> ，这个 <code>cb</code> 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 <code>cb</code> 事件。</p><p>因为目前浏览器平台并没有实现 <code>nextTick</code> 方法，所以 Vue.js 源码中分别用 <code>Promise</code>、<code>setTimeout</code>、<code>setImmediate</code> 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。</p><p>笔者用 <code>setTimeout</code> 来模拟这个方法，当然，真实的源码中会更加复杂，笔者在小册中只讲原理，有兴趣了解源码中 <code>nextTick</code> 的具体实现的同学可以参考<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L90">next-tick</a>。</p><p>首先定义一个 <code>callbacks</code> 数组用来存储 <code>nextTick</code>，在下一个 tick 处理这些回调函数之前，所有的 <code>cb</code> 都会被存在这个 <code>callbacks</code> 数组中。<code>pending</code> 是一个标记位，代表一个等待的状态。</p><p><code>setTimeout</code> 会在 task 中创建一个事件 <code>flushCallbacks</code> ，<code>flushCallbacks</code> 则会在执行时将 <code>callbacks</code> 中的所有 <code>cb</code> 依次执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callbacks = [];</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    callbacks.push(cb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>);</span><br><span class="line">    callbacks.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">        copies[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="再写-Watcher"><a href="#再写-Watcher" class="headerlink" title="再写 Watcher"></a>再写 Watcher</h2><p>第一个例子中，当我们将 <code>number</code> 增加 1000 次时，先将对应的 <code>Watcher</code> 对象给 <code>push</code> 进一个队列 <code>queue</code> 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？</p><p>因为 <code>number</code> 执行 ++ 操作以后对应的 <code>Watcher</code> 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 <code>Watcher</code> 对象去修改界面，而是只需要执行一个 <code>Watcher</code> 对象，使其将界面上的 0 变成 1000 即可。</p><p>那么，我们就需要执行一个过滤的操作，同一个的 <code>Watcher</code> 在同一个 tick 的时候应该只被执行一次，也就是说队列 <code>queue</code> 中不应该出现重复的 <code>Watcher</code> 对象。</p><p>那么我们给 <code>Watcher</code> 对象起个名字吧～用 <code>id</code> 来标记每一个 <code>Watcher</code> 对象，让他们看起来“不太一样”。</p><p>实现 <code>update</code> 方法，在修改数据后由 <code>Dep</code> 来调用， 而 <code>run</code> 方法才是真正的触发 <code>patch</code> 更新视图的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;watch&#x27;</span> + <span class="built_in">this</span>.id + <span class="string">&#x27; update&#x27;</span>);</span><br><span class="line">        queueWatcher(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;watch&#x27;</span> + <span class="built_in">this</span>.id + <span class="string">&#x27;视图更新啦～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h2><p>不知道大家注意到了没有？笔者已经将 <code>Watcher</code> 的 <code>update</code> 中的实现改成了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queueWatcher(<span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>将 <code>Watcher</code> 对象自身传递给 <code>queueWatcher</code> 方法。</p><p>我们来实现一下 <code>queueWatcher</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> has = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> queue = [];</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = watcher.id;</span><br><span class="line">    <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">        has[id] = <span class="literal">true</span>;</span><br><span class="line">        queue.push(watcher);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">            waiting = <span class="literal">true</span>;</span><br><span class="line">            nextTick(flushSchedulerQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个叫做 <code>has</code> 的 map，里面存放 id -&gt; true ( false ) 的形式，用来判断是否已经存在相同的 <code>Watcher</code> 对象 （这样比每次都去遍历 <code>queue</code> 效率上会高很多）。</p><p>如果目前队列 <code>queue</code> 中还没有这个 <code>Watcher</code> 对象，则该对象会被 <code>push</code> 进队列 <code>queue</code> 中去。</p><p><code>waiting</code> 是一个标记位，标记是否已经向 <code>nextTick</code> 传递了 <code>flushSchedulerQueue</code> 方法，在下一个 tick 的时候执行 <code>flushSchedulerQueue</code> 方法来 flush 队列 <code>queue</code>，执行它里面的所有 <code>Watcher</code> 对象的 <code>run</code> 方法。</p><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> watcher, id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">        watcher = queue[index];</span><br><span class="line">        id = watcher.id;</span><br><span class="line">        has[id] = <span class="literal">null</span>;</span><br><span class="line">        watcher.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    waiting  = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> watch1 = <span class="keyword">new</span> Watcher();</span><br><span class="line"><span class="keyword">let</span> watch2 = <span class="keyword">new</span> Watcher();</span><br><span class="line"></span><br><span class="line">watch1.update();</span><br><span class="line">watch1.update();</span><br><span class="line">watch2.update();</span><br></pre></td></tr></table></figure><p>我们现在 new 了两个 <code>Watcher</code> 对象，因为修改了 <code>data</code> 的数据，所以我们模拟触发了两次 <code>watch1</code> 的 <code>update</code> 以及 一次 <code>watch2</code> 的 <code>update</code>。</p><p>假设没有批量异步更新策略的话，理论上应该执行 <code>Watcher</code> 对象的 <code>run</code>，那么会打印。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch1 update</span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch1 update</span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch2 update</span><br><span class="line">watch2视图更新啦～</span><br></pre></td></tr></table></figure><p>实际上则执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch1 update</span><br><span class="line">watch1 update</span><br><span class="line">watch2 update</span><br><span class="line">watch1视图更新啦～</span><br><span class="line">watch2视图更新啦～</span><br></pre></td></tr></table></figure><p>这就是异步更新策略的效果，相同的 <code>Watcher</code> 对象会在这个过程中被剔除，在下一个 tick 的时候去更新视图，从而达到对我们第一个例子的优化。</p><p>我们再回过头聊一下第一个例子， <code>number</code> 会被不停地进行 <code>++</code> 操作，不断地触发它对应的 <code>Dep</code> 中的 <code>Watcher</code> 对象的 <code>update</code> 方法。然后最终 <code>queue</code> 中因为对相同 <code>id</code> 的 <code>Watcher</code> 对象进行了筛选，从而 <code>queue</code> 中实际上只会存在一个 <code>number</code> 对应的 <code>Watcher</code> 对象。在下一个 tick 的时候（此时 <code>number</code> 已经变成了 1000），触发 <code>Watcher</code> 对象的 <code>run</code> 方法来更新视图，将视图上的 <code>number</code> 从 0 直接变成 1000。</p><p>到这里，批量异步更新策略及 nextTick 原理已经讲完了，接下来让我们学习一下 Vuex 状态管理的工作原理。</p><p>注：本节代码参考[《批量异步更新策略及 nextTick 原理》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A">https://github.com/answershuto/VueDemo/blob/master/《批量异步更新策略及</a> nextTick 原理》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;批量异步更新策略及nextTick原理&quot;&gt;&lt;a href=&quot;#批量异步更新策略及nextTick原理&quot; class=&quot;headerlink&quot; title=&quot;批量异步更新策略及nextTick原理&quot;&gt;&lt;/a&gt;批量异步更新策略及nextTick原理&lt;/h2&gt;&lt;h2 i</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制06</title>
    <link href="http://example.com/2021/08/14/vue2-core06/"/>
    <id>http://example.com/2021/08/14/vue2-core06/</id>
    <published>2021-08-14T07:17:49.000Z</published>
    <updated>2021-09-17T08:10:31.532Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据状态更新时的差异-diff-及-patch-机制"><a href="#数据状态更新时的差异-diff-及-patch-机制" class="headerlink" title="数据状态更新时的差异 diff 及 patch 机制"></a>数据状态更新时的差异 diff 及 patch 机制</h2><h2 id="数据更新视图"><a href="#数据更新视图" class="headerlink" title="数据更新视图"></a>数据更新视图</h2><p>之前讲到，在对 <code>model</code> 进行操作对时候，会触发对应 <code>Dep</code> 中的 <code>Watcher</code> 对象。<code>Watcher</code> 对象会调用对应的 <code>update</code> 来修改视图。最终是将新产生的 VNode 节点与老 VNode 进行一个 <code>patch</code> 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。</p><p>这一章就来介绍一下这个 <code>patch</code> 的过程，因为 <code>patch</code> 过程本身比较复杂，这一章的内容会比较多，但是不要害怕，我们逐块代码去看，一定可以理解。</p><h2 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h2><p>因为使用了 Virtual DOM 的原因，Vue.js具有了跨平台的能力，Virtual DOM 终归只是一些 JavaScript 对象罢了，那么最终是如何调用不同平台的 API 的呢？</p><p>这就需要依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeOps = &#123;</span><br><span class="line">    setTextContent (text) &#123;</span><br><span class="line">        <span class="keyword">if</span> (platform === <span class="string">&#x27;weex&#x27;</span>) &#123;</span><br><span class="line">            node.parentNode.setAttr(<span class="string">&#x27;value&#x27;</span>, text);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (platform === <span class="string">&#x27;web&#x27;</span>) &#123;</span><br><span class="line">            node.textContent = text;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    parentNode () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    removeChild () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    nextSibling () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;,</span><br><span class="line">    insertBefore () &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，现在我们有上述一个 <code>nodeOps</code> 对象做适配，根据 platform 区分不同平台来执行当前平台对应的API，而对外则是提供了一致的接口，供 Virtual DOM 来调用。</p><h2 id="一些API"><a href="#一些API" class="headerlink" title="一些API"></a>一些API</h2><p>接下来我们来介绍其他的一些 API，这些API在下面 <code>patch</code> 的过程中会被用到，他们最终都会调用 <code>nodeOps</code> 中的相应函数来操作平台。</p><p><code>insert</code> 用来在 <code>parent</code> 这个父节点下插入一个子节点，如果指定了 <code>ref</code> 则插入到 <code>ref</code> 这个子节点前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ref.parentNode === parent) &#123;</span><br><span class="line">                nodeOps.insertBefore(parent, elm, ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodeOps.appendChild(parent, elm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElm</code> 用来新建一个节点， <code>tag</code> 存在创建一个标签节点，否则创建一个文本节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params">vnode, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.tag) &#123;</span><br><span class="line">        insert(parentElm, nodeOps.createElement(vnode.tag), refElm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(parentElm, nodeOps.createTextNode(vnode.text), refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addVnodes</code> 用来批量调用 <code>createElm</code> 新建节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addVnodes</span> (<span class="params">parentElm, refElm, vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">        createElm(vnodes[startIdx], parentElm, refElm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeNode</code> 用来移除一个节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parent = nodeOps.parentNode(el);</span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        nodeOps.removeChild(parent, el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeVnodes</code> 会批量调用 <code>removeNode</code> 移除节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span> (<span class="params">parentElm, vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">        <span class="keyword">const</span> ch = vnodes[startIdx]</span><br><span class="line">        <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">            removeNode(ch.elm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>首先说一下 <code>patch</code> 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 <code>patch</code> 的过程，我们需要将他们进行比对。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/28/1609be691ed64525?w=706&h=295&f=jpeg&s=18300" alt="img"></p><p>diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。</p><p><img src="https://img.kancloud.cn/78/ed/78ed0f7a71736796f0d4c31f5a9d1b9c_628x214.gif" alt="img"></p><p>这张图中的相同颜色的方块中的节点会进行比对，比对得到「<strong>差异</strong>」后将这些「<strong>差异</strong>」更新到视图上。因为只进行同层级的比对，所以十分高效。</p><p><code>patch</code> 的过程相当复杂，我们先用简单的代码来看一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, parentElm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">        addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(oldVNode, vnode)) &#123;</span><br><span class="line">            patchVnode(oldVNode, vnode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">            addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>patch</code> 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。我们来逐步捋一下逻辑， <code>addVnodes</code> 、 <code>removeVnodes</code> 等函数后面会讲。</p><p>首先在 <code>oldVnode</code>（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 <code>addVnodes</code> 将这些节点批量添加到 <code>parentElm</code> 上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!oldVnode) &#123;</span><br><span class="line">    addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后同理，在 <code>vnode</code>（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 <code>removeVnodes</code> 进行批量的节点删除即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!vnode) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一种情况，当 <code>oldVNode</code> 与 <code>vnode</code> 都存在的时候，需要判断它们是否属于 <code>sameVnode</code>（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameVnode(oldVNode, vnode)) &#123;</span><br><span class="line">    patchVnode(oldVNode, vnode);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    removeVnodes(parentElm, oldVnode, <span class="number">0</span>, oldVnode.length - <span class="number">1</span>);</span><br><span class="line">    addVnodes(parentElm, <span class="literal">null</span>, vnode, <span class="number">0</span>, vnode.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h2><p>上面这些比较好理解，下面我们来看看什么情况下两个 VNode 会属于 <code>sameVnode</code> （相同的节点）呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        a.key === b.key &amp;&amp;</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        (!!a.data) === (!!b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameInputType</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.tag !== <span class="string">&#x27;input&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> typeA = (i = a.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type</span><br><span class="line">    <span class="keyword">const</span> typeB = (i = b.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type</span><br><span class="line">    <span class="keyword">return</span> typeA === typeB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sameVnode</code> 其实很简单，只有当 <code>key</code>、 <code>tag</code>、 <code>isComment</code>（是否为注释节点）、 <code>data</code>同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改类型，所以他们被视为不同类型）即可。</p><h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h2><p>之前patch的过程还剩下 <code>patchVnode</code> 这个函数没有讲，这也是最复杂的一个，我们现在来看一下。因为这个函数是在符合 <code>sameVnode</code> 的条件下触发的，所以会进行「<strong>比对</strong>」。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123;</span><br><span class="line">        vnode.elm = oldVnode.elm;</span><br><span class="line">        vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm;</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children;</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vnode.text) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123;</span><br><span class="line">            updateChildren(elm, oldCh, ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldVnode.text) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">            addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldCh) &#123;</span><br><span class="line">            removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text) &#123;</span><br><span class="line">            nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的这种情况也比较简单，在当新老 VNode 节点都是 <code>isStatic</code>（静态的），并且 <code>key</code> 相同时，只要将 <code>componentInstance</code> 与 <code>elm</code> 从老 VNode 节点“拿过来”即可。这里的 <code>isStatic</code> 也就是前面提到过的「编译」的时候会将静态节点标记出来，这样就可以跳过比对的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123;</span><br><span class="line">    vnode.elm = oldVnode.elm;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，当新 VNode 节点是文本节点的时候，直接用 <code>setTextContent</code> 来设置 text，这里的 <code>nodeOps</code> 是一个适配层，根据不同平台提供不同的操作平台 DOM 的方法，实现跨平台。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当新 VNode 节点是非文本节点当时候，需要分几种情况。</p><ul><li><code>oldCh</code> 与 <code>ch</code> 都存在且不相同时，使用 <code>updateChildren</code> 函数来更新子节点，这个后面重点讲。</li><li>如果只有 <code>ch</code> 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 <code>ch</code> 批量插入插入到节点elm下。</li><li>同理当只有 <code>oldch</code> 存在时，说明需要将老节点通过 <code>removeVnodes</code> 全部清除。</li><li>最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123;</span><br><span class="line">    updateChildren(elm, oldCh, ch);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldVnode.text) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldCh) &#123;</span><br><span class="line">    removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><p>接下来就要讲一下 <code>updateChildren</code> 函数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldStartVnode) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVnode) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">            nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">            newEndVnode = newCh[--newEndIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">            nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> elmToMove = oldCh[idxInOld];</span><br><span class="line">            <span class="keyword">if</span> (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">            idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                createElm(newStartVnode, parentElm);</span><br><span class="line">                newStartVnode = newCh[++newStartIdx];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                elmToMove = oldCh[idxInOld];</span><br><span class="line">                <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(elmToMove, newStartVnode);</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">                    nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    createElm(newStartVnode, parentElm);</span><br><span class="line">                    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = (newCh[newEndIdx + <span class="number">1</span>]) ? newCh[newEndIdx + <span class="number">1</span>].elm : <span class="literal">null</span>;</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到代码那么多先不要着急，我们还是一点一点地讲解。</p><p>首先我们定义 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 分别是新老两个 VNode 的两边的索引，同时 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 分别指向这几个索引对应的 VNode 节点。</p><p><img src="https://img.kancloud.cn/9d/4a/9d4a83c7a917571940a8edd29396c345_885x397.gif" alt="img"></p><p>接下来是一个 <code>while</code> 循环，在这过程中，<code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 会逐渐向中间靠拢。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) </span><br></pre></td></tr></table></figure><p><img src="https://img.kancloud.cn/9b/fa/9bfa3d79db0aa810974ce4000e01ffd2_864x428.gif" alt="img"></p><p>首先当 <code>oldStartVnode</code> 或者 <code>oldEndVnode</code> 不存在的时候，<code>oldStartIdx</code> 与 <code>oldEndIdx</code> 继续向中间靠拢，并更新对应的 <code>oldStartVnode</code> 与 <code>oldEndVnode</code> 的指向（注：下面讲到的 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 移动都会伴随着 <code>oldStartVnode</code>、<code>newStartVnode</code>、<code>oldEndVnode</code> 以及 <code>newEndVnode</code> 的指向的变化，之后的部分只会讲 <code>Idx</code> 的移动）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!oldStartVnode) &#123;</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVnode) &#123;</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来这一块，是将 <code>oldStartIdx</code>、<code>newStartIdx</code>、<code>oldEndIdx</code> 以及 <code>newEndIdx</code> 两两比对的过程，一共会出现 2*2=4 种情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode);</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newEndVnode);</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    newEndVnode = newCh[--newEndIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newEndVnode);</span><br><span class="line">    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">    newEndVnode = newCh[--newEndIdx];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newStartVnode);</span><br><span class="line">    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>首先是 <code>oldStartVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接进行 <code>patchVnode</code>，同时 <code>oldStartIdx</code> 与 <code>newStartIdx</code> 向后移动一位。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b71f5a48631f4?w=618&h=251&f=png&s=19993" alt="img"></p><p>其次是 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code>，也就是两个 VNode 的结尾是相同的 VNode，同样进行 <code>patchVnode</code> 操作并将 <code>oldEndVnode</code> 与 <code>newEndVnode</code> 向前移动一位。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b7228b9ecb23a?w=753&h=235&f=png&s=20727" alt="img"></p><p>接下来是两种交叉的情况。</p><p>先是 <code>oldStartVnode</code> 与 <code>newEndVnode</code> 符合 <code>sameVnode</code> 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 <code>oldStartVnode.elm</code> 这个节点直接移动到 <code>oldEndVnode.elm</code> 这个节点的后面即可。然后 <code>oldStartIdx</code> 向后移动一位，<code>newEndIdx</code> 向前移动一位。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b723af0fd706a?w=1540&h=776&f=png&s=105982" alt="img"></p><p>同理，<code>oldEndVnode</code> 与 <code>newStartVnode</code> 符合 <code>sameVnode</code> 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 <code>oldEndVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 前面。同样的，<code>oldEndIdx</code> 向前移动一位，<code>newStartIdx</code> 向后移动一位。</p><p><img src="https://img.kancloud.cn/aa/8d/aa8d34c20a47b212378b1da678355af9_810x432.gif" alt="img"></p><p>最后是当以上情况都不符合的时候，这种情况怎么处理呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> elmToMove = oldCh[idxInOld];</span><br><span class="line">    <span class="keyword">if</span> (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">        createElm(newStartVnode, parentElm);</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elmToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(elmToMove, newStartVnode);</span><br><span class="line">            oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">            nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createElm(newStartVnode, parentElm);</span><br><span class="line">            newStartVnode = newCh[++newStartIdx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span> (<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i, key</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">        key = children[i].key</span><br><span class="line">        <span class="keyword">if</span> (isDef(key)) map[key] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createKeyToOldIdx</code> 的作用是产生 <code>key</code> 与 <code>index</code> 索引对应的一个 map 表。比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">xx</span>: xx, <span class="attr">key</span>: <span class="string">&#x27;key0&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">xx</span>: xx, <span class="attr">key</span>: <span class="string">&#x27;key1&#x27;</span>&#125;, </span><br><span class="line">    &#123;<span class="attr">xx</span>: xx, <span class="attr">key</span>: <span class="string">&#x27;key2&#x27;</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在经过 <code>createKeyToOldIdx</code> 转化以后会变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    key0: <span class="number">0</span>, </span><br><span class="line">    key1: <span class="number">1</span>, </span><br><span class="line">    key2: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以根据某一个 key 的值，快速地从 <code>oldKeyToIdx</code>（<code>createKeyToOldIdx</code> 的返回值）中获取相同 key 的节点的索引 <code>idxInOld</code>，然后找到相同的节点。</p><p>如果没有找到相同的节点，则通过 <code>createElm</code> 创建一个新节点，并将 <code>newStartIdx</code> 向后移动一位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">    createElm(newStartVnode, parentElm);</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则如果找到了节点，同时它符合 <code>sameVnode</code>，则将这两个节点进行 <code>patchVnode</code>，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 的前面。同理，<code>newStartIdx</code> 往后移动一位。</p><p><img src="https://img.kancloud.cn/e9/fa/e9fa09c72cbca2763a9fd891f8894d3c_750x373.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    elmToMove = oldCh[idxInOld];</span><br><span class="line">    <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">        patchVnode(elmToMove, newStartVnode);</span><br><span class="line">        oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">        nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不符合 <code>sameVnode</code>，只能创建一个新节点插入到 <code>parentElm</code> 的子节点中，<code>newStartIdx</code> 往后移动一位。</p><p><img src="https://img.kancloud.cn/bc/0d/bc0dc37b80d324472e77d4eb418edf67_927x462.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    createElm(newStartVnode, parentElm);</span><br><span class="line">    newStartVnode = newCh[++newStartIdx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步就很容易啦，当 <code>while</code> 循环结束以后，如果 <code>oldStartIdx &gt; oldEndIdx</code>，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 <code>addVnodes</code> 将这些节点插入即可。</p><p><img src="https://img.kancloud.cn/9b/17/9b172cca47e698754c47653c10bc815f_784x373.gif" alt="img"></p><p>同理，如果满足 <code>newStartIdx &gt; newEndIdx</code> 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 <code>removeVnodes</code> 批量删除即可。</p><p><img src="https://img.kancloud.cn/37/65/3765205d0b78788b7cdddcffb70a495f_836x367.gif" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = (newCh[newEndIdx + <span class="number">1</span>]) ? newCh[newEndIdx + <span class="number">1</span>].elm : <span class="literal">null</span>;</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，比对的核心实现已经讲完了，这部分比较复杂，不过仔细地梳理一下比对的过程，相信一定能够理解得更加透彻的。</p><p>注：本节代码参考[《数据状态更新时的差异 diff 及 patch 机制》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82">https://github.com/answershuto/VueDemo/blob/master/《数据状态更新时的差异</a> diff 及 patch 机制》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据状态更新时的差异-diff-及-patch-机制&quot;&gt;&lt;a href=&quot;#数据状态更新时的差异-diff-及-patch-机制&quot; class=&quot;headerlink&quot; title=&quot;数据状态更新时的差异 diff 及 patch 机制&quot;&gt;&lt;/a&gt;数据状态更新时的</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制05</title>
    <link href="http://example.com/2021/08/10/vue2-core05/"/>
    <id>http://example.com/2021/08/10/vue2-core05/</id>
    <published>2021-08-10T07:17:49.000Z</published>
    <updated>2021-09-17T08:09:28.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="template-模板是怎样通过-Compile-编译的"><a href="#template-模板是怎样通过-Compile-编译的" class="headerlink" title="template 模板是怎样通过 Compile 编译的"></a>template 模板是怎样通过 Compile 编译的</h2><h2 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h2><p><code>compile</code> 编译可以分成 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 三个阶段，最终需要得到 render function。这部分内容不算 Vue.js 的响应式核心，只是用来编译的，笔者认为在精力有限的情况下不需要追究其全部的实现细节，能够把握如何解析的大致流程即可。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606ec3d306ab28f?w=824&h=496&f=png&s=37271" alt="img"></p><p>由于解析过程比较复杂，直接上代码可能会导致不了解这部分内容的同学一头雾水。所以笔者准备提供一个 template 的示例，通过这个示例的变化来看解析的过程。但是解析的过程及结果都是将最重要的部分抽离出来展示，希望能让读者更好地了解其核心部分的实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;c&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;demo&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><br><span class="line">    &lt;span v-<span class="keyword">for</span>=<span class="string">&quot;item in sz&quot;</span>&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> html = <span class="string">&#x27;&lt;div :class=&quot;c&quot; class=&quot;demo&quot; v-if=&quot;isShow&quot;&gt;&lt;span v-for=&quot;item in sz&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/div&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>接下来的过程都会依赖这个示例来进行。</p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>首先是 <code>parse</code>，<code>parse</code> 会用正则等方式将 template 模板中进行字符串解析，得到指令、class、style等数据，形成 AST（<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。</a>）。</p><p>这个过程比较复杂，会涉及到比较多的正则进行字符串解析，我们来看一下得到的 AST 的样子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 标签属性的map，记录了标签上属性 */</span></span><br><span class="line">    <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;:class&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;v-if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 解析得到的:class */</span></span><br><span class="line">    <span class="string">&#x27;classBinding&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 标签属性v-if */</span></span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">    <span class="comment">/* v-if的条件 */</span></span><br><span class="line">    <span class="string">&#x27;ifConditions&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;exp&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">/* 标签属性class */</span></span><br><span class="line">    <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 标签的tag */</span></span><br><span class="line">    <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 子标签数组 */</span></span><br><span class="line">    <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;v-for&#x27;</span>: <span class="string">&quot;item in sz&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/* for循环的参数 */</span></span><br><span class="line">            <span class="string">&#x27;alias&#x27;</span>: <span class="string">&quot;item&quot;</span>,</span><br><span class="line">            <span class="comment">/* for循环的对象 */</span></span><br><span class="line">            <span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">            <span class="comment">/* for循环是否已经被处理的标记位 */</span></span><br><span class="line">            <span class="string">&#x27;forProcessed&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 表达式，_s是一个转字符串的函数 */</span></span><br><span class="line">                    <span class="string">&#x27;expression&#x27;</span>: <span class="string">&#x27;_s(item)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#123;&#123;item&#125;&#125;&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终得到的 AST 通过一些特定的属性，能够比较清晰地描述出标签的属性以及依赖关系。</p><p>接下来我们用代码来讲解一下如何使用正则来把 template 编译成我们需要的 AST 的。</p><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>首先我们定义一下接下来我们会用到的正则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ncname = <span class="string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> singleAttrIdentifier = <span class="regexp">/([^\s&quot;&#x27;&lt;&gt;/=]+)/</span></span><br><span class="line"><span class="keyword">const</span> singleAttrAssign = <span class="regexp">/(?:=)/</span></span><br><span class="line"><span class="keyword">const</span> singleAttrValues = [</span><br><span class="line">  /<span class="string">&quot;([^&quot;</span>]*)<span class="string">&quot;+/.source,</span></span><br><span class="line"><span class="string">  /&#x27;([^&#x27;]*)&#x27;+/.source,</span></span><br><span class="line"><span class="string">  /([^\s&quot;</span><span class="string">&#x27;=&lt;&gt;`]+)/.source</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">const attribute = new RegExp(</span></span><br><span class="line"><span class="string">  &#x27;</span>^\\s*<span class="string">&#x27; + singleAttrIdentifier.source +</span></span><br><span class="line"><span class="string">  &#x27;</span>(?:\\s*(<span class="string">&#x27; + singleAttrAssign.source + &#x27;</span>)<span class="string">&#x27; +</span></span><br><span class="line"><span class="string">  &#x27;</span>\\s*(?:<span class="string">&#x27; + singleAttrValues.join(&#x27;</span>|<span class="string">&#x27;) + &#x27;</span>))?<span class="string">&#x27;</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const qnameCapture = &#x27;</span>((?:<span class="string">&#x27; + ncname + &#x27;</span>\\:)?<span class="string">&#x27; + ncname + &#x27;</span>)<span class="string">&#x27;</span></span><br><span class="line"><span class="string">const startTagOpen = new RegExp(&#x27;</span>^&lt;<span class="string">&#x27; + qnameCapture)</span></span><br><span class="line"><span class="string">const startTagClose = /^\s*(\/?)&gt;/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const endTag = new RegExp(&#x27;</span>^<span class="xml">&lt;\\/&#x27; + qnameCapture + &#x27;[^&gt;]*&gt;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="xml">const defaultTagRE = /\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;/g</span></span><br><span class="line"></span><br><span class="line"><span class="xml">const forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/</span></span><br></pre></td></tr></table></figure><h2 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h2><p>因为我们解析 template 采用循环进行字符串匹配的方式，所以每匹配解析完一段我们需要将已经匹配掉的去掉，头部的指针指向接下来需要匹配的部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">advance</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    index += n</span><br><span class="line">    html = html.substring(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，当我们把第一个 div 的头标签全部匹配完毕以后，我们需要将这部分除去，也就是向右移动 43 个字符。</p><p><img src="https://img.kancloud.cn/30/12/3012cf68fb6155a4d9ccf0490bcc85c8_1086x199.gif" alt="img"></p><p>调用 <code>advance</code> 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">advance(43);</span><br></pre></td></tr></table></figure><p>得到结果</p><p><img src="https://img.kancloud.cn/84/89/84898f9a7959fa81cc4055869bd98c4f_1096x198.gif" alt="img"></p><h3 id="parseHTML"><a href="#parseHTML" class="headerlink" title="parseHTML"></a>parseHTML</h3><p>首先我们需要定义个 <code>parseHTML</code> 函数，在里面我们循环解析 template 字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHTML</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(html) &#123;</span><br><span class="line">        <span class="keyword">let</span> textEnd = html.indexOf(<span class="string">&#x27;&lt;&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (textEnd === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (html.match(endTag)) &#123;</span><br><span class="line">                <span class="comment">//...process end tag</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">                <span class="comment">//...process start tag</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...process text</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>parseHTML</code> 会用 <code>while</code> 来循环解析 template ，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个 template 被解析完毕。</p><h3 id="parseStartTag"><a href="#parseStartTag" class="headerlink" title="parseStartTag"></a>parseStartTag</h3><p>我们来写一个 <code>parseStartTag</code> 函数，用来解析起始标签（”</p><p>“部分的内容）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseStartTag</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line">    <span class="keyword">if</span> (start) &#123;</span><br><span class="line">        <span class="keyword">const</span> match = &#123;</span><br><span class="line">            tagName: start[<span class="number">1</span>],</span><br><span class="line">            attrs: [],</span><br><span class="line">            start: index</span><br><span class="line">        &#125;</span><br><span class="line">        advance(start[<span class="number">0</span>].length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> end, attr</span><br><span class="line">        <span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class="line">            advance(attr[<span class="number">0</span>].length)</span><br><span class="line">            match.attrs.push(&#123;</span><br><span class="line">                name: attr[<span class="number">1</span>],</span><br><span class="line">                value: attr[<span class="number">3</span>]</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end) &#123;</span><br><span class="line">            match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">            advance(end[<span class="number">0</span>].length);</span><br><span class="line">            match.end = index;</span><br><span class="line">            <span class="keyword">return</span> match</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先用 <code>startTagOpen</code> 正则得到标签的头部，可以得到 <code>tagName</code>（标签名称），同时我们需要一个数组 <code>attrs</code> 用来存放标签内的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> start = html.match(startTagOpen);</span><br><span class="line"><span class="keyword">const</span> match = &#123;</span><br><span class="line">    tagName: start[<span class="number">1</span>],</span><br><span class="line">    attrs: [],</span><br><span class="line">    start: index</span><br><span class="line">&#125;</span><br><span class="line">advance(start[<span class="number">0</span>].length);</span><br></pre></td></tr></table></figure><p>接下来使用 <code>startTagClose</code> 与 <code>attribute</code> 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 <code>while</code> 循环一直到匹配到 <code>startTagClose</code> 为止，解析内部所有的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> end, attr</span><br><span class="line"><span class="keyword">while</span> (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123;</span><br><span class="line">    advance(attr[<span class="number">0</span>].length)</span><br><span class="line">    match.attrs.push(&#123;</span><br><span class="line">        name: attr[<span class="number">1</span>],</span><br><span class="line">        value: attr[<span class="number">3</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (end) &#123;</span><br><span class="line">    match.unarySlash = end[<span class="number">1</span>];</span><br><span class="line">    advance(end[<span class="number">0</span>].length);</span><br><span class="line">    match.end = index;</span><br><span class="line">    <span class="keyword">return</span> match</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>此外，我们需要维护一个 <strong>stack</strong> 栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 <code>currentParent</code> 变量用来存放当前标签的父标签节点的引用， <code>root</code> 变量用来指向根标签节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stack = [];</span><br><span class="line"><span class="keyword">let</span> currentParent, root;</span><br></pre></td></tr></table></figure><p><img src="https://img.kancloud.cn/40/28/4028cf3960616fca915c0f2ed4229427_709x451.gif" alt="img"></p><p>知道这个以后，我们优化一下 <code>parseHTML</code> ，在 <code>startTagOpen</code> 的 <code>if</code> 逻辑中加上新的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">        type: <span class="number">1</span>,</span><br><span class="line">        tag: startTagMatch.tagName,</span><br><span class="line">        lowerCasedTag: startTagMatch.tagName.toLowerCase(),</span><br><span class="line">        attrsList: startTagMatch.attrs,</span><br><span class="line">        attrsMap: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">        parent: currentParent,</span><br><span class="line">        children: []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentParent)&#123;</span><br><span class="line">        currentParent.children.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(element);</span><br><span class="line">    currentParent = element;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 <code>startTagMatch</code> 得到的结果首先封装成 <code>element</code> ，这个就是最终形成的 AST 的节点，标签节点的 type 为 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    tag: startTagMatch.tagName,</span><br><span class="line">    attrsList: startTagMatch.attrs,</span><br><span class="line">    attrsMap: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">    parent: currentParent,</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让 <code>root</code> 指向根节点的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">    root = element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们将当前节点的 <code>element</code> 放入父节点 <code>currentParent</code> 的 <code>children</code> 数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(currentParent)&#123;</span><br><span class="line">    currentParent.children.push(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将当前节点 <code>element</code> 压入 stack 栈中，并将 <code>currentParent</code> 指向当前节点，因为接下去下一个解析如果还是头标签或者是文本的话，会成为当前节点的子节点，如果是尾标签的话，那么将会从栈中取出当前节点，这种情况我们接下来要讲。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack.push(element);</span><br><span class="line">currentParent = element;</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>其中的 <code>makeAttrsMap</code> 是将 attrs 转换成 map 格式的一个方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAttrsMap</span> (<span class="params">attrs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = attrs.length; i &lt; l; i++) &#123;</span><br><span class="line">        map[attrs[i].name] = attrs[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parseEndTag"><a href="#parseEndTag" class="headerlink" title="parseEndTag"></a>parseEndTag</h3><p>同样，我们在 <code>parseHTML</code> 中加入对尾标签的解析函数，为了匹配如“</p><p>”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> endTagMatch = html.match(endTag)</span><br><span class="line"> <span class="keyword">if</span> (endTagMatch) &#123;</span><br><span class="line">    advance(endTagMatch[<span class="number">0</span>].length);</span><br><span class="line">    parseEndTag(endTagMatch[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>parseEndTag</code> 来解析尾标签，它会从 stack 栈中取出最近的跟自己标签名一致的那个元素，将 <code>currentParent</code> 指向那个元素，并将该元素之前的元素都从 stack 中出栈。</p><p>这里可能有同学会问，难道解析的尾元素不应该对应 stack 栈的最上面的一个元素才对吗？</p><p>其实不然，比如说可能会存在自闭合的标签，如“<br>”，或者是写了“”但是没有加上“&lt; /span&gt;”的情况，这时候就要找到 stack 中的第二个位置才能找到同名标签。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseEndTag</span> (<span class="params">tagName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (pos = stack.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; pos--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack[pos].lowerCasedTag === tagName.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stack.length = pos;</span><br><span class="line">        currentParent = stack[pos]; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parseText"><a href="#parseText" class="headerlink" title="parseText"></a>parseText</h3><p>最后是解析文本，这个比较简单，只需要将文本取出，然后有两种情况，一种是普通的文本，直接构建一个节点 push 进当前 <code>currentParent</code> 的 children 中即可。还有一种情况是文本是如“”这样的 Vue.js 的表达式，这时候我们需要用 <code>parseText</code> 来将表达式转化成代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">text = html.substring(<span class="number">0</span>, textEnd)</span><br><span class="line">advance(textEnd)</span><br><span class="line"><span class="keyword">let</span> expression;</span><br><span class="line"><span class="keyword">if</span> (expression = parseText(text)) &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type: <span class="number">2</span>,</span><br><span class="line">        text,</span><br><span class="line">        expression</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    currentParent.children.push(&#123;</span><br><span class="line">        type: <span class="number">3</span>,</span><br><span class="line">        text,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>我们会用到一个 <code>parseText</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseText</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!defaultTagRE.test(text)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> tokens = [];</span><br><span class="line">    <span class="keyword">let</span> lastIndex = defaultTagRE.lastIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> match, index</span><br><span class="line">    <span class="keyword">while</span> ((match = defaultTagRE.exec(text))) &#123;</span><br><span class="line">        index = match.index</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">            tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex, index)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> exp = match[<span class="number">1</span>].trim()</span><br><span class="line">        tokens.push(<span class="string">`_s(<span class="subst">$&#123;exp&#125;</span>)`</span>)</span><br><span class="line">        lastIndex = index + match[<span class="number">0</span>].length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastIndex &lt; text.length) &#123;</span><br><span class="line">        tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tokens.join(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个 <code>tokens</code> 数组来存放解析结果，通过 <code>defaultTagRE</code> 来循环匹配该文本，如果是普通文本直接 <code>push</code> 到 <code>tokens</code> 数组中去，如果是表达式（），则转化成“_s(${exp})”的形式。</p><p>举个例子，如果我们有这样一个文本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;hello,&#123;&#123;name&#125;&#125;.&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>最终得到 <code>tokens</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokens = [<span class="string">&#x27;hello,&#x27;</span>, _s(name), <span class="string">&#x27;.&#x27;</span>];</span><br></pre></td></tr></table></figure><p>最终通过 <code>join</code> 返回表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;hello&#x27;</span> + _s(name) + <span class="string">&#x27;.&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="processIf与processFor"><a href="#processIf与processFor" class="headerlink" title="processIf与processFor"></a>processIf与processFor</h3><p>最后介绍一下如何处理“<code>v-if</code>”以及“<code>v-for</code>”这样的 Vue.js 的表达式的，这里我们只简单介绍两个示例中用到的表达式解析。</p><p>我们只需要在解析头标签的内容中加入这两个表达式的解析函数即可，在这时“<code>v-for</code>”之类指令已经在属性解析时存入了 <code>attrsMap</code> 中了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.match(startTagOpen)) &#123;</span><br><span class="line">    <span class="keyword">const</span> startTagMatch = parseStartTag();</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">        type: <span class="number">1</span>,</span><br><span class="line">        tag: startTagMatch.tagName,</span><br><span class="line">        attrsList: startTagMatch.attrs,</span><br><span class="line">        attrsMap: makeAttrsMap(startTagMatch.attrs),</span><br><span class="line">        parent: currentParent,</span><br><span class="line">        children: []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    processIf(element);</span><br><span class="line">    processFor(element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(currentParent)&#123;</span><br><span class="line">        currentParent.children.push(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(element);</span><br><span class="line">    currentParent = element;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要定义一个 <code>getAndRemoveAttr</code> 函数，用来从 <code>el</code> 的 <code>attrsMap</code> 属性或是 <code>attrsList</code> 属性中取出 <code>name</code> 对应值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAndRemoveAttr</span> (<span class="params">el, name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> val</span><br><span class="line">    <span class="keyword">if</span> ((val = el.attrsMap[name]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> list = el.attrsList</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i].name === name) &#123;</span><br><span class="line">                list.splice(i, <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说解析示例的 div 标签属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAndRemoveAttr(el, <span class="string">&#x27;v-for&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可有得到“item in sz”。</p><p>有了这个函数这样我们就可以开始实现 <code>processFor</code> 与 <code>processIf</code> 了。</p><p>“v-for”会将指令解析成 <code>for</code> 属性以及 <code>alias</code> 属性，而“v-if”会将条件都存入 <code>ifConditions</code> 数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processFor</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> exp;</span><br><span class="line">    <span class="keyword">if</span> ((exp = getAndRemoveAttr(el, <span class="string">&#x27;v-for&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">const</span> inMatch = exp.match(forAliasRE);</span><br><span class="line">        el.for = inMatch[<span class="number">2</span>].trim();</span><br><span class="line">        el.alias = inMatch[<span class="number">1</span>].trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processIf</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> exp = getAndRemoveAttr(el, <span class="string">&#x27;v-if&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (exp) &#123;</span><br><span class="line">        el.if = exp;</span><br><span class="line">        <span class="keyword">if</span> (!el.ifConditions) &#123;</span><br><span class="line">            el.ifConditions = [];</span><br><span class="line">        &#125;</span><br><span class="line">        el.ifConditions.push(&#123;</span><br><span class="line">            exp: exp,</span><br><span class="line">            block: el</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经把 <code>parse</code> 的过程介绍完了，接下来看一下 <code>optimize</code>。</p><h2 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h2><p><code>optimize</code> 主要作用就跟它的名字一样，用作「优化」。</p><p>这个涉及到后面要讲 <code>patch</code> 的过程，因为 <code>patch</code> 的过程实际上是将 VNode 节点进行一层一层的比对，然后将「差异」更新到视图上。那么一些静态节点是不会根据数据变化而产生变化的，这些节点我们没有比对的需求，是不是可以跳过这些静态节点的比对，从而节省一些性能呢？</p><p>那么我们就需要为静态的节点做上一些「标记」，在 <code>patch</code> 的时候我们就可以直接跳过这些被标记的节点的比对，从而达到「优化」的目的。</p><p>经过 <code>optimize</code> 这层的处理，每个节点会加上 <code>static</code> 属性，用来标记是否是静态的。</p><p>得到如下结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;:class&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;v-if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;classBinding&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;if&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ifConditions&#x27;</span>: [</span><br><span class="line">        <span class="string">&#x27;exp&#x27;</span>: <span class="string">&#x27;isShow&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="comment">/* 静态标志 */</span></span><br><span class="line">    <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&#x27;attrsMap&#x27;</span>: &#123;</span><br><span class="line">                <span class="string">&#x27;v-for&#x27;</span>: <span class="string">&quot;item in sz&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&#x27;alias&#x27;</span>: <span class="string">&quot;item&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;for&#x27;</span>: <span class="string">&#x27;sz&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;forProcessed&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&#x27;tag&#x27;</span>: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;children&#x27;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&#x27;expression&#x27;</span>: <span class="string">&#x27;_s(item)&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#123;&#123;item&#125;&#125;&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;static&#x27;</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用代码实现一下 <code>optimize</code> 函数。</p><h3 id="isStatic"><a href="#isStatic" class="headerlink" title="isStatic"></a>isStatic</h3><p>首先实现一个 <code>isStatic</code> 函数，传入一个 node 判断该 node 是否是静态节点。判断的标准是当 type 为 2（表达式节点）则是非静态节点，当 type 为 3（文本节点）的时候则是静态节点，当然，如果存在 <code>if</code> 或者 <code>for</code>这样的条件的时候（表达式节点），也是非静态节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isStatic</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (!node.if &amp;&amp; !node.for);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="markStatic"><a href="#markStatic" class="headerlink" title="markStatic"></a>markStatic</h3><p><code>markStatic</code> 为所有的节点标记上 <code>static</code>，遍历所有节点通过 <code>isStatic</code> 来判断当前节点是否是静态节点，此外，会遍历当前节点的所有子节点，如果子节点是非静态节点，那么当前节点也是非静态节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStatic</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.static = isStatic(node);</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = node.children.length; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> child = node.children[i];</span><br><span class="line">            markStatic(child);</span><br><span class="line">            <span class="keyword">if</span> (!child.static) &#123;</span><br><span class="line">                node.static = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="markStaticRoots"><a href="#markStaticRoots" class="headerlink" title="markStaticRoots"></a>markStaticRoots</h3><p>接下来是 <code>markStaticRoots</code> 函数，用来标记 <code>staticRoot</code>（静态根）。这个函数实现比较简单，简单来将就是如果当前节点是静态节点，同时满足该节点并不是只有一个文本节点左右子节点（作者认为这种情况的优化消耗会大于收益）时，标记 <code>staticRoot</code> 为 true，否则为 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">markStaticRoots</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(</span><br><span class="line">        node.children.length === <span class="number">1</span> &amp;&amp;</span><br><span class="line">        node.children[<span class="number">0</span>].type === <span class="number">3</span></span><br><span class="line">        )) &#123;</span><br><span class="line">            node.staticRoot = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.staticRoot = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="optimize-1"><a href="#optimize-1" class="headerlink" title="optimize"></a>optimize</h3><p>有了以上的函数，就可以实现 <code>optimize</code> 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">optimize</span> (<span class="params">rootAst</span>) </span>&#123;</span><br><span class="line">    markStatic(rootAst);</span><br><span class="line">    markStaticRoots(rootAst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p><code>generate</code> 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。</p><p>首先带大家感受一下真实的 Vue.js 编译得到的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params"><span class="built_in">this</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isShow) ? </span><br><span class="line">    _c(</span><br><span class="line">        <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            staticClass: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">            class: c</span><br><span class="line">        &#125;,</span><br><span class="line">        _l(</span><br><span class="line">            (sz),</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _c(<span class="string">&#x27;span&#x27;</span>,[_v(_s(item))])</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    : _e()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里可能会纳闷了，这些 <code>_c</code>，<code>_l</code> 到底是什么？其实他们是 Vue.js 对一些函数的简写，比如说 <code>_c</code> 对应的是 <code>createElement</code> 这个函数。没关系，我们把它用 VNode 的形式写出来就会明白了，这个对接上一章写的 VNode 函数。</p><p>首先是第一层 div 节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> isShow ? (<span class="keyword">new</span> VNode(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: c</span><br><span class="line">    &#125;, [ <span class="comment">/*这里还有子节点*/</span> ])) : createEmptyVNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们在 <code>children</code> 中加上第二层 span 及其子文本节点节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 渲染v-for列表 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderList</span> (<span class="params">val, render</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(val.length);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = val.length; i &lt; l; i++) &#123;</span><br><span class="line">        ret[i] = render(val[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render () &#123;</span><br><span class="line">    <span class="keyword">return</span> isShow ? (<span class="keyword">new</span> VNode(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;staticClass&#x27;</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;class&#x27;</span>: c</span><br><span class="line">    &#125;, </span><br><span class="line">        <span class="comment">/* begin */</span></span><br><span class="line">        renderList(sz, <span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="string">&#x27;span&#x27;</span>, &#123;&#125;, [</span><br><span class="line">                createTextVNode(item);</span><br><span class="line">            ]);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">/* end */</span></span><br><span class="line">    )) : createEmptyVNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何来实现一个 <code>generate</code> 呢？</p><h3 id="genIf"><a href="#genIf" class="headerlink" title="genIf"></a>genIf</h3><p>首先实现一个处理 <code>if</code> 条件的 <code>genIf</code> 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genIf</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.ifProcessed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!el.ifConditions.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;_e()&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;el.ifConditions[<span class="number">0</span>].exp&#125;</span>)?<span class="subst">$&#123;genElement(el.ifConditions[<span class="number">0</span>].block)&#125;</span>: _e()`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="genFor"><a href="#genFor" class="headerlink" title="genFor"></a>genFor</h3><p>然后是处理 <code>for</code> 循环的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genFor</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    el.forProcessed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> exp = el.for;</span><br><span class="line">    <span class="keyword">const</span> alias = el.alias;</span><br><span class="line">    <span class="keyword">const</span> iterator1 = el.iterator1 ? <span class="string">`,<span class="subst">$&#123;el.iterator1&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> iterator2 = el.iterator2 ? <span class="string">`,<span class="subst">$&#123;el.iterator2&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_l((<span class="subst">$&#123;exp&#125;</span>),`</span> +</span><br><span class="line">        <span class="string">`function(<span class="subst">$&#123;alias&#125;</span><span class="subst">$&#123;iterator1&#125;</span><span class="subst">$&#123;iterator2&#125;</span>)&#123;`</span> +</span><br><span class="line">        <span class="string">`return <span class="subst">$&#123;genElement(el)&#125;</span>`</span> +</span><br><span class="line">    <span class="string">&#x27;&#125;)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="genText"><a href="#genText" class="headerlink" title="genText"></a>genText</h3><p>处理文本节点的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genText</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`_v(<span class="subst">$&#123;el.expression&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="genElement"><a href="#genElement" class="headerlink" title="genElement"></a>genElement</h3><p>接下来实现一下 <code>genElement</code>，这是一个处理节点的函数，因为它依赖 <code>genChildren</code> 以及g <code>enNode</code> ，所以这三个函数放在一起讲。</p><p>genElement会根据当前节点是否有 <code>if</code> 或者 <code>for</code> 标记然后判断是否要用 <code>genIf</code> 或者 <code>genFor</code> 处理，否则通过 <code>genChildren</code> 处理子节点，同时得到 <code>staticClass</code>、<code>class</code> 等属性。</p><p><code>genChildren</code> 比较简单，遍历所有子节点，通过 <code>genNode</code> 处理后用“，”隔开拼接成字符串。</p><p><code>genNode</code> 则是根据 <code>type</code> 来判断该节点是用文本节点 <code>genText</code> 还是标签节点 <code>genElement</code> 来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genNode</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.type === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> genElement(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> genText(el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genChildren</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> children = el.children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children &amp;&amp; children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;children.map(genNode).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genElement</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genIf(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;</span><br><span class="line">        <span class="keyword">return</span> genFor(el);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = genChildren(el);</span><br><span class="line">        <span class="keyword">let</span> code;</span><br><span class="line">        code = <span class="string">`_c(&#x27;<span class="subst">$&#123;el.tag&#125;</span>,&#x27;&#123;</span></span><br><span class="line"><span class="string">            staticClass: <span class="subst">$&#123;el.attrsMap &amp;&amp; el.attrsMap[<span class="string">&#x27;:class&#x27;</span>]&#125;</span>,</span></span><br><span class="line"><span class="string">            class: <span class="subst">$&#123;el.attrsMap &amp;&amp; el.attrsMap[<span class="string">&#x27;class&#x27;</span>]&#125;</span>,</span></span><br><span class="line"><span class="string">        &#125;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">            children ? <span class="string">`,<span class="subst">$&#123;children&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        &#125;</span>)`</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generate-1"><a href="#generate-1" class="headerlink" title="generate"></a>generate</h3><p>最后我们使用上面的函数来实现 <code>generate</code>，其实很简单，我们只需要将整个 AST 传入后判断是否为空，为空则返回一个 div 标签，否则通过 <code>generate</code> 来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span> (<span class="params">rootAst</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> code = rootAst ? genElement(rootAst) : <span class="string">&#x27;_c(&quot;div&quot;)&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        render: <span class="string">`with(this)&#123;return <span class="subst">$&#123;code&#125;</span>&#125;`</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经历过这些过程以后，我们已经把 template 顺利转成了 render function 了，接下来我们将介绍 <code>patch</code> 的过程，来看一下具体 VNode 节点如何进行差异的比对。</p><p>注：本节代码参考[《template 模板是怎样通过 Compile 编译的》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8Atemplate">https://github.com/answershuto/VueDemo/blob/master/《template</a> 模板是怎样通过 Compile 编译的》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;template-模板是怎样通过-Compile-编译的&quot;&gt;&lt;a href=&quot;#template-模板是怎样通过-Compile-编译的&quot; class=&quot;headerlink&quot; title=&quot;template 模板是怎样通过 Compile 编译的&quot;&gt;&lt;/a&gt;te</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制04</title>
    <link href="http://example.com/2021/08/07/vue2-core04/"/>
    <id>http://example.com/2021/08/07/vue2-core04/</id>
    <published>2021-08-07T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:56.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现-Virtual-DOM-下的一个-VNode-节点"><a href="#实现-Virtual-DOM-下的一个-VNode-节点" class="headerlink" title="实现 Virtual DOM 下的一个 VNode 节点"></a>实现 Virtual DOM 下的一个 VNode 节点</h2><h2 id="什么是VNode"><a href="#什么是VNode" class="headerlink" title="什么是VNode"></a>什么是VNode</h2><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><h2 id="实现一个VNode"><a href="#实现一个VNode" class="headerlink" title="实现一个VNode"></a>实现一个VNode</h2><p>VNode 归根结底就是一个 JavaScript 对象，只要这个类的一些属性可以正确直观地描述清楚当前节点的信息即可。我们来实现一个简单的 <code>VNode</code> 类，加入一些基本属性，为了便于理解，我们先不考虑复杂的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params">tag, data, children, text, elm</span>) &#123;</span><br><span class="line">        <span class="comment">/*当前节点的标签名*/</span></span><br><span class="line">        <span class="built_in">this</span>.tag = tag;</span><br><span class="line">        <span class="comment">/*当前节点的一些数据信息，比如props、attrs等数据*/</span></span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="comment">/*当前节点的子节点，是一个数组*/</span></span><br><span class="line">        <span class="built_in">this</span>.children = children;</span><br><span class="line">        <span class="comment">/*当前节点的文本*/</span></span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">        <span class="comment">/*当前虚拟节点对应的真实dom节点*/</span></span><br><span class="line">        <span class="built_in">this</span>.elm = elm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我目前有这么一个 Vue 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;demo&quot;</span> v-show=<span class="string">&quot;isShow&quot;</span>&gt;</span><br><span class="line">    This is a span.</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>用 JavaScript 代码形式就是这样的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VNode(</span><br><span class="line">        <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 指令集合数组 */</span></span><br><span class="line">            directives: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* v-show指令 */</span></span><br><span class="line">                    rawName: <span class="string">&#x27;v-show&#x27;</span>,</span><br><span class="line">                    expression: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">                    name: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                    value: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">/* 静态class */</span></span><br><span class="line">            staticClass: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [ <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="string">&#x27;This is a span.&#x27;</span>) ]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看转换成 VNode 以后的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">&#x27;span&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">/* 指令集合数组 */</span></span><br><span class="line">        directives: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* v-show指令 */</span></span><br><span class="line">                rawName: <span class="string">&#x27;v-show&#x27;</span>,</span><br><span class="line">                expression: <span class="string">&#x27;isShow&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">                value: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">/* 静态class */</span></span><br><span class="line">        staticClass: <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    text: <span class="literal">undefined</span>,</span><br><span class="line">    children: [</span><br><span class="line">        <span class="comment">/* 子节点是一个文本VNode节点 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="literal">undefined</span>,</span><br><span class="line">            data: <span class="literal">undefined</span>,</span><br><span class="line">            text: <span class="string">&#x27;This is a span.&#x27;</span>,</span><br><span class="line">            children: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以将 VNode 进一步封装一下，可以实现一些产生常用 VNode 的方法。</p><ul><li>创建一个空节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createEmptyVNode</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> VNode();</span><br><span class="line">    node.text = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个文本节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>克隆一个 VNode 节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneVNode</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cloneVnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        node.tag,</span><br><span class="line">        node.data,</span><br><span class="line">        node.children,</span><br><span class="line">        node.text,</span><br><span class="line">        node.elm</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> cloneVnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，VNode 就是一个 JavaScript 对象，用 JavaScript 对象的属性来描述当前节点的一些状态，用 VNode 节点的形式来模拟一棵 Virtual DOM 树。</p><p>注：本节代码参考[《实现 Virtual DOM 下的一个 VNode 节点》](<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%AE%9E%E7%8E%B0">https://github.com/answershuto/VueDemo/blob/master/《实现</a> Virtual DOM 下的一个 VNode 节点》.js)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现-Virtual-DOM-下的一个-VNode-节点&quot;&gt;&lt;a href=&quot;#实现-Virtual-DOM-下的一个-VNode-节点&quot; class=&quot;headerlink&quot; title=&quot;实现 Virtual DOM 下的一个 VNode 节点&quot;&gt;&lt;/a&gt;实现</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制03</title>
    <link href="http://example.com/2021/08/03/vue2-core03/"/>
    <id>http://example.com/2021/08/03/vue2-core03/</id>
    <published>2021-08-03T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式系统的依赖收集追踪原理"><a href="#响应式系统的依赖收集追踪原理" class="headerlink" title="响应式系统的依赖收集追踪原理"></a>响应式系统的依赖收集追踪原理</h2><h2 id="为什么要依赖收集？"><a href="#为什么要依赖收集？" class="headerlink" title="为什么要依赖收集？"></a>为什么要依赖收集？</h2><p><strong>先举个栗子🌰</strong></p><p>我们现在有这么一个 Vue 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template: </span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text2&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        text1: <span class="string">&#x27;text1&#x27;</span>,</span><br><span class="line">        text2: <span class="string">&#x27;text2&#x27;</span>,</span><br><span class="line">        text3: <span class="string">&#x27;text3&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们做了这么一个操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.text3 = <span class="string">&#x27;modify text3&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们修改了 <code>data</code> 中 <code>text3</code> 的数据，但是因为视图中并不需要用到 <code>text3</code> ，所以我们并不需要触发上一章所讲的 <code>cb</code> 函数来更新视图，调用 <code>cb</code> 显然是不正确的。</p><p><strong>再来一个栗子🌰</strong></p><p>假设我们现在有一个全局的对象，我们可能会在多个 Vue 对象中用到它进行展示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalObj = &#123;</span><br><span class="line">    text1: <span class="string">&#x27;text1&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    data: globalObj</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    template:</span><br><span class="line">        <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; </span></span><br><span class="line"><span class="string">        &lt;div&gt;`</span>,</span><br><span class="line">    data: globalObj</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个时候，我们执行了如下操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalObj.text1 = <span class="string">&#x27;hello,text1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们应该需要通知 <code>o1</code> 以及 <code>o2</code> 两个vm实例进行视图的更新，「依赖收集」会让 <code>text1</code> 这个数据知道“哦～有两个地方依赖我的数据，我变化的时候需要通知它们～”。</p><p>最终会形成数据与视图的一种对应关系，如下图。</p><p><img src="https://img.kancloud.cn/5f/b8/5fb8adff0d214c2d2364b40b475e62d5_610x270.gif" alt="img"></p><p>接下来我们来介绍一下「依赖收集」是如何实现的。</p><h2 id="订阅者-Dep"><a href="#订阅者-Dep" class="headerlink" title="订阅者 Dep"></a>订阅者 Dep</h2><p>首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 <code>Watcher</code> 观察者对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="built_in">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了便于理解我们只实现了添加的部分代码，主要是两件事情：</p><ol><li>用 <code>addSub</code> 方法可以在目前的 <code>Dep</code> 对象中增加一个 <code>Watcher</code> 的订阅操作；</li><li>用 <code>notify</code> 方法通知目前 <code>Dep</code> 对象的 <code>subs</code> 中的所有 <code>Watcher</code> 对象触发更新操作。</li></ol><h2 id="观察者-Watcher"><a href="#观察者-Watcher" class="headerlink" title="观察者 Watcher"></a>观察者 Watcher</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">    <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">/* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */</span></span><br><span class="line">        Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新视图的方法 */</span></span><br><span class="line">    update () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;视图更新啦～&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>接下来我们修改一下 <code>defineReactive</code> 以及 Vue 的构造函数，来完成依赖收集。</p><p>我们在闭包中增加了一个 Dep 类的对象，用来收集 <code>Watcher</code> 对象。在对象被「读」的时候，会触发 <code>reactiveGetter</code> 函数把当前的 <code>Watcher</code> 对象（存放在 Dep.target 中）收集到 <code>Dep</code> 类中去。之后如果当该对象被「<strong>写</strong>」的时候，则会触发 <code>reactiveSetter</code> 方法，通知 <code>Dep</code> 类调用 <code>notify</code> 来触发所有 <code>Watcher</code> 对象的 <code>update</code> 方法更新对应视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 一个Dep类对象 */</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* 将Dep.target（即当前的Watcher对象存入dep的subs中） */</span></span><br><span class="line">            dep.addSub(Dep.target);</span><br><span class="line">            <span class="keyword">return</span> val;         </span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */</span></span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._data = options.data;</span><br><span class="line">        observer(<span class="built_in">this</span>._data);</span><br><span class="line">        <span class="comment">/* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */</span></span><br><span class="line">        <span class="keyword">new</span> Watcher();</span><br><span class="line">        <span class="comment">/* 在这里模拟render的过程，为了触发test属性的get函数 */</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render~&#x27;</span>, <span class="built_in">this</span>._data.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下。</p><p>首先在 <code>observer</code> 的过程中会注册 <code>get</code> 方法，该方法用来进行「<strong>依赖收集</strong>」。在它的闭包中会有一个 <code>Dep</code> 对象，这个对象用来存放 Watcher 对象的实例。其实「<strong>依赖收集</strong>」的过程就是把 <code>Watcher</code> 实例存放到对应的 <code>Dep</code> 对象中去。<code>get</code> 方法可以让当前的 <code>Watcher</code> 对象（Dep.target）存放到它的 subs 中（<code>addSub</code>）方法，在数据变化时，<code>set</code> 会调用 <code>Dep</code> 对象的 <code>notify</code> 方法通知它内部所有的 <code>Watcher</code> 对象进行视图更新。</p><p>这是 <code>Object.defineProperty</code> 的 <code>set/get</code> 方法处理的事情，那么「<strong>依赖收集</strong>」的前提条件还有两个：</p><ol><li>触发 <code>get</code> 方法；</li><li>新建一个 Watcher 对象。</li></ol><p>这个我们在 Vue 的构造类中处理。新建一个 <code>Watcher</code> 对象只需要 new 出来，这时候 <code>Dep.target</code> 已经指向了这个 new 出来的 <code>Watcher</code> 对象来。而触发 <code>get</code> 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 <code>get</code> 进行「依赖收集」。</p><p>本章我们介绍了「依赖收集」的过程，配合之前的响应式原理，已经把整个「响应式系统」介绍完毕了。其主要就是 <code>get</code> 进行「依赖收集」。<code>set</code> 通过观察者来更新视图，配合下图仔细捋一捋，相信一定能搞懂它！</p><p><img src="https://img.kancloud.cn/3f/32/3f32fe9400f1f726e6d10eadd342b277_1460x728.gif" alt="img"></p><p>注：本节代码参考<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86%E3%80%8B.js">《响应式系统的依赖收集追踪原理》</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应式系统的依赖收集追踪原理&quot;&gt;&lt;a href=&quot;#响应式系统的依赖收集追踪原理&quot; class=&quot;headerlink&quot; title=&quot;响应式系统的依赖收集追踪原理&quot;&gt;&lt;/a&gt;响应式系统的依赖收集追踪原理&lt;/h2&gt;&lt;h2 id=&quot;为什么要依赖收集？&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Vue+echarts重复渲染循环数据格式</title>
    <link href="http://example.com/2021/07/31/Vue-echarts/"/>
    <id>http://example.com/2021/07/31/Vue-echarts/</id>
    <published>2021-07-31T10:25:06.000Z</published>
    <updated>2021-09-17T08:13:17.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在Vue项目中封装echarts"><a href="#在Vue项目中封装echarts" class="headerlink" title="在Vue项目中封装echarts"></a>在Vue项目中封装echarts</h1><blockquote><p>文章目的：在vue项目中使用echarts针对相同类型的数据渲染，无法定位渲染id和繁琐问题</p></blockquote><h3 id="先看效果图"><a href="#先看效果图" class="headerlink" title="先看效果图"></a>先看效果图</h3><p><img src="/images/Vue-echarts/image-20210814185111072.png" alt="image-20210814185111072"></p><h2 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install echarts</span><br></pre></td></tr></table></figure><h2 id="在main-js中引入依赖"><a href="#在main-js中引入依赖" class="headerlink" title="在main.js中引入依赖"></a>在main.js中引入依赖</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入echarts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">&#x27;echarts&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="在公共的方法文件夹中创建echarts-js文件"><a href="#在公共的方法文件夹中创建echarts-js文件" class="headerlink" title="在公共的方法文件夹中创建echarts.js文件"></a>在公共的方法文件夹中创建echarts.js文件</h2><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/util/echarts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">echarts, id, seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(seriesdata)<span class="comment">//echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">        <span class="built_in">this</span>.echarts = echarts;</span><br><span class="line">        <span class="keyword">let</span> option = <span class="built_in">this</span>.getOption(seriesdata, answerTotal)  <span class="comment">//把参数传递给方法</span></span><br><span class="line">        <span class="keyword">var</span> myChart = <span class="built_in">this</span>.echarts.init(<span class="built_in">document</span>.getElementById(id));<span class="comment">//获取dom</span></span><br><span class="line">        myChart.setOption(option);     <span class="comment">//暴露出去</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOption</span>(<span class="params">seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> option = &#123;</span><br><span class="line">            <span class="comment">// 环形中间的标题</span></span><br><span class="line">            title: &#123;</span><br><span class="line">                text: answerTotal + <span class="string">&quot;人&quot;</span>,</span><br><span class="line">                left: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                top: <span class="string">&quot;50%&quot;</span>,</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                    color: <span class="string">&quot;#27D9C8&quot;</span>,</span><br><span class="line">                    fontSize: <span class="number">18</span>,</span><br><span class="line">                    align: <span class="string">&quot;center&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 环形中间的标题</span></span><br><span class="line">            graphic: &#123;</span><br><span class="line">                type: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                left: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                top: <span class="string">&quot;40%&quot;</span>,</span><br><span class="line">                style: &#123;</span><br><span class="line">                    text: <span class="string">&quot;实测&quot;</span>,</span><br><span class="line">                    textAlign: <span class="string">&quot;center&quot;</span>,</span><br><span class="line">                    fill: <span class="string">&quot;#333&quot;</span>,</span><br><span class="line">                    fontSize: <span class="number">18</span>,</span><br><span class="line">                    fontWeight: <span class="number">700</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            legend: &#123;</span><br><span class="line">                show: <span class="literal">false</span>, <span class="comment">//图例显示与隐藏</span></span><br><span class="line">            &#125;,</span><br><span class="line">            series: [</span><br><span class="line">                &#123;</span><br><span class="line">                    type: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">                    <span class="comment">// roseType: &#x27;area&#x27;,</span></span><br><span class="line">                    radius: [<span class="string">&#x27;40%&#x27;</span>, <span class="string">&#x27;60%&#x27;</span>],</span><br><span class="line">                    center: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line"></span><br><span class="line">                    label: &#123;</span><br><span class="line">                        alignTo: <span class="string">&#x27;edge&#x27;</span>,</span><br><span class="line">                        formatter: <span class="string">&#x27;&#123;name|&#123;b&#125;&#125;\n&#123;time|&#123;c&#125; 人&#125;&#x27;</span>,</span><br><span class="line">                        minMargin: <span class="number">5</span>,</span><br><span class="line">                        edgeDistance: <span class="number">10</span>,</span><br><span class="line">                        lineHeight: <span class="number">15</span>,</span><br><span class="line">                        rich: &#123;</span><br><span class="line">                            time: &#123;</span><br><span class="line">                                fontSize: <span class="number">10</span>,</span><br><span class="line">                                color: <span class="string">&#x27;#999&#x27;</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    itemStyle: &#123;</span><br><span class="line">                        normal: &#123;</span><br><span class="line">                            color: <span class="function"><span class="keyword">function</span> (<span class="params">colors</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> colorList = [<span class="string">&#x27;#FF8400&#x27;</span>, <span class="string">&#x27;#EEC23A&#x27;</span>, <span class="string">&#x27;#EEE93A&#x27;</span>, <span class="string">&#x27;#CCCCCC&#x27;</span>];</span><br><span class="line">                                <span class="keyword">return</span> colorList[colors.dataIndex]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        shadowBlur: <span class="number">200</span>,</span><br><span class="line">                        shadowColor: <span class="string">&#x27;rgba(0, 0, 0, 0.5)&#x27;</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    data: seriesdata,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="在Vue所需echarts文件中引入该echarts-js文件"><a href="#在Vue所需echarts文件中引入该echarts-js文件" class="headerlink" title="在Vue所需echarts文件中引入该echarts.js文件"></a>在Vue所需echarts文件中引入该echarts.js文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入封装的echarts方法</span></span><br><span class="line"><span class="keyword">import</span> echarts <span class="keyword">from</span> <span class="string">&quot;@/util/echarts.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="规划好echarts放置的地方"><a href="#规划好echarts放置的地方" class="headerlink" title="规划好echarts放置的地方"></a>规划好echarts放置的地方</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px; height: 400px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> //echarts存放的div</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实例化一个渲染echarts的方法"><a href="#实例化一个渲染echarts的方法" class="headerlink" title="实例化一个渲染echarts的方法"></a>实例化一个渲染echarts的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">addEcharts</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> echarts(<span class="built_in">this</span>.$echarts, <span class="string">&quot;main&quot;</span>, <span class="built_in">this</span>.seriesdata,<span class="built_in">this</span>.answerTotal);  </span><br><span class="line">      <span class="comment">//echarts传参，this.$echarts声明是echarts，main是div的ID, this.seriesdata,this.answerTotal是传递参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="在Vue生命周期mounted阶段调用该方法"><a href="#在Vue生命周期mounted阶段调用该方法" class="headerlink" title="在Vue生命周期mounted阶段调用该方法"></a>在Vue生命周期mounted阶段调用该方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.addEcharts();  <span class="comment">//调用组件的时候自动调用这个方法</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="效果如下："><a href="#效果如下：" class="headerlink" title="效果如下："></a>效果如下：</h2><p><img src="/images/Vue-echarts/image-20210814185044874.png" alt="image-20210814185044874"></p><h2 id="可能遇到的问题（待补充）"><a href="#可能遇到的问题（待补充）" class="headerlink" title="可能遇到的问题（待补充）"></a>可能遇到的问题（待补充）</h2><h3 id="echarts-js-5fd2-7-Uncaught-in-promise-TypeError-Cannot-read-property-‘init’-of-undefined"><a href="#echarts-js-5fd2-7-Uncaught-in-promise-TypeError-Cannot-read-property-‘init’-of-undefined" class="headerlink" title="echarts.js?5fd2:7 Uncaught (in promise) TypeError: Cannot read property ‘init’ of undefined"></a>echarts.js?5fd2:7 Uncaught (in promise) TypeError: Cannot read property ‘init’ of undefined</h3><p><img src="/images/Vue-echarts/image-20210814184516054.png" alt="image-20210814184516054"></p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><p>对于数据加载和dom初始化过程，如果不加限制 使用echarts 绘图的js方法<strong>有很大机率</strong>先于dom初始完成之前运行，所以造成图表不显示。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>使用setTimeout函数延迟运行绘图的js.时间在500毫秒左右,可根据情况调整；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @/util/echarts.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">echarts, id, seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(seriesdata)<span class="comment">//echarts, id, seriesdata,answerTotal都是vue组件中传递过来的参数</span></span><br><span class="line">        <span class="built_in">this</span>.echarts = echarts;</span><br><span class="line">        <span class="keyword">let</span> option = <span class="built_in">this</span>.getOption(seriesdata, answerTotal)  <span class="comment">//把参数传递给方法</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改的地方👇👇👇</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myChart = <span class="built_in">this</span>.echarts.init(<span class="built_in">document</span>.getElementById(id));<span class="comment">//获取dom</span></span><br><span class="line">        myChart.setOption(option);     <span class="comment">//暴露出去</span></span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">        <span class="comment">// 修改的地方👆👆👆</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">getOption</span>(<span class="params">seriesdata, answerTotal</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> option = &#123;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            ...(中间均未发生改变)</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">                    &#125;,</span><br><span class="line">                    data: seriesdata,</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> option;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在Vue项目中封装echarts&quot;&gt;&lt;a href=&quot;#在Vue项目中封装echarts&quot; class=&quot;headerlink&quot; title=&quot;在Vue项目中封装echarts&quot;&gt;&lt;/a&gt;在Vue项目中封装echarts&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;文</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="项目学习" scheme="http://example.com/categories/Vue/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Project" scheme="http://example.com/tags/Project/"/>
    
    <category term="echarts" scheme="http://example.com/tags/echarts/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制02</title>
    <link href="http://example.com/2021/07/31/vue2-core02/"/>
    <id>http://example.com/2021/07/31/vue2-core02/</id>
    <published>2021-07-31T07:17:49.000Z</published>
    <updated>2021-09-17T08:11:24.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应式系统的基本原理"><a href="#响应式系统的基本原理" class="headerlink" title="响应式系统的基本原理"></a>响应式系统的基本原理</h2><h2 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h2><p>Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「<strong>响应式系统</strong>」。尽管我们在使用 Vue.js 进行开发时不会直接修改「<strong>响应式系统</strong>」，但是理解它的实现有助于避开一些常见的「<strong>坑</strong>」，也有助于在遇见一些琢磨不透的问题时可以深入其原理来解决它。</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a><code>Object.defineProperty</code></h2><p>首先我们来介绍一下 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a>，Vue.js就是基于它实现「<strong>响应式系统</strong>」的。</p><p>首先是使用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    obj: 目标对象</span></span><br><span class="line"><span class="comment">    prop: 需要操作的目标对象的属性名</span></span><br><span class="line"><span class="comment">    descriptor: 描述符</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    return value 传入对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><p>descriptor的一些属性，简单介绍几个属性，具体可以参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN 文档</a>。</p><ul><li><code>enumerable</code>，属性是否可枚举，默认 false。</li><li><code>configurable</code>，属性是否可以被修改或者删除，默认 false。</li><li><code>get</code>，获取属性的方法。</li><li><code>set</code>，设置属性的方法。</li></ul><h2 id="实现-observer（可观察的）"><a href="#实现-observer（可观察的）" class="headerlink" title="实现 observer（可观察的）"></a>实现 <code>observer</code>（可观察的）</h2><p>知道了 <code>Object.defineProperty</code> 以后，我们来用它使对象变成可观察的。</p><p>这一部分的内容我们在第二小节中已经初步介绍过，在 <code>init</code> 的阶段会进行初始化，对数据进行「<strong>响应式化</strong>」。</p><p><img src="https://img.kancloud.cn/c4/dd/c4dd695d1c4423aeb8ea55e67fff486d_828x336.gif" alt="img"></p><p>为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。</p><p>首先我们定义一个 <code>cb</code> 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 渲染视图 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;视图更新啦～&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义一个 <code>defineReactive</code> ，这个方法通过 <code>Object.defineProperty</code> 来实现对对象的「<strong>响应式</strong>」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 <code>defineReactive</code> 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 <code>reactiveGetter</code> 方法，而在该属性被「写」的时候则会触发 <code>reactiveSetter</code> 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,       <span class="comment">/* 属性可枚举 */</span></span><br><span class="line">        configurable: <span class="literal">true</span>,     <span class="comment">/* 属性可被修改或删除 */</span></span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> val;         <span class="comment">/* 实际上会依赖收集，下一小节会讲 */</span></span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line">            cb(newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这是不够的，我们需要在上面再封装一层 <code>observer</code> 。这个函数传入一个 value（需要「<strong>响应式</strong>」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 <code>defineReactive</code> 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value || (<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        defineReactive(value, key, value[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，让我们用 <code>observer</code> 来封装一个 Vue 吧！</p><p>在 Vue 的构造函数中，对 <code>options</code> 的 <code>data</code> 进行处理，这里的 <code>data</code> 想必大家很熟悉，就是平时我们在写 Vue 项目时组件中的 <code>data</code> 属性（实际上是一个函数，这里当作一个对象来简单处理）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Vue构造类 */</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._data = options.data;</span><br><span class="line">        observer(<span class="built_in">this</span>._data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们只要 new 一个 Vue 对象，就会将 <code>data</code> 中的数据进行「<strong>响应式</strong>」化。如果我们对 <code>data</code> 的属性进行下面的操作，就会触发 <code>cb</code> 方法更新视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: <span class="string">&quot;I am test.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o._data.test = <span class="string">&quot;hello,world.&quot;</span>;  <span class="comment">/* 视图更新啦～ */</span></span><br></pre></td></tr></table></figure><p>至此，响应式原理已经介绍完了，接下来让我们学习「<strong>响应式系统</strong>」的另一部分 ——「<strong>依赖收集</strong>」。</p><p>注：本节代码参考<a href="https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%8B.js">《响应式系统的基本原理》</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应式系统的基本原理&quot;&gt;&lt;a href=&quot;#响应式系统的基本原理&quot; class=&quot;headerlink&quot; title=&quot;响应式系统的基本原理&quot;&gt;&lt;/a&gt;响应式系统的基本原理&lt;/h2&gt;&lt;h2 id=&quot;响应式系统&quot;&gt;&lt;a href=&quot;#响应式系统&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>剖析vue.js内部运行机制01</title>
    <link href="http://example.com/2021/07/27/vue2-core01/"/>
    <id>http://example.com/2021/07/27/vue2-core01/</id>
    <published>2021-07-27T07:17:49.000Z</published>
    <updated>2021-09-17T08:07:02.359Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自<a href="https://www.kancloud.cn/sllyli/vuejs">看云</a>《剖析vue.js内部运行机制》</p><h2 id="Vue-js-运行机制全局概览"><a href="#Vue-js-运行机制全局概览" class="headerlink" title="Vue.js 运行机制全局概览"></a>Vue.js 运行机制全局概览</h2><h2 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h2><p>这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。</p><p>首先我们来看一下笔者画的内部流程图。</p><p><img src="https://img.kancloud.cn/01/db/01db136b4380b1804c072899e92daa3d_1752x1216.gif" alt="img"></p><p>大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。</p><h2 id="初始化及挂载"><a href="#初始化及挂载" class="headerlink" title="初始化及挂载"></a>初始化及挂载</h2><p><img src="https://img.kancloud.cn/c4/dd/c4dd695d1c4423aeb8ea55e67fff486d_828x336.gif" alt="img"></p><p>在 <code>new Vue()</code> 之后。 Vue 会调用 <code>_init</code> 函数进行初始化，也就是这里的 <code>init</code> 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 <code>Object.defineProperty</code> 设置 <code>setter</code> 与 <code>getter</code> 函数，用来实现「<strong>响应式</strong>」以及「<strong>依赖收集</strong>」，后面会详细讲到，这里只要有一个印象即可。</p><p>初始化之后调用 <code>$mount</code> 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「<strong>编译</strong>」步骤。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>compile编译可以分成 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 三个阶段，最终需要得到 render function。</p><p><img src="https://img.kancloud.cn/7e/80/7e80fcd4e490557058f4e19af76e5795_824x496.gif" alt="img"></p><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p><code>parse</code> 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。</p><h3 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h3><p><code>optimize</code> 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 <code>update</code> 更新界面时，会有一个 <code>patch</code> 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 <code>patch</code> 的性能。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p><code>generate</code> 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。</p><p>在经历过 <code>parse</code>、<code>optimize</code> 与 <code>generate</code> 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>接下来也就是 Vue.js 响应式核心部分。</p><p><img src="https://img.kancloud.cn/3f/32/3f32fe9400f1f726e6d10eadd342b277_1460x728.gif" alt="img"></p><p>这里的 <code>getter</code> 跟 <code>setter</code> 已经在之前介绍过了，在 <code>init</code> 的时候通过 <code>Object.defineProperty</code> 进行了绑定，它使得当被设置的对象被读取的时候会执行 <code>getter</code> 函数，而在当被赋值的时候会执行 <code>setter</code> 函数。</p><p>当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 <code>getter</code> 函数进行「<strong>依赖收集</strong>」，「<strong>依赖收集</strong>」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。</p><p><img src="https://img.kancloud.cn/43/c8/43c84091dc595cdf3eb9db090b7aec13_520x245.gif" alt="img"></p><p>在修改对象的值的时候，会触发对应的 <code>setter</code>， <code>setter</code> 通知之前「<strong>依赖收集</strong>」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 <code>update</code> 来更新视图，当然这中间还有一个 <code>patch</code> 的过程以及使用队列来异步更新的策略，这个我们后面再讲。</p><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><p>比如说下面这样一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: <span class="string">&#x27;div&#x27;</span>,                 <span class="comment">/*说明这是一个div标签*/</span></span><br><span class="line">    children: [                 <span class="comment">/*存放该标签的子节点*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">&#x27;a&#x27;</span>,           <span class="comment">/*说明这是一个a标签*/</span></span><br><span class="line">            text: <span class="string">&#x27;click me&#x27;</span>    <span class="comment">/*标签的内容*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染后可以得到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a&gt;click me&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。</p><h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p><img src="https://img.kancloud.cn/d1/dc/d1dc77e6aec6a13caa86bc32afd24509_731x339.gif" alt="img"></p><p>前面我们说到，在修改一个对象值的时候，会通过 <code>setter -&gt; Watcher -&gt; update</code> 的流程来修改对应的视图，那么最终是如何更新视图的呢？</p><p>当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 <code>innerHTML</code> 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「<strong>浪费</strong>」。</p><p>那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「**<code>patch</code><strong>」了。我们会将新的 VNode 与旧的 VNode 一起传入 <code>patch</code> 进行比较，经过 diff 算法得出它们的「</strong>差异<strong>」。最后我们只需要将这些「</strong>差异**」的对应 DOM 进行修改即可。</p><h2 id="再看全局"><a href="#再看全局" class="headerlink" title="再看全局"></a>再看全局</h2><p><img src="https://img.kancloud.cn/01/db/01db136b4380b1804c072899e92daa3d_1752x1216.gif" alt="img"></p><p>回过头再来看看这张图，是不是大脑中已经有一个大概的脉络了呢？</p><p><strong>那么，让我们继续学习每一个模块吧!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章转载自&lt;a href=&quot;https://www.kancloud.cn/sllyli/vuejs&quot;&gt;看云&lt;/a&gt;《剖析vue.js内部运行机制》&lt;/p&gt;
&lt;h2 id=&quot;Vue-js-运行机制全局概览&quot;&gt;&lt;a href=&quot;#Vue-js-运行机制全局概览&quot; class=</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="源码" scheme="http://example.com/categories/Vue/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="vue源码" scheme="http://example.com/tags/vue%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>前端面试exp01</title>
    <link href="http://example.com/2021/07/15/interview-exp01/"/>
    <id>http://example.com/2021/07/15/interview-exp01/</id>
    <published>2021-07-15T06:33:12.000Z</published>
    <updated>2021-09-17T06:54:53.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍-amp-项目介绍"><a href="#自我介绍-amp-项目介绍" class="headerlink" title="自我介绍 &amp; 项目介绍"></a>自我介绍 &amp; 项目介绍</h2><h2 id="从用户输入URL到看到页面，这个过程中都发生了什么？"><a href="#从用户输入URL到看到页面，这个过程中都发生了什么？" class="headerlink" title="从用户输入URL到看到页面，这个过程中都发生了什么？"></a>从用户输入URL到看到页面，这个过程中都发生了什么？</h2><p><img src="/images/interview-exp01/image-20210904205421204.png" alt="image-20210904205421204"></p><h2 id="defer-amp-async-的区别"><a href="#defer-amp-async-的区别" class="headerlink" title="defer &amp; async 的区别"></a>defer &amp; async 的区别</h2><p> defer与async的区别是：前者要等到整个页面正常渲染结束，才会执行；后者一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。 一句话，defer是“渲染完再执行”，async是“下载完就执行”。 另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</p><h2 id="为什么加载同步script标签中的内容会阻塞文档渲染？"><a href="#为什么加载同步script标签中的内容会阻塞文档渲染？" class="headerlink" title="为什么加载同步script标签中的内容会阻塞文档渲染？"></a>为什么加载同步script标签中的内容会阻塞文档渲染？</h2><p>JavaScript是单线程的语言。</p><p>单线程意味着什麽呢？意味着一次只能干一件事。这条线程，被JavaScript的执行和浏览器的渲染所共享（也就是说两者用的均是这一条线程，浏览器在某个时间点只能执行JS或渲染UI一个动作）。</p><h2 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h2><p><img src="/images/interview-exp01/image-20210917144847187.png" alt="image-20210917144847187"></p><p><img src="/images/interview-exp01/image-20210917144858432.png" alt="image-20210917144858432"></p><h2 id="对BFC语法规范的理解？"><a href="#对BFC语法规范的理解？" class="headerlink" title="对BFC语法规范的理解？"></a>对BFC语法规范的理解？</h2><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。可以把它理解成一个独立的区域</p><p>另外还有个概念叫<code>IFC</code>（IFC的line box（线框高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响）。不过，<code>BFC</code>问得更多。</p><p><strong>如何生成BFC</strong></p><p>1、overflow<code>: 不为</code>visible</p><p>2、浮动中：不为none</p><p>3、定位中：不为static</p><p>4、display：flex，inline-block</p><h2 id="对“闭包”的理解？"><a href="#对“闭包”的理解？" class="headerlink" title="对“闭包”的理解？"></a>对“闭包”的理解？</h2><p>　　在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。</p><p><strong>优点：</strong></p><p>1、可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用。</p><p>2、避免变量污染全局。</p><p>3、把变量存到独立的作用域，作为私有成员存在。</p><p><strong>缺点：</strong></p><p>1、对内存消耗有负面影响，因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏。</p><p>2、对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域长度。</p><h2 id="防抖-amp-节流-的原理及应用场景？"><a href="#防抖-amp-节流-的原理及应用场景？" class="headerlink" title="防抖 &amp; 节流 的原理及应用场景？"></a>防抖 &amp; 节流 的原理及应用场景？</h2><p>1、基本概念</p><p> 防抖：最后一次点击事件后time过后才会执行</p><p>节流：持续触发事件时，保证一定time内执行一次</p><p>2、分别适合用在什么场景：</p><p>防抖：input   </p><p>节流：resize   scroll</p><h2 id="滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景"><a href="#滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景" class="headerlink" title="滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景"></a>滚动条滚动时触发的scroll事件对应的event对象的组成以及各属性的使用场景</h2><p>①scrollTop/scrollLeft:滚动的距离，一开始默认都是0，往下滚动scrollTop增加，往右scrollLeft增加。</p><p>②scrollHeight/scrollWidth:整个页面内容的大小，包括被隐藏的部分。</p><p>③clientHeight/clientWidth:视图显示部分的大小</p><p>①判断滚动方向，记录之前的scrollTop，scrollLeft，然后触发后进行比较判断</p><p>②判断是否到达顶部底部，scrollTop+clientHeight == scrollHeight到达底部</p><h2 id="JS的异步处理函数有哪些？（具体阐述，ES5-–-gt-ES6）"><a href="#JS的异步处理函数有哪些？（具体阐述，ES5-–-gt-ES6）" class="headerlink" title="JS的异步处理函数有哪些？（具体阐述，ES5 –&gt; ES6）"></a>JS的异步处理函数有哪些？（具体阐述，ES5 –&gt; ES6）</h2><p>setTimeout、setInterval、promise、async await</p><h2 id="关于async和await的应用场景题"><a href="#关于async和await的应用场景题" class="headerlink" title="关于async和await的应用场景题"></a>关于async和await的应用场景题</h2><p> 一个请求接着一个请求：后一个请求依赖前一个请求返回值</p><p> 请求后的错误处理：使用 try/catch 直接捕获</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">imageCrawler</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">await</span> getImage(url)</span><br><span class="line">        <span class="keyword">return</span> img</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）"><a href="#浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）" class="headerlink" title="浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）"></a>浏览器的异步处理队列？（宏任务和微任务，具体有哪些？）</h2><p>宏任务：整体代码，setTimeout，setInterval，I/O操作</p><p>微任务：new Promise().then ，MutaionObserver（前端的回溯）</p><p>Node V10以后和浏览器的行为统一了：先执行完一轮宏任务，再去清空微任务队列.</p><h2 id="Vue的双向数据绑定原理"><a href="#Vue的双向数据绑定原理" class="headerlink" title="Vue的双向数据绑定原理"></a>Vue的双向数据绑定原理</h2><p>利用Object.defineProperty()数据劫持，结合发布者-订阅者模式实现的。</p><p><strong>数据劫持</strong>：Object.defineProperty()：简单的说 就是用这个方法来定义一个值。当调用时我们使用了它里面的get方法，当我们给这个属性赋值的时候，又用到了它里面的set方法</p><p><strong>发布者-订阅者</strong>：</p><p> 前面所讲的数据劫持，其实就是为属性创建了一个观察者对象，监听数据的变化。接下来就是创建发布类和订阅类，如下：</p><p><img src="https://img-blog.csdnimg.cn/20190420173653318.png" alt="img"></p><p><strong>observer</strong>，创建数据监听，并为每个属性建立一个发布类。</p><p><strong>Dep</strong>是发布类，维护与该属性相关的订阅实例，当数据发生更新时，会通知所有的订阅实例。</p><p><strong>Watcher</strong>是订阅类，注册到所有相关属性的Dep发布类中，接受发布类的数据变更通知，通过回调，实现视图的更新。</p><h2 id="Vue的diff算法"><a href="#Vue的diff算法" class="headerlink" title="Vue的diff算法"></a>Vue的diff算法</h2><p><code>diff</code> 算法只对同级节点进行对比</p><p>都用key做为唯一标识，进行查找，只有key和标签类型相同时才会复用老节点（遍历前都会根据老的节点构建一个map，方便根据key快速查找）</p><p>ps：与react不同的是，react 采用从左向右进行遍历</p><h2 id="使用v-for渲染列表是key值的作用？"><a href="#使用v-for渲染列表是key值的作用？" class="headerlink" title="使用v-for渲染列表是key值的作用？"></a>使用v-for渲染列表是key值的作用？</h2><p>key的作用让列表中每个item都有一个唯一的识别身份，可以下标值index或者id, 主要是为了vue精准的追踪到每一个元素，高效的更新虚拟DOM。</p><h2 id="项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）"><a href="#项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）" class="headerlink" title="项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）"></a>项目中的商品列表使用懒加载之后，还存在哪些不足？怎么优化？（虚拟列表）</h2><p><strong>原理：</strong>首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域,如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。<br><strong>优点：</strong>页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好</p><p><strong>不足：</strong>数据量大的时候，加载速度依旧很慢</p><p><strong>优化：</strong>缩略图格式（压缩资源大小）</p><h2 id="项目中遇到的问题？"><a href="#项目中遇到的问题？" class="headerlink" title="项目中遇到的问题？"></a>项目中遇到的问题？</h2><h3 id="使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义"><a href="#使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义" class="headerlink" title="使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义"></a>使用echarts针对相同类型的数据无法渲染，echarts渲染区域未定义</h3><p>this.$nextTick()将回调延迟到下次 DOM 更新之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。</p><p>由于dom元素还没有更新， 因此打印出来的还是未改变之前的值，而通过this.$nextTick()获取到的值为dom更新之后的值</p><h2 id="小程序的样式适配怎么做的"><a href="#小程序的样式适配怎么做的" class="headerlink" title="小程序的样式适配怎么做的"></a>小程序的样式适配怎么做的</h2><p>小程序的适配原理，提出了一种新单位rpx，可以根据屏幕宽度进行自适应，规定屏幕宽为750rpx</p><p><strong>微信官方提供的换算方式</strong>：rpx = px * (目标设备宽 px 值 / 750)</p><p>在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。</p><p><strong>一般情况设计稿是按照iphone6尺寸设计的，设计稿上尺寸大小可以直接等于rpx</strong></p><h2 id="CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置"><a href="#CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置" class="headerlink" title="CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置"></a>CSS弹性布局，如果想给容器里面某一个项目设置在交叉轴上的排列与其他不同怎么设置</h2><p>flex布局下的一个属性：align-self</p><h2 id="CSS选择器（常见的，伪类选择器用过哪些，-before-after应用场景）"><a href="#CSS选择器（常见的，伪类选择器用过哪些，-before-after应用场景）" class="headerlink" title="CSS选择器（常见的，伪类选择器用过哪些，::before ::after应用场景）"></a>CSS选择器（常见的，伪类选择器用过哪些，::before ::after应用场景）</h2><p>常见伪类——:hover,:link,:active,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让超链接点击之前是红色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*让超链接点击之后是橙色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: orange;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标悬停，放到标签上的时候是绿色*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: green;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*鼠标点击链接，但是不松手的时候*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>: black;&#125;</span><br></pre></td></tr></table></figure><p>常见伪元素——::before,::after,</p><p>::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。</p><p>这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。</p><p>所以不要用:before或:after展示有实际意义的内容，尽量使用它们显示修饰性内容，例如图标。</p><p>举例：网站有些联系电话，希望在它们前加一个icon☎，就可以使用:before伪元素，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.phoneNumber</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;\260E&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;phoneNumber&quot;</span>&gt;</span>12345645654<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最常用的就是清除浮动</p><h2 id="选择器优先级排列"><a href="#选择器优先级排列" class="headerlink" title="选择器优先级排列"></a>选择器优先级排列</h2><p>内联样式 =&gt; id(id选择器) =&gt; class(类选择器) =&gt; div(标签选择器) =&gt; ul&gt;li子选择器() =&gt; li a(后代选择器) =&gt; a:hover(伪类选择器) </p><p><strong>选择器的权值加到一起，大的优先；如果权值相同，后定义的优先</strong> </p><h2 id="CSS函数用过嘛？常见的calc-函数-计算长度值，-var"><a href="#CSS函数用过嘛？常见的calc-函数-计算长度值，-var" class="headerlink" title="CSS函数用过嘛？常见的calc()函数 计算长度值， var()"></a>CSS函数用过嘛？常见的calc()函数 计算长度值， var()</h2><h3 id="calc"><a href="#calc" class="headerlink" title="calc()"></a>calc()</h3><p>这个函数使我们能够计算CSS值，而不是指定确切的值。通常用于计算元素的大小或位置。它支持加法、减法、乘法和除法。</p><p><strong>需要特别注意重要一点</strong>是<code>+</code>和<code>-</code>运算符<strong>必须用空格隔开</strong>，不然无法正常工作。<code>*</code>和<code>/</code>运算符不有这限制，但出于一致性的考虑，建议添加空格。</p><p>实践例子：水平居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;calc&quot;</span>&gt;</span>Centered with calc<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.calc</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">100px</span>)//页面总长度的一半减去自身长度的一半</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="var"><a href="#var" class="headerlink" title="var()"></a>var()</h3><p>通过这个函数，我们可以使用一个自定义属性的值作为另一个CSS属性的值。简单地说，可以定义一个颜色，放在自定义属性(CSS变量)中，然后通过调用var函数重用该属性值。</p><p>此函数接受两个参数，即自定义属性和一个默认值，如果出现问题，将使用默认值。</p><p>实践例子：一个网站的主题色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --bg-<span class="attribute">color</span>: green;//通过 --前缀来实现自定义</span><br><span class="line">  --<span class="attribute">color</span>: white</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.var</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg-color);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js如何判断数组-Array-isArray-instanceof-原理"><a href="#js如何判断数组-Array-isArray-instanceof-原理" class="headerlink" title="js如何判断数组  Array.isArray()   instanceof 原理"></a>js如何判断数组  Array.isArray()   instanceof 原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单理解就是运用对象原型的toString方法将Array转换为字符串，之后进行比对，下面我们来详细分析下各个部分的组成。<br>Object.prototype.toString代表这个toString方法本来是对象原型上面的，之后call方法将toString方法中的this转换为参数value，这样传进的参数value（实际上对于此方法应该是个数组[]）就可以通过原型的方法来转换为字符串。</p><h3 id="value-instanceof-Type-true-false"><a href="#value-instanceof-Type-true-false" class="headerlink" title="value instanceof Type == true/false"></a>value instanceof Type == true/false</h3><p> instanceof实现原理：看左边实例的–proto–指向的原型链上，有没有跟右侧类型的prototype指向同一个对象</p><h2 id="JS对象深拷贝"><a href="#JS对象深拷贝" class="headerlink" title="JS对象深拷贝"></a>JS对象深拷贝</h2><p>使用JSON.parse（）和 JSON.stringify（）对对象进行深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(会忽略function和undefined的字段，只能克隆原始对象自身的值，不能克隆它继承的值)</p><h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="事件循环（Event-Loop）机制"><a href="#事件循环（Event-Loop）机制" class="headerlink" title="事件循环（Event Loop）机制"></a>事件循环（Event Loop）机制</h2><p>js是单线程的 </p><p>宏任务：整体代码，setTimeout，setInterval，I/O操作</p><p>微任务：new Promise（）.then ，MutaionObserver（前端的回溯）</p><h2 id="二分法查找时间复杂度O-logn-、-快排时间复杂度O-nlogn"><a href="#二分法查找时间复杂度O-logn-、-快排时间复杂度O-nlogn" class="headerlink" title="二分法查找时间复杂度O(logn)、 快排时间复杂度O(nlogn)"></a>二分法查找时间复杂度O(logn)、 快排时间复杂度O(nlogn)</h2><p>二分查找：假设一个数组长度为n,每次查找后数据长度减半，第一次查找后数据长度为n/2,第二次查找后数据长度为n/(2的2次方)，第k次查找后数据长度为n/(2的k次方)，最坏情况下数数据长度为1时找到该数，即n/(2的k次方)=1, 解得k=log2n</p><p>快排基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>冒泡排序：O(n^2)</p><h2 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h2><p>栈：先进后出</p><p>队列：先进先出</p><h2 id="打印二叉树用什么数据结构"><a href="#打印二叉树用什么数据结构" class="headerlink" title="打印二叉树用什么数据结构"></a>打印二叉树用什么数据结构</h2><p> 队列</p><h2 id="遍历对象和数组的方法"><a href="#遍历对象和数组的方法" class="headerlink" title="遍历对象和数组的方法"></a>遍历对象和数组的方法</h2><p>遍历对象：for…in、Object.keys().forEach()</p><p>遍历数组：forEach、map、for循环遍历、for…in、for…of(只能遍历出value，无下标)</p><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><h3 id="大概多久出面试结果？"><a href="#大概多久出面试结果？" class="headerlink" title="大概多久出面试结果？"></a>大概多久出面试结果？</h3><h3 id="对我此次面试表现的评价？"><a href="#对我此次面试表现的评价？" class="headerlink" title="对我此次面试表现的评价？"></a>对我此次面试表现的评价？</h3><h3 id="跟同批次同学相比优点和缺点？对于缺点有什么建议？"><a href="#跟同批次同学相比优点和缺点？对于缺点有什么建议？" class="headerlink" title="跟同批次同学相比优点和缺点？对于缺点有什么建议？"></a>跟同批次同学相比优点和缺点？对于缺点有什么建议？</h3><h3 id="主要技术栈是什么？新人是怎么进行培养的呢？"><a href="#主要技术栈是什么？新人是怎么进行培养的呢？" class="headerlink" title="主要技术栈是什么？新人是怎么进行培养的呢？"></a>主要技术栈是什么？新人是怎么进行培养的呢？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自我介绍-amp-项目介绍&quot;&gt;&lt;a href=&quot;#自我介绍-amp-项目介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍 &amp;amp; 项目介绍&quot;&gt;&lt;/a&gt;自我介绍 &amp;amp; 项目介绍&lt;/h2&gt;&lt;h2 id=&quot;从用户输入URL到看到页面，这个过</summary>
      
    
    
    
    <category term="FE-Interview" scheme="http://example.com/categories/FE-Interview/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue3-Vue2</title>
    <link href="http://example.com/2021/06/20/vue3-vue2/"/>
    <id>http://example.com/2021/06/20/vue3-vue2/</id>
    <published>2021-06-20T11:01:24.000Z</published>
    <updated>2021-09-17T07:16:57.030Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>vue3 相比 vue2 的十项优点</strong></p><p>本文章转载自华为云社区《<a href="https://www.oschina.net/action/GoToLink?url=https://bbs.huaweicloud.com/blogs/300280?utm_source=oschina&utm_medium=bbs-ex&utm_campaign=other&utm_content=content">【云驻共创】vue3 相比 vue2 的十项优点</a>》，作者：海拥</p><p>Vue3新版本的理念成型于 2018 年末，当时的 Vue 2 已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，Vue3在2020年正式推出，在源码和API都有较大变化，性能得到了显著的提升，比Vue2.x快1.2~2倍。</p><p><strong>其中，一些比较重要的优点有：</strong></p><p>diff算法的优化；hoistStatic 静态提升；cacheHandlers 事件侦听器缓存；ssr渲染；更好的Ts支持；Compostion API: 组合API/注入API；更先进的组件；自定义渲染API；按需编译，体积比vue2.x更小；支持多根节点组件等。下面我们就来具体说说vue3 的优点：</p><h2 id="优点1：diff算法的优化"><a href="#优点1：diff算法的优化" class="headerlink" title="优点1：diff算法的优化"></a><strong>优点1：diff算法的优化</strong></h2><p>vue2中的虚拟dom是全量的对比（每个节点不论写死的还是动态的都会一层一层比较，这就浪费了大部分事件在对比静态节点上）</p><p>vue3新增了静态标记（patchflag）与上次虚拟节点对比时，只对比带有patch flag的节点（动态数据所在的节点）；可通过flag信息得知当前节点要对比的具体内容。</p><p>例如：下面的模板包含一个div，div内包含三个段落，其中前两个段落是静态固定不变的，而第三个段落的内容绑定的msg属性，当msg改变的时候，Vue会生成新的虚拟DOM然后和旧的进行对比。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>云驻共创<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>如何评价 vue3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当视图更新时，只对动态节点部分进行diff运算，减少了资源的损耗。Patchflag是个枚举，取值为1代表这个元素的文本是动态绑定的，取值为2代表元素的class是动态绑定的。</p><h2 id="优点2：hoistStatic-静态提升"><a href="#优点2：hoistStatic-静态提升" class="headerlink" title="优点2：hoistStatic 静态提升"></a><strong>优点2：hoistStatic 静态提升</strong></h2><p>vue2无论元素是否参与更新，每次都会重新创建然后再渲染。</p><p>vue3对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可。<br>例如：下面我们利用Vue 3 Template Explorer,来直观的感受一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>共创1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>共创2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>静态提升之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        _openBlock(),</span><br><span class="line">        _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;共创1&#x27;</span>),</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;共创2&#x27;</span>),</span><br><span class="line">            _createVNode(</span><br><span class="line">                <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                _toDisplayString(_ctx.name),</span><br><span class="line">                <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">            ),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态提升之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;共创1&#x27;</span>,</span><br><span class="line">    -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/*#__PURE__*/</span> _createVNode(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;共创2&#x27;</span>,</span><br><span class="line">    -<span class="number">1</span> <span class="comment">/* HOISTED */</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        _openBlock(),</span><br><span class="line">        _createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _hoisted_1,</span><br><span class="line">            _hoisted_2,</span><br><span class="line">            _createVNode(</span><br><span class="line">                <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                _toDisplayString(_ctx.name),</span><br><span class="line">                <span class="number">1</span> <span class="comment">/* TEXT */</span></span><br><span class="line">            ),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码中我们可以看出，_hoisted_1 和_hoisted_2 两个方法被提升到了渲染函数 render 之外，也就是我们说的静态提升。通过静态提升可以避免每次渲染的时候都要重新创建这些对象，从而大大提高了渲染效率。</p><h2 id="优点3：cacheHandlers-事件侦听器缓存"><a href="#优点3：cacheHandlers-事件侦听器缓存" class="headerlink" title="优点3：cacheHandlers 事件侦听器缓存"></a><strong>优点3：cacheHandlers 事件侦听器缓存</strong></h2><p>vue2.x中，绑定事件每次触发都要重新生成全新的function去更新，cacheHandlers 是Vue3中提供的事件缓存对象，当 cacheHandlers 开启，会自动生成一个内联函数，同时生成一个静态节点。当事件再次触发时，只需从缓存中调用即可，无需再次更新。</p><p>默认情况下onClick会被视为动态绑定，所以每次都会追踪它的变化，但是同一个函数没必要追踪变化，直接缓存起来复用即可。</p><p>例如：下面我们同样是通过Vue 3 Template Explorer，来看一下事件监听器缓存的作用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;todo&quot;</span>&gt;</span>做点有趣的事<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该段 html 经过编译后变成我们下面的结构(未开启事件监听缓存)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_openBlock(),_createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>,&#123; <span class="attr">onClick</span>: _ctx.todo&#125;, <span class="string">&#x27;做点有趣的事&#x27;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>,</span><br><span class="line">                [<span class="string">&#x27;onClick&#x27;</span>]),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们开启事件监听器缓存后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_openBlock(),_createBlock(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span><br><span class="line">            _createVNode(<span class="string">&#x27;div&#x27;</span>,&#123;</span><br><span class="line">                    onClick:    <span class="comment">//开启监听后</span></span><br><span class="line">                        _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span>_ctx.todo(...args)),</span><br><span class="line">                &#125;,<span class="string">&#x27;做点有趣的事&#x27;</span>),</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对比开启事件监听缓存前后的代码，转换之后的代码, 大家可能还看不懂, 但是不要紧，我们只需要观察有没有静态标记即可，在Vue3的diff算法中, 只有有静态标记的才会进行比较, 才会进行追踪。</p><h2 id="优点4：ssr渲染"><a href="#优点4：ssr渲染" class="headerlink" title="优点4：ssr渲染"></a><strong>优点4：ssr渲染</strong></h2><p>Vue2 中也是有 SSR 渲染的，但是 Vue3 中的 SSR 渲染相对于 Vue2 来说，性能方面也有对应的提升。</p><p>当存在大量静态内容时，这些内容会被当作纯字符串推进一个 buffer 里面，即使存在动态的绑定，会通过模版插值潜入进去。这样会比通过虚拟 dmo 来渲染的快上很多。</p><p>当静态内容大到一个量级的时候，会用_createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml，就不需要再创建对象，然后根据对象渲染。</p><h2 id="优点5：更好的Ts支持"><a href="#优点5：更好的Ts支持" class="headerlink" title="优点5：更好的Ts支持"></a><strong>优点5：更好的Ts支持</strong></h2><p>vue2不适合使用ts，原因在于vue2的Option API风格。options是个简单对象，而ts是一种类型系统、面向对象的语法。两者有点不匹配。</p><p>在vue2结合ts的具体实践中，要用 vue-class-component 强化 vue 组件，让 Script 支持 TypeScript 装饰器，用 vue-property-decorator 来增加更多结合 Vue 特性的装饰器，最终搞的ts的组件写法和js的组件写法差别挺大。</p><p>在vue3中，量身打造了defineComponent函数，使组件在ts下，更好的利用参数类型推断 。Composition API 代码风格中，比较有代表性的api就是 ref 和 reactive，也很好的支持了类型声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Component = defineComponent(&#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        success: &#123; <span class="attr">type</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">        student: &#123;</span><br><span class="line">          type: <span class="built_in">Object</span> <span class="keyword">as</span> PropType&lt;Student&gt;,</span><br><span class="line">          required: <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> year = ref(<span class="number">2020</span>)</span><br><span class="line">      <span class="keyword">const</span> month = ref&lt;string | number&gt;(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">      month.value = <span class="number">9</span> <span class="comment">// OK</span></span><br><span class="line">     <span class="keyword">const</span> result = year.value.split(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="优点6：Compostion-API-组合API-注入API"><a href="#优点6：Compostion-API-组合API-注入API" class="headerlink" title="优点6：Compostion API: 组合API/注入API"></a><strong>优点6：Compostion API: 组合API/注入API</strong></h2><p>传统的网页是html/css/javascript（结构/样式/逻辑）分离。vue通过组件化的方式，将联系紧密的结构/样式/逻辑放在一起，有利于代码的维护。compostion api更进一步，着力于JS（逻辑）部分，将逻辑相关的代码放在一起，这样更有利于代码的维护。</p><p>在vue2的组件内使用的是Option API风格(data/methods/mounted)来组织的代码，这样会让逻辑分散，举个例子就是我们完成一个计数器功能，要在data里声明变量，在methods定义响应函数，在mounted里初始化变量，如果在一个功能比较多、代码量比较大的组件里，你要维护这样一个功能，就需要在data/methods/mounted反复的切换到对应位置，然后进行代码的更改。</p><p>而在vue3中，使用setup函数。如下所示跟count相关的逻辑，都放到counter.js文件里，跟todo相关的逻辑放到todos.js里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useCounter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useTodo <span class="keyword">from</span> <span class="string">&#x27;./todos&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> &#123; val, todos, addTodo &#125; = useTodo()</span><br><span class="line"><span class="keyword">let</span> &#123;count,add&#125; = useCounter() </span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">val, todos, addTodo,</span><br><span class="line">count,add,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点7：更先进的组件"><a href="#优点7：更先进的组件" class="headerlink" title="优点7：更先进的组件"></a><strong>优点7：更先进的组件</strong></h2><p>vue2是不允许这样写的，组件必须有一个跟节点，现在可以这样写，vue将为我们创建一个虚拟的Fragment节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;华为云享专家&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;全栈领域博主&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>在Suspended-component完全渲染之前，备用内容会被显示出来。如果是异步组件，Suspense可以等待组件被下载，或者在设置函数中执行一些异步操作。</p><h2 id="优点8：自定义渲染API"><a href="#优点8：自定义渲染API" class="headerlink" title="优点8：自定义渲染API"></a><strong>优点8：自定义渲染API</strong></h2><p>vue2.x项目架构对于weex（移动端跨平台方案）和myvue（小程序上使用）等渲染到不同平台不太友好，vue3.0推出了自定义渲染API解决了该问题。下面我们先看vue2和vue3的入口写法有哪些不同。</p><p>vue2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; =&gt; h(App)&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./src/App&quot;</span></span><br><span class="line">createApp(App).mount((<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>vue官方实现的 createApp 会给我们的 template 映射生成 html 代码，但是要是你不想渲染生成到 html ，而是要渲染生成到 canvas 之类的不是html的代码的时候，那就需要用到 Custom Renderer API 来定义自己的 render 渲染生成函数了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;./runtime-render&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./src/App&quot;</span>; <span class="comment">// 根组件</span></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用自定义渲染API，如weex和myvue这类方案的问题就得到了完美解决。只需重写createApp即可。</p><h2 id="优点9：按需编译，体积比vue2-x更小"><a href="#优点9：按需编译，体积比vue2-x更小" class="headerlink" title="优点9：按需编译，体积比vue2.x更小"></a><strong>优点9：按需编译，体积比vue2.x更小</strong></h2><p>框架的大小也会影响其性能。这是 Web 应用程序的唯一关注点，因为需要即时下载资源，在浏览器解析必要的 JavaScript 之前该应用程序是不可交互的。对于单页应用程序尤其如此。尽管 Vue 一直是相对轻量级的（Vue 2 的运行时大小压缩为 23 KB）。</p><p>在 Vue 3 中，通过将大多数全局 API 和内部帮助程序移至 ES 模块导出来，实现了这一目标。这使现代的打包工具可以静态分析模块依赖性并删除未使用的导出相关的代码。模板编译器还会生成友好的 Tree-shaking 代码，在模板中实际使用了该功能时才导入该功能的帮助程序。</p><p>框架的某些部分永远不会 Tree-shaking，因为它们对于任何类型的应用都是必不可少的。我们将这些必不可少的部分的度量标准称为基准尺寸。尽管增加了许多新功能，但 Vue 3 的基准大小压缩后约为 10 KB，还不到 Vue 2 的一半。</p><h2 id="优点10：支持多根节点组件"><a href="#优点10：支持多根节点组件" class="headerlink" title="优点10：支持多根节点组件"></a><strong>优点10：支持多根节点组件</strong></h2><p>Vue3 一个模板不再限制有多个根节点，(多个根节点上的 Attribute 继承) 需要显式定义 attribute 应该分布在哪里。否则控制台会给出警告提示。</p><p>在 Vue 3 中，组件现在正式支持多根节点组件，即片段！</p><p>在 2.x 中，不支持多根组件，当用户意外创建多根组件时会发出警告，因此，为了修复此错误，许多组件被包装在一个中。如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;header&gt;...&lt;&#x2F;header&gt;</span><br><span class="line">    &lt;main&gt;...&lt;&#x2F;main&gt;</span><br><span class="line">    &lt;footer&gt;...&lt;&#x2F;footer&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><p>在 3.x 中，组件现在可以有多个根节点！但是，这确实要求开发者明确定义属性应该分布在哪里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;...&lt;&#x2F;header&gt;</span><br><span class="line">  &lt;main v-bind&#x3D;&quot;$attrs&quot;&gt;...&lt;&#x2F;main&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h2 id="结尾想说的"><a href="#结尾想说的" class="headerlink" title="结尾想说的"></a><strong>结尾想说的</strong></h2><p>Vue是国内最火的前端框架之一。性能提升，运行速度是vue2的1.2-2倍。</p><ul><li>体积更小，按需编译体积vue2要更小。</li><li>类型推断，更好的支持ts这个也是趋势。</li><li>高级给予，暴露了更底层的API和提供更先进的内置组件。</li><li>组合API，能够更好的组织逻辑，封装逻辑，复用逻辑</li></ul><h2 id="对未来的展望："><a href="#对未来的展望：" class="headerlink" title="对未来的展望："></a><strong>对未来的展望：</strong></h2><p>技术总是越新越好，越来越多的企业都升级了vue3；</p><p>大型项目，由于对TS的友好越来越多的大型项目可以使用vue3；</p><p>作为程序员，我们就应该适应市场，提高自己的竞争力，为加薪提供空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; &lt;strong&gt;vue3 相比 vue2 的十项优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文章转载自华为云社区《&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https://bbs.huaweicloud.com/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>koa2-demo</title>
    <link href="http://example.com/2021/06/12/koa2-demo/"/>
    <id>http://example.com/2021/06/12/koa2-demo/</id>
    <published>2021-06-12T12:53:10.000Z</published>
    <updated>2021-09-17T07:37:20.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Koa2框架的简单项目搭建及实战开发"><a href="#基于Koa2框架的简单项目搭建及实战开发" class="headerlink" title="[基于Koa2框架的简单项目搭建及实战开发]"></a>[基于Koa2框架的简单项目搭建及实战开发]</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://koa.bootcss.com/">Koa</a>是基于 Node.js 平台的下一代 web 开发框架，由express原班人马打造，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p><p>此文是简单介绍使用kos2进行项目的基本搭建以及api的简单开发</p><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>1、Koa框架是基于node.js的，安装node是必须进行的第一步，这里就不在赘述了</p><p>2、安装koa（推荐使用淘宝镜像进行安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa --save</span><br></pre></td></tr></table></figure><p>3、全局安装Koa2的项目生成器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa-generator -g</span><br></pre></td></tr></table></figure><p>4、创建一个项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">koa2 myProject</span><br></pre></td></tr></table></figure><p>5、进入这个项目文件夹，下载依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myProject</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure><blockquote><p>koa2 myProject 是用来生成项目的几门架构的</p></blockquote><p><img src="/images/koa2-demo/image-20210628200133834.png" alt="image-20210628200133834"></p><p>6、接下来，我们就可以启动项目服务了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br><span class="line">or</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:3000/%E5%8D%B3%E5%8F%AF%E6%9F%A5%E7%9C%8B%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%9E%E5%86%B5">http://localhost:3000/即可查看项目的运行实况</a></p><p><img src="/images/koa2-demo/image-20210628200448515.png" alt="image-20210628200448515"></p><h2 id="安装sequelize"><a href="#安装sequelize" class="headerlink" title="安装sequelize"></a>安装sequelize</h2><p>（Sequelize是一个基于promise的nodejs ORM，目前支持Postgres、mysql、SQLite和Microsoft SQL Server。它具有强大的事务支持，关联关系，读取和复制等功能。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install sequelize --save</span><br></pre></td></tr></table></figure><h2 id="安装mysql、mysql2"><a href="#安装mysql、mysql2" class="headerlink" title="安装mysql、mysql2"></a>安装mysql、mysql2</h2><p>项目使用的是mysql的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install mysql mysql2 --save</span><br></pre></td></tr></table></figure><h2 id="配置Sequelize的数据库链接"><a href="#配置Sequelize的数据库链接" class="headerlink" title="配置Sequelize的数据库链接"></a>配置Sequelize的数据库链接</h2><p>在项目的根目录下创建一个config目录，config目录中创建db.js，该文件主要用来创建mysql的数据库链接的。<br><code>/config/db.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;koa_demo&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>, &#123;</span><br><span class="line">    host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port: <span class="number">3306</span>,</span><br><span class="line">    dialect: <span class="string">&#x27;mysql&#x27;</span>,</span><br><span class="line">    operatorsAliases: <span class="literal">false</span>,</span><br><span class="line">    dialectOptions: &#123;</span><br><span class="line">        <span class="comment">// 字符集</span></span><br><span class="line">        charset: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">        collate: <span class="string">&#x27;utf8_general_ci&#x27;</span>,</span><br><span class="line">        supportBigNumbers: <span class="literal">true</span>,</span><br><span class="line">        bigNumberStrings: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    poll: &#123;</span><br><span class="line">        max: <span class="number">5</span>,</span><br><span class="line">        min: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 信号量：对特定资源的允许同时访问的操作数量进行控制（并发数）</span></span><br><span class="line">        acquire: <span class="number">30000</span>,</span><br><span class="line">        <span class="comment">// 空闲数</span></span><br><span class="line">        idle: <span class="number">10000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 东八时区 （&#x27;:08:00&#x27;）</span></span><br><span class="line">    timezone: <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sequelize</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其中koa_demo为数据库名称，root为数据库用户名，123456为数据库密码，这是我自己本地的默认数据库信息</p></blockquote><h2 id="创建schema、modules、controllers"><a href="#创建schema、modules、controllers" class="headerlink" title="创建schema、modules、controllers"></a>创建schema、modules、controllers</h2><p>schema:数据表模型实例<br>modules：实体模型<br>controllers：控制器</p><p>3个目录下分别创建student.js</p><p><img src="/images/koa2-demo/image-20210628200827484.png" alt="image-20210628200827484"></p><h3 id="schema数据表模型"><a href="#schema数据表模型" class="headerlink" title="schema数据表模型"></a>schema数据表模型</h3><p>在schema目录下新建一个student.js文件，该文件的主要作用就是建立与数据表的对应关系，也可以理解为代码的建表。<br><code>schema/student.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const moment = require(&quot;moment&quot;);</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">sequelize, DataTypes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sequelize.define(<span class="string">&#x27;student&#x27;</span>, &#123;</span><br><span class="line">        id: &#123;</span><br><span class="line">            type: DataTypes.INTEGER,</span><br><span class="line">            primaryKey: <span class="literal">true</span>,</span><br><span class="line">            allowNull: <span class="literal">true</span>,</span><br><span class="line">            autoIncrement: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//学生姓名</span></span><br><span class="line">        name: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;name&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 婚否</span></span><br><span class="line">        married: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">true</span>,</span><br><span class="line">            field: <span class="string">&#x27;married&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//年龄</span></span><br><span class="line">        age: &#123;</span><br><span class="line">            type: DataTypes.INTEGER,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;age&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//性别</span></span><br><span class="line">        gender: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;gender&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//分数</span></span><br><span class="line">        grade: &#123;</span><br><span class="line">            type: DataTypes.STRING,</span><br><span class="line">            allowNull: <span class="literal">false</span>,</span><br><span class="line">            field: <span class="string">&#x27;grade&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 创建时间</span></span><br><span class="line">        createdAt: &#123;</span><br><span class="line">            type: DataTypes.DATE</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 更新时间</span></span><br><span class="line">        updatedAt: &#123;</span><br><span class="line">            type: DataTypes.DATE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果为true，则表示名称和model相同，即user</span></span><br><span class="line"><span class="comment">         * 如果为fasle，mysql创建的表名称会是复数，即users</span></span><br><span class="line"><span class="comment">         * 如果指定的表名称本身就是复数，则形式不变</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        freezeTableName: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模型应用、使用"><a href="#模型应用、使用" class="headerlink" title="模型应用、使用"></a>模型应用、使用</h3><p>在项目中modules目录下创建student.js文件，为学生信息表，该文件为文章的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入mysql的配置文件</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../config/db&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; QueryTypes, DataTypes &#125; = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入sequelize对象</span></span><br><span class="line"><span class="keyword">const</span> Sequelize = db.sequelize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入数据表模型</span></span><br><span class="line"><span class="comment">// const student = Sequelize.import(&#x27;../schema/student&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;../schema/student&#x27;</span>)(Sequelize, DataTypes);</span><br><span class="line">student.sync(&#123; <span class="attr">force</span>: <span class="literal">false</span> &#125;); <span class="comment">//自动创建表</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">studentModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   创建学生表模型</span></span><br><span class="line">    <span class="comment">//   @param data</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise&lt;*&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">createStudent</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> student.create(&#123;</span><br><span class="line">            name: data.name, <span class="comment">//姓名</span></span><br><span class="line">            age: data.age,  <span class="comment">//年龄</span></span><br><span class="line">            gender: data.gender,  <span class="comment">//性别</span></span><br><span class="line">            grade: data.grade, <span class="comment">//分数</span></span><br><span class="line">            married: data.married,  <span class="comment">//婚否</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   查询学生信息的详情</span></span><br><span class="line">    <span class="comment">//   @param id 学生信息ID</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise&lt;Model&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">getStudentDetail</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> student.findOne(&#123;</span><br><span class="line">            where: &#123;</span><br><span class="line">                id</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = studentModel;</span><br></pre></td></tr></table></figure><h3 id="controllers-控制器"><a href="#controllers-控制器" class="headerlink" title="controllers 控制器"></a>controllers 控制器</h3><p>控制器的主要作用为功能的处理，项目中controllers目录下创建student.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> StudentModel = <span class="built_in">require</span>(<span class="string">&quot;../modules/student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">studentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   创建学生信息</span></span><br><span class="line">    <span class="comment">//   @param ctx</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise.&lt;void&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">create</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//接收客服端</span></span><br><span class="line">        <span class="keyword">let</span> req = ctx.request.body;</span><br><span class="line">        <span class="keyword">if</span> (req.name &amp;&amp; req.age &amp;&amp; req.gender &amp;&amp; req.grade &amp;&amp; req.married) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建学生信息模型</span></span><br><span class="line">                <span class="keyword">const</span> ret = <span class="keyword">await</span> StudentModel.createStudent(req);</span><br><span class="line">                <span class="comment">//使用刚刚创建的学生信息ID查询学生信息详情，且返回学生信息详情信息</span></span><br><span class="line">                <span class="keyword">const</span> data = <span class="keyword">await</span> StudentModel.getStudentDetail(ret.id);</span><br><span class="line"></span><br><span class="line">                ctx.response.status = <span class="number">200</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">200</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;创建学生信息成功&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                ctx.response.status = <span class="number">412</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">412</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;创建学生信息失败&#x27;</span>,</span><br><span class="line">                    data: err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.response.status = <span class="number">416</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                code: <span class="number">200</span>,</span><br><span class="line">                msg: <span class="string">&#x27;参数不齐全&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   获取学生详情</span></span><br><span class="line">    <span class="comment">//   @param ctx</span></span><br><span class="line">    <span class="comment">//   @returns &#123;Promise.&lt;void&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">async</span> <span class="function"><span class="title">detail</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> id = ctx.params.id;</span><br><span class="line">        <span class="keyword">if</span> (id) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 查询学生信息详情模型</span></span><br><span class="line">                <span class="keyword">let</span> data = <span class="keyword">await</span> StudentModel.getStudentDetail(id);</span><br><span class="line">                ctx.response.status = <span class="number">200</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">200</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;查询成功&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                ctx.response.status = <span class="number">412</span>;</span><br><span class="line">                ctx.body = &#123;</span><br><span class="line">                    code: <span class="number">412</span>,</span><br><span class="line">                    msg: <span class="string">&#x27;查询失败&#x27;</span>,</span><br><span class="line">                    data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.response.status = <span class="number">416</span>;</span><br><span class="line">            ctx.body = &#123;</span><br><span class="line">                code: <span class="number">416</span>,</span><br><span class="line">                msg: <span class="string">&#x27;学生ID必须传&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = studentController;</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由，也可以简单理解为路径，主要是作为请求的url，请求的路径来处理一些请求，返回数据。一般情况下，基于node的项目，路由都是在一个叫做routes的目录下面。</p><p>routes目录下创建student.js，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)()</span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">const</span> StudentController = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/student&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由前置</span></span><br><span class="line">router.prefix(<span class="string">&#x27;/student&#x27;</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//创建学生</span></span><br><span class="line">router.post(<span class="string">&#x27;/student/create&#x27;</span>, StudentController.create);</span><br><span class="line"><span class="comment">//获取某个学生详情</span></span><br><span class="line">router.get(<span class="string">&#x27;/student/:id&#x27;</span>, StudentController.detail)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router</span><br></pre></td></tr></table></figure><p>然后在app.js添加如下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;./routes/student&#x27;</span>)</span><br><span class="line">app.use(student.routes(), student.allowedMethods())</span><br></pre></td></tr></table></figure><blockquote><p>注意koa框架的洋葱圈模型，不懂得可以去自行查询</p></blockquote><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><p>跨域是web开发中不可避免的一个必须要解决的问题了。跨域问题，主要是要解决服务器端的通信问题。在node的开发中，只需要实现一个CORS标准就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install koa-cors --save</span><br></pre></td></tr></table></figure><p>然后在根目录下的app.js加入koa-cors的引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const cors = require(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line">app.use(cors()) //使用cors</span><br></pre></td></tr></table></figure><blockquote><p>同理：注意koa框架的洋葱圈模型，不懂得可以去自行查询</p></blockquote><p>完整的app.js文件代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">require</span>(<span class="string">&#x27;koa-json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> onerror = <span class="built_in">require</span>(<span class="string">&#x27;koa-onerror&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyparser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="built_in">require</span>(<span class="string">&#x27;koa-logger&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> users = <span class="built_in">require</span>(<span class="string">&#x27;./routes/users&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa-cors&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">&#x27;./routes/student&#x27;</span>)</span><br><span class="line"><span class="comment">// error handler</span></span><br><span class="line">onerror(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">// middlewares</span></span><br><span class="line">app.use(bodyparser(&#123;</span><br><span class="line">    enableTypes: [<span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;form&#x27;</span>, <span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">&#125;))</span><br><span class="line">app.use(json())</span><br><span class="line">app.use(logger())</span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)(__dirname + <span class="string">&#x27;/public&#x27;</span>))</span><br><span class="line"></span><br><span class="line">app.use(views(__dirname + <span class="string">&#x27;/views&#x27;</span>, &#123;</span><br><span class="line">    extension: <span class="string">&#x27;pug&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="keyword">const</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span>() - start</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes</span></span><br><span class="line">app.use(index.routes(), index.allowedMethods())</span><br><span class="line">app.use(users.routes(), users.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">// error-handling</span></span><br><span class="line">app.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">err, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;server error&#x27;</span>, err, ctx)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(student.routes(), student.allowedMethods())</span><br><span class="line">app.use(cors());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="然后重启项目"><a href="#然后重启项目" class="headerlink" title="然后重启项目"></a>然后重启项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p><img src="/images/koa2-demo/image-20210628201511106.png" alt="image-20210628201511106"></p><p>如果启动过程中出现上图的结果，说明服务启动成功</p><h2 id="使用Postman软件进行接口的测试"><a href="#使用Postman软件进行接口的测试" class="headerlink" title="使用Postman软件进行接口的测试"></a>使用Postman软件进行接口的测试</h2><h4 id="创建一个student的测试接口为："><a href="#创建一个student的测试接口为：" class="headerlink" title="创建一个student的测试接口为："></a>创建一个student的测试接口为：</h4><p><a href="http://127.0.0.1:3000/student/student/create">http://127.0.0.1:3000/student/student/create</a></p><h4 id="查询一个student的测试接口为："><a href="#查询一个student的测试接口为：" class="headerlink" title="查询一个student的测试接口为："></a>查询一个student的测试接口为：</h4><p><a href="http://localhost:3000/student/student/1">http://localhost:3000/student/student/1</a></p><p>####请求条件选择为：</p><p>POST请求<br>Body ===&gt; x-www-form-rulencoded</p><h4 id="如下图所示"><a href="#如下图所示" class="headerlink" title="如下图所示"></a>如下图所示</h4><p><img src="/images/koa2-demo/image-20210628201654659.png" alt="image-20210628201654659"></p><p>点击《send》请求后，返回的信息如下：</p><p><img src="/images/koa2-demo/image-20210628201947721.png" alt="image-20210628201947721"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;创建学生信息成功&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;jungle&quot;</span>,</span><br><span class="line">        <span class="string">&quot;married&quot;</span>: <span class="string">&quot;未婚&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span>,</span><br><span class="line">        <span class="string">&quot;grade&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;createdAt&quot;</span>: <span class="string">&quot;2021-06-10T12:19:20.000Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;updatedAt&quot;</span>: <span class="string">&quot;2021-06-10T12:19:20.000Z&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口返回成功后，我们去数据库里看一下这个表</p><p><img src="/images/koa2-demo/image-20210628202210099.png" alt="image-20210628202210099"></p><p>可以看到，已经在下koa_demo这个数据库中创建了一张student新表，且内容也是我们刚才进行添加的信息</p><h2 id="over"><a href="#over" class="headerlink" title="over"></a>over</h2><p>关于koa2的项目搭建先简单介绍到这里吧，算是对简单所学知识的一个小总结。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于Koa2框架的简单项目搭建及实战开发&quot;&gt;&lt;a href=&quot;#基于Koa2框架的简单项目搭建及实战开发&quot; class=&quot;headerlink&quot; title=&quot;[基于Koa2框架的简单项目搭建及实战开发]&quot;&gt;&lt;/a&gt;[基于Koa2框架的简单项目搭建及实战开发]&lt;/</summary>
      
    
    
    
    <category term="Node" scheme="http://example.com/categories/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/categories/Node/Koa2/"/>
    
    
    <category term="Node" scheme="http://example.com/tags/Node/"/>
    
    <category term="Koa2" scheme="http://example.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>vue中使用vue-qr生成并下载二维码</title>
    <link href="http://example.com/2021/05/26/Vue-qr/"/>
    <id>http://example.com/2021/05/26/Vue-qr/</id>
    <published>2021-05-26T01:42:04.000Z</published>
    <updated>2021-09-17T07:36:28.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue中使用vue-qr生成并下载二维码"><a href="#vue中使用vue-qr生成并下载二维码" class="headerlink" title="vue中使用vue-qr生成并下载二维码"></a>vue中使用vue-qr生成并下载二维码</h1><p>最近在项目中遇到一个生成二维码的需求，并且二维码上要带上logo和背景。</p><p>另一种二维码生成<strong>qrcode</strong>只能单纯的生成二维码，不能带logo及其它一些自定义。</p><p>于是选择了<strong>vue-qr</strong>。它具有自定义二维码背景、logo、实点颜色等等特性，能够生成更炫酷的二维码。</p><h2 id="vue中使用vue-qr生成二维码"><a href="#vue中使用vue-qr生成二维码" class="headerlink" title="vue中使用vue-qr生成二维码"></a>vue中使用vue-qr生成二维码</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-qr --save</span><br></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;basic-setting&quot;</span>&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;qrcode&quot;</span>&gt;</span><br><span class="line">        &lt;vue-qr :correctLevel=<span class="string">&quot;3&quot;</span> :autoColor=<span class="string">&quot;false&quot;</span> colorDark=<span class="string">&quot;#313a90&quot;</span> :bgSrc=<span class="string">&quot;bgSrc&quot;</span> :logoSrc=<span class="string">&quot;logoSrc&quot;</span> :text=<span class="string">&quot;codeUrl&quot;</span> :size=<span class="string">&quot;95&quot;</span> :margin=<span class="string">&quot;0&quot;</span> :logoMargin=<span class="string">&quot;3&quot;</span>&gt;&lt;/vue-qr&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">&quot;downloadImg&quot;</span>&gt;下载该二维码&#123;&#123; imgurl &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> VueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;vue-qr&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      imgurl: <span class="string">&quot;https://www.baidu.com/&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueQr,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="参数及说明"><a href="#参数及说明" class="headerlink" title="参数及说明"></a>参数及说明</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>text</td><td>二维码内容</td><td>是</td></tr><tr><td>size</td><td>尺寸, 长宽一致, 包含外边距</td><td>是</td></tr><tr><td>margin</td><td>二维码图像的外边距, 默认 20px</td><td>否</td></tr><tr><td>dotScale</td><td>数据区域点缩小比例,默认为0.35</td><td>否</td></tr><tr><td>correctLevel</td><td>容错级别 0-3</td><td>否</td></tr><tr><td>whiteMargin</td><td>若设为 true, 背景图外将绘制白色边框（默认是true）</td><td>否</td></tr><tr><td>bindElement</td><td>指定是否需要自动将生成的二维码绑定到HTML上（默认是true）</td><td>否</td></tr><tr><td>callback</td><td>生成的二维码 Data URI 可以在回调中取得,第一个参数为二维码 data URL, 第二个参数为 props 传过来的 qid(因为二维码生成是异步的,所以加个 id 用于排序)</td><td>否</td></tr></tbody></table><blockquote><p>可以使用 <code>bindElement</code> 来指定要自动填入二维码图像的元素的 ID（不含前导「#」），支持 <code>&lt;div&gt;</code> 或是 <code>&lt;img&gt;</code>。</p></blockquote><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><table><thead><tr><th>参数</th><th>说明</th><th>是否必要</th></tr></thead><tbody><tr><td>colorDark</td><td>黑点的颜色</td><td>否</td></tr><tr><td>colorLight</td><td>空白区域的颜色</td><td>否</td></tr><tr><td>autoColor</td><td>若为 true, 背景图的主要颜色将作为实点的颜色, 即 colorDark,默认 true</td><td>否</td></tr></tbody></table><blockquote><p>若设置了 <code>autoColor</code>，则 <code>colorDark</code> 和 <code>colorLight</code> 都将被忽略。</p></blockquote><h3 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h3><table><thead><tr><th><strong>参数</strong></th><th>说明</th><th>是否必要</th></tr></thead><tbody><tr><td>bgSrc</td><td>欲嵌入的背景图地址</td><td>否</td></tr><tr><td>gifBgSrc</td><td>欲嵌入的背景图 gif 地址,设置后普通的背景图将失效。设置此选项会影响性能</td><td>否</td></tr><tr><td>backgroundColor</td><td>背景色</td><td>否</td></tr><tr><td>backgroundDimming</td><td>叠加在背景图上的颜色, 在解码有难度的时有一定帮助</td><td>否</td></tr></tbody></table><blockquote><p>若设定了 <code>gifBackground</code> ，则 <code>backgroundImage</code> 将会被忽略。</p></blockquote><h3 id="logo图像"><a href="#logo图像" class="headerlink" title="logo图像"></a>logo图像</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>logoSrc</td><td>嵌入至二维码中心的 LOGO 地址</td><td>否</td></tr><tr><td>logoScale</td><td>用于计算 LOGO 大小的值, 过大将导致解码失败, LOGO 尺寸计算公式 logoScale*(size-2*margin), 默认 0.2</td><td>否</td></tr><tr><td>logoMargin</td><td>标识周围的空白边框, 默认为0</td><td>否</td></tr><tr><td>logoBackgroundColor</td><td>背景色,需要设置 logo margin</td><td>否</td></tr><tr><td>logoCornerRadius</td><td>标识及其边框的圆角半径, 默认为0</td><td>否</td></tr></tbody></table><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><table><thead><tr><th><strong>参数</strong></th><th><strong>说明</strong></th><th>是否必要</th></tr></thead><tbody><tr><td>binarize</td><td>若为 true, 图像将被二值化处理, 未指定阈值则使用默认值，默认是false</td><td>否</td></tr><tr><td>binarizeThreshold</td><td>(0 &lt; threshold &lt; 255) 二值化处理的阈值</td><td>否</td></tr></tbody></table><h2 id="vue中下载生成的二维码"><a href="#vue中下载生成的二维码" class="headerlink" title="vue中下载生成的二维码"></a>vue中下载生成的二维码</h2><h3 id="添加下载事件"><a href="#添加下载事件" class="headerlink" title="添加下载事件"></a>添加下载事件</h3><p>生成二维码&amp;下载二维码完整版代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;basic-setting&quot;</span>&gt;</span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line">      &lt;div id=<span class="string">&quot;qrcode&quot;</span>&gt;</span><br><span class="line">        &lt;vue-qr :correctLevel=<span class="string">&quot;3&quot;</span> :autoColor=<span class="string">&quot;false&quot;</span> colorDark=<span class="string">&quot;#313a90&quot;</span> :bgSrc=<span class="string">&quot;bgSrc&quot;</span> :logoSrc=<span class="string">&quot;logoSrc&quot;</span> :text=<span class="string">&quot;codeUrl&quot;</span> :size=<span class="string">&quot;95&quot;</span> :margin=<span class="string">&quot;0&quot;</span> :logoMargin=<span class="string">&quot;3&quot;</span>&gt;&lt;/vue-qr&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">    &lt;el-button @click=<span class="string">&quot;downloadImg&quot;</span>&gt;下载该二维码&#123;&#123; imgurl &#125;&#125;&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> VueQr <span class="keyword">from</span> <span class="string">&quot;vue-qr&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;vue-qr&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义二维码扫描的地址</span></span><br><span class="line">      imgurl: <span class="string">&quot;https://www.baidu.com/&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    VueQr,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">downloadImg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> oQrcode = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#qrcode img&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> url = oQrcode.src;</span><br><span class="line">      <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> event = <span class="keyword">new</span> MouseEvent(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">      <span class="comment">// 自定义下载二维码图片的名字</span></span><br><span class="line">      a.download = <span class="string">&quot;download二维码&quot;</span>;</span><br><span class="line">      <span class="comment">//url地址</span></span><br><span class="line">      a.href = url;</span><br><span class="line">      <span class="comment">//进行下载</span></span><br><span class="line">      a.dispatchEvent(event);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="效果图如下"><a href="#效果图如下" class="headerlink" title="效果图如下"></a>效果图如下</h3><p><img src="/images/Vue-qr/directive.gif" alt="directive"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue中使用vue-qr生成并下载二维码&quot;&gt;&lt;a href=&quot;#vue中使用vue-qr生成并下载二维码&quot; class=&quot;headerlink&quot; title=&quot;vue中使用vue-qr生成并下载二维码&quot;&gt;&lt;/a&gt;vue中使用vue-qr生成并下载二维码&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="项目学习" scheme="http://example.com/categories/Vue/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue-qr" scheme="http://example.com/tags/Vue-qr/"/>
    
  </entry>
  
  <entry>
    <title>ElementUI中gutter和offset的区别</title>
    <link href="http://example.com/2021/05/22/ElementUI-gutter&amp;offset/"/>
    <id>http://example.com/2021/05/22/ElementUI-gutter&amp;offset/</id>
    <published>2021-05-22T12:12:02.000Z</published>
    <updated>2021-05-22T12:23:57.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="elementui中gutter和offset的区别"><a href="#elementui中gutter和offset的区别" class="headerlink" title="elementui中gutter和offset的区别"></a>elementui中gutter和offset的区别</h1><blockquote><p> gutter是指栅格间间隔，offset是指栅格左侧的间隔格数</p></blockquote><h2 id="分栏间隔"><a href="#分栏间隔" class="headerlink" title="分栏间隔"></a><strong>分栏间隔</strong></h2><p>el-row配置行，el-col配置列，像是一个个单行的表格</p><p>el-row上的属性gutter，默认值为0，可以设置大于0的任意数字</p><p>在PC端，设置的这个gutter值为该单元格左右的padding之和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-row :gutter=<span class="string">&quot;20&quot;</span>&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">  &lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">&lt;/el-row&gt;</span><br></pre></td></tr></table></figure><p>上图代表的是<code>&quot;padding-left: 10px; padding-right: 10px;&quot;</code></p><p><img src="/images/ElementUI-gutter&offset/20200810154559866.png" alt="在这里插入图片描述"></p><h2 id="分栏偏移"><a href="#分栏偏移" class="headerlink" title="分栏偏移"></a><strong>分栏偏移</strong></h2><p>el-col的offset属性，设置某个el-col元素左侧<strong>空多少份</strong>的位置，默认为0</p><p>如果其offset和span之和大于<strong>24</strong>，则该行剩余元素移到下一行，同时这个元素只显示一部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-col :span=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br><span class="line">&lt;el-col :span=<span class="string">&quot;6&quot;</span> :offset=<span class="string">&quot;6&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&lt;/el-col&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/ElementUI-gutter&offset/20200810154943500.png" alt="在这里插入图片描述"></p><p>即：中间会偏移原先6份大小的位置~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;elementui中gutter和offset的区别&quot;&gt;&lt;a href=&quot;#elementui中gutter和offset的区别&quot; class=&quot;headerlink&quot; title=&quot;elementui中gutter和offset的区别&quot;&gt;&lt;/a&gt;elementu</summary>
      
    
    
    
    <category term="Css" scheme="http://example.com/categories/Css/"/>
    
    
    <category term="ElementUI" scheme="http://example.com/tags/ElementUI/"/>
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>内卷之下|拒绝个人内卷化</title>
    <link href="http://example.com/2021/05/10/Perception-03/"/>
    <id>http://example.com/2021/05/10/Perception-03/</id>
    <published>2021-05-10T02:44:27.000Z</published>
    <updated>2021-05-10T10:43:34.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>总结：</strong>内卷不但不会创造价值，而且会危害每一个人。</p></blockquote><p>不知道从什么时候开始，“内卷”这个概念变得很火炎焱燚。</p><p>什么是内卷？什么是内卷化？内卷究竟卷的是什么？众说纷纭。</p><p><strong>随着网络的发酵，“内卷”的使用场景不断扩大，“万物皆可内卷”。</strong>人们对内卷这个概念原本的语义价值已经不太在意，更多只是用来描述当下的“难”，借以表达对各自行业和处境的不满。</p><p><strong>内卷，渐渐成为“标签化”的情绪攻讦。</strong></p><p>如此，就太可惜了。我们连最开始讨论“内卷”的意义都失去了。</p><p>我们需要的是，冷静地审视“内卷”：社会的内卷，个人的内卷；更需要的是，冷静地思考：内卷之下，如何寻求突破？</p><h2 id="但无论如何我们都要去清楚的了解，什么才是“内卷”！"><a href="#但无论如何我们都要去清楚的了解，什么才是“内卷”！" class="headerlink" title="但无论如何我们都要去清楚的了解，什么才是“内卷”！"></a>但无论如何我们都要去清楚的了解，什么才是“内卷”！</h2><h3 id="1-什么是内卷"><a href="#1-什么是内卷" class="headerlink" title="1. 什么是内卷"></a><strong>1. 什么是内卷</strong></h3><p>很久很久以前，地球上有一个小镇。小镇上有很多鞋店，这些鞋店每天上午10点开门，中午12点到下午2点午休，下午2点到晚上6点继续营业；每周一至周五营业5天，周末休息。</p><p>天最热的那几天，鞋店老板们会纷纷把店关掉，去南方的海边度假；冬天最冷的那几天，鞋店老板们也会纷纷把店关掉，去北方的山里滑雪。</p><p>多年以来，小镇上的常住人口没有什么变化，鞋的品质一直优秀，供货也稳定，所以，<strong>小镇上的鞋的供需关系一直处于一个近乎完美的平衡状态。</strong></p><p>后来有一天，一户人家出于不明原因从大城市搬来小镇上，并且也开了一家鞋店。小镇虽然小，但也算具有一定规模，鞋的供需平衡还不至于因为新增一家鞋店而被打破。</p><p>但是，那座大城市的人民以勤奋、能吃苦著称。果然，这户来自大城市的人家也具备这些特点。他们家的鞋店每天早晨7点就开门了，中午也不午休，晚上直到11点才关门；周末他们也正常营业，夏天和冬天他们也从不去度假。</p><p>渐渐地，他们的“勤奋”得到了回报，他们鞋店的生意明显好于小镇上的其他鞋店。以前小镇人民吃完晚饭后是无法买鞋的，但现在，他们几乎随时可以去大城市人的鞋店买鞋，也就没什么必要光顾其他鞋店了。</p><p>但小镇老板们也不服输，他们纷纷效仿大城市人民的作息时间，每周工作7天，每天工作16小时。他们的“勤奋”也得到了“回报”：他们的营业收入恢复到了以前的状态。</p><p>那么，此时的小镇生活发生了什么样的变化呢？由于小镇人口并没有增加，鞋的需求量保持恒定，跟以前一样，所以每家鞋店最终的营业收入没什么变化，并不会增长。但营业时间从原来的每周5天，每天6小时变成了每周7天，每天16小时。</p><p>也就是说，<strong>他们的工作时间变长了，但收入却没有增加。</strong></p><p>这就是传说中的内卷（involution）。同时，这也是传说中的囚徒困境。</p><h3 id="2-什么是囚徒困境"><a href="#2-什么是囚徒困境" class="headerlink" title="2. 什么是囚徒困境"></a><strong>2. 什么是囚徒困境</strong></h3><p>我们可以把鞋店简化为两家：大城市鞋店和小镇鞋店。他们工作模式也可简化为996和955。小镇上鞋的需求不变。根据以上条件可知：</p><ul><li><strong>如果两家鞋店都选择955</strong>，会平分市场需求，同时也保证了休息时间，这种情况下总体收益最高，假设两家的收益分别是5, 5。</li><li><strong>如果两家鞋店都采取996</strong>工作模式，最终仍然会平分市场，但由于休息时间减少，幸福感降低，收益不能再是5, 5而应该是3, 3。</li><li><strong>而如果一家店选择了996而另一家店选择了955</strong>，那么996鞋店最终可能会独占市场，而955鞋店会没生意，于是两家的收益可假设为8, 0。</li></ul><p>这场博弈中两位鞋店的<strong>赢利表</strong>如下：</p><p><img src="/images/Perception-03/640" alt="图片"></p><p>两位鞋店老板彼此不知道对方是怎么想的，但他们都是“聪明”人，很容易算出：如果对方996，那么我955的收益是0，我也996的收益是3，所以我应该996；如果对方955，那么我也955的收益是5，我996的收益8，所以我应该996。</p><p>最终，两家鞋店都选择了996，这场博弈达到<strong>纳什均衡</strong>，<strong>两位老板都成了996的“囚徒”。</strong></p><blockquote><p>纳什均衡是这样一种状态，在该状态下每个参与人所采取的策略都是对于其他参与人的策略的最优反应。</p><p>——摘自董志强 《身边的博弈》，机械工业出版社·华章经管</p></blockquote><h3 id="3-什么是勤劳和公平"><a href="#3-什么是勤劳和公平" class="headerlink" title="3. 什么是勤劳和公平"></a><strong>3. 什么是勤劳和公平</strong></h3><p>任何一个行业都不是孤立存在的。鞋店老板们工作时间变长了，娱乐时间就变少了，他们光顾餐馆、咖啡馆的次数就少了，于是小镇上的餐饮业变得冷清了。虽然鞋店的营业时间延长，他们的耗电量增加，但餐馆、咖啡馆却在一些生意冷清的时段进入了节电模式，所以发电厂的生意也没有变好。</p><p><strong>总体算下来，小镇的经济不但没有变好，反而变差了一些。</strong>所以，我们可以看到，<strong>内卷不但有危害，而且会危害到看似无辜的每一个人。</strong></p><p>疲惫的小镇鞋店老板们也很快意识到了这个问题，于是他们成立鞋业协会，联合小镇政府制定强制性的行业规则和劳动法：每日工作时间不得超过8小时、每周营业时间不得超过5天，法定节假日必须休息……鞋业协会有权要求不遵守规定的鞋店关门，对屡教不改者，鞋业协会将联合小镇政府将其驱逐出小镇……</p><p>行规一出，来自大城市的人家就立即抗议，他们觉得这是对勤劳致富者的不尊重，也是对消费者的不尊重，这是干涉他们的自由，这是对他们的不公平对待和地域歧视……</p><p>鞋业协会立即怼了回去：你们所谓的勤劳并没有真正致富，反而对社会造成了危害。鞋店又不是急救中心，消费者早一天买鞋还是晚一天买鞋往往并没有区别。你们只顾着自己的作息时间而不管他人，这不是自由，而是自私，这才是真正的不公平……劳动法面前人人平等，并没针对谁、歧视谁，对违法的人采取强制措施也是天经地义……</p><h3 id="4、大城市社会工作中"><a href="#4、大城市社会工作中" class="headerlink" title="4、大城市社会工作中"></a>4、大城市社会工作中</h3><p>如果你觉得内卷是老板们才要关心的问题，跟打工人无关，那么我们离开小镇，来看看大城市里发生的故事。</p><p>大城市里有一家皮鞋款式设计公司，原本每一位打工人都是9点上班5点下班。后来，一位从小镇来的打工人进入这家公司，他本没有从业经验，为了得到这份工作在简历上和面试时都说了谎。于是开始打工时，他非常吃力，每天5点下班时他都无法完成工作，只好继续加班到9点才离开。</p><p>有一天，老板买了一个跑步机放在自己办公室里。从那天起，老板都会在完成工作后跑步健身，要在8点左右才离开办公室。所以他发现，这位小镇青年每天在8点时还没下班。于是，在下一个月的公司例会上，他表扬了小镇青年的刻苦精神，并宣布要他发奖金。</p><p>此后，其他打工人也发生了变化。有些人想，反正我下班之后也没什么事情，不如等8点以后再走，让老板也看到我加班，也给我发奖金。于是，加班的人逐渐多了起来。</p><p>起初，他们获得奖金，但一段时间过后，<strong>随着加班的人变成了大多数</strong>，老板对这些“勤奋刻苦”的人见怪不怪了，<strong>奖金的事也不再提了</strong>……。反而是那些下班后有事要做不能加班的人经常被老板批评，甚至被扣工资。</p><p>于是，打工人的工作时间延长了，但收入并没有增加，内卷害了每一个人。</p><p>要打破囚徒困境，打工人可以像小镇鞋店老板那样，成立工会争取自己合法权利。但他们其实还有另一种办法，就是辞掉这份工作，去另一家不需要加班的公司。</p><p>而对于老板来说，如果选择满足工会要求，其实并没有什么损失，大家只是回到以前的状态而已，公司的业绩就算不增长，也不会下降。但如果他选择拒绝，那么那些本来能力优秀的打工人很可能选择离开，留下像小镇青年那样不得不加班的低效率打工人，这就是<strong>劣币驱逐良币</strong>，毫无疑问，良币被驱逐意味着企业将蒙受损失。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>因此，内卷不会创造价值，而且会危害每一个人。如果打工人不觉醒、不抗争，管理者不制定有效措施防止内卷，而任由内卷的发生，我们每一个人都将是受害者，每个人的幸福感都会降低。</p><h2 id="内卷之下｜如何解决个人的内卷化问题？"><a href="#内卷之下｜如何解决个人的内卷化问题？" class="headerlink" title="内卷之下｜如何解决个人的内卷化问题？"></a><strong>内卷之下｜如何解决个人的内卷化问题？</strong></h2><h3 id="1、解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。"><a href="#1、解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。" class="headerlink" title="1、解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。"></a>1、<strong>解决个人的内卷化问题，一定要从个人的思维方式和行为方式入手。</strong></h3><p>中国传统文化给了我们很多精神财富，同时也给了我们很多包袱：热衷道德宣判，没事喜欢评价别人，又特别害怕别人评价自己；随大流受魅惑，没有独立的眼光，独立的判断能力；功利意识爆棚，满口仁义道德，真到做事，功利为上；贪多求全责备，恨不得拿下所有证书；多元眼光为零，对社会的观察完全没有多元的眼光。</p><p>当下又被管理主义、教条主义、科学主义折腾得够呛。每天做无数的规定动作，在其中消耗生命。</p><p>这种情况下，我们需要一个坚定的心态来实现个人的反内卷。</p><ul><li><p><strong>第一，面对嘈嘈杂杂的意见，要有战略性躺平的意识。</strong></p></li><li><p><strong>第二，对于重重叠叠的要求，要明白它们的机制性来由。</strong></p></li><li><p><strong>第三，对于社会提倡的林林总总的能力，你要集中一切精力和资历，培养行业的核心能力。</strong></p></li></ul><h3 id="2、善于用智慧的方式实现个人成长。"><a href="#2、善于用智慧的方式实现个人成长。" class="headerlink" title="2、善于用智慧的方式实现个人成长。"></a>2、善于用智慧的方式实现个人成长。</h3><ul><li><strong>第一，培养独立人格。你要有独立的眼光，要把自己立起来，站稳脚跟。这是成长的起点。</strong></li></ul><p>如果你心里装的全是别人塞给你的各种各样的观点，身受各种各样的枷锁，你怎么可能观察这样的社会？你连你自己都认识不了，你怎么认识社会？你连你自己都立不起来，你怎么样去做事业？</p><ul><li><strong>第二，进行系统化修身。</strong></li></ul><p>你要明白自身这个相对独立的小系统的运作，掌握身心两个层面的结构调试能力，在自我调试中悟道。这是成长的基础。</p><ul><li><strong>第三，实现人生的开放式演化。</strong></li></ul><p>你要找到你自身这个小系统与社会大系统、天地超系统之间的关联点，锚定价值点。</p><h3 id="何谓成长之道？"><a href="#何谓成长之道？" class="headerlink" title="何谓成长之道？"></a>何谓成长之道？</h3><p>就是去做只有你才能做的事，或者你能比别人做得更好的事。只要你能为社会做出贡献，你就有权利得到回报。同时培养自己轨道放开的能力，就是在具体问题上，不要锁死在一个轨道上，或者锁死在某一个目标上，某一个情绪上。心灵是开放的，思维方式是开放的，即所谓成长之道！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;内卷不但不会创造价值，而且会危害每一个人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道从什么时候开始，“内卷”这个概念变得很火炎焱燚。&lt;/p&gt;
&lt;p&gt;什么是内卷？什么是内卷化？内卷究竟卷的是什么？众说纷</summary>
      
    
    
    
    <category term="随笔感悟" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94%E6%84%9F%E6%82%9F/"/>
    
    
    <category term="Perception" scheme="http://example.com/tags/Perception/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-Vuex</title>
    <link href="http://example.com/2021/05/07/VueBasis-Vuex/"/>
    <id>http://example.com/2021/05/07/VueBasis-Vuex/</id>
    <published>2021-05-07T11:13:15.000Z</published>
    <updated>2021-09-17T07:34:07.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><h4 id="1、什么是vuex？"><a href="#1、什么是vuex？" class="headerlink" title="1、什么是vuex？"></a>1、什么是vuex？</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态， 并以相应的规则保证状态以一种可预测的方式发生改变简单来说，就是用来集中管理数据；</p><h4 id="2、使用vuex的核心概念"><a href="#2、使用vuex的核心概念" class="headerlink" title="2、使用vuex的核心概念"></a>2、使用vuex的核心概念</h4><h5 id="1）store"><a href="#1）store" class="headerlink" title="1）store"></a>1）store</h5><p>vuex 中最关键的是store对象，这是vuex的核心。可以说，vuex这个插件其实就是一个store对象，每个vue应用仅且仅有一个store对象。</p><p>（1）创建store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;...&#125;);</span><br></pre></td></tr></table></figure><p>可见，store是Vuex.Store这个构造函数new出来的实例。在构造函数中可以传一个对象参数。这个参数中可以包含5个对象：</p><ul><li><p>state – 存放状态</p></li><li><p>getters – state的计算属性</p></li><li><p>mutations – 更改状态的逻辑，同步操作</p></li><li><p>actions – 提交mutation，异步操作</p></li><li><p>mudules – 将store模块化</p></li></ul><p>关于store，需要先记住两点：</p><ul><li><p>store 中存储的状态是响应式的，当组件从store中读取状态时，如果store中的状态发生了改变，那么相应的组件也会得到更新；</p></li><li><p>不能直接改变store中的状态。改变store中的状态的唯一途径是提交(commit)mutations。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><p>（2）完整的store的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line"><span class="comment">// 存放状态</span></span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line"><span class="comment">// state的计算属性</span></span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">    <span class="comment">// 更改state中状态的逻辑，同步操作</span></span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line"><span class="comment">// 提交mutation，异步操作</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 如果将store分成一个个的模块的话，则需要用到modules。</span></span><br><span class="line"><span class="comment">//然后在每一个module中写state, getters, mutations, actions等。</span></span><br><span class="line">modules: &#123;</span><br><span class="line">a: moduleA,</span><br><span class="line">b: moduleB,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）-state"><a href="#2）-state" class="headerlink" title="2） state"></a>2） state</h5><p>state上存放的，说的简单一些就是变量，也就是所谓的状态。没有使用 state 的时候，我们都是直接在data 中进行初始化的，但是有了 state 之后，我们就把 data 上的数据转移到 state 上去了。另外有些状态是组件私有的状态，称为组件的局部状态，我们不需要把这部分状态放在store中去。</p><p>（1）如何在组件中获取vuex状态</p><p>由于vuex的状态是响应式的，所以从store中读取状态的的方法是在组件的计算属性中返回某个状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;store&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">computed: &#123;</span><br><span class="line">count () &#123;</span><br><span class="line"><span class="comment">// 获取store中的状态</span></span><br><span class="line"><span class="keyword">return</span> store.state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，组件中的状态就与store中的状态关联起来了。每当store.state.count发生变化时，都会重新求取计算属性，从而更新DOM。<br>然而，每个组件中都需要反复倒入store。<strong>可以将store注入到vue实例对象中去</strong>，这样每一个子组件中都可以直接获取store中的状态，而不需要反复的倒入store了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="comment">// 把 store 对象注入到了</span></span><br><span class="line">store,</span><br><span class="line">components: &#123; Counter &#125;,</span><br><span class="line">template: <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;counter&gt;&lt;/counter&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样可以在子组件中使用<code>this.$store.state.count</code>访问到state里面的count这个状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">template: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">computed: &#123;</span><br><span class="line">count () &#123;</span><br><span class="line"><span class="comment">// 获取store中的状态</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2） mapState<br>当一个组件获取多种状态的时候，则在计算属性中要写多个函数。为了方便，可以使用mapState辅助函<br>数来帮我们生成计算属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">data ()&#123;</span><br><span class="line">localState: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">computed: mapState(&#123;</span><br><span class="line"><span class="comment">// 此处的state即为store里面的state</span></span><br><span class="line">count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"><span class="comment">// 当计算属性的名称与state的状态名称一样时，可以省写</span></span><br><span class="line"><span class="comment">// 映射 this.count1 为 store.state.count1</span></span><br><span class="line">count1,</span><br><span class="line"><span class="comment">//&#x27;count&#x27;等同于 ‘state =&gt; state.count’</span></span><br><span class="line">countAlias: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line">countPlus (state)&#123;</span><br><span class="line"><span class="comment">// 使用普通函数是为了保证this指向组件对象</span></span><br><span class="line"><span class="keyword">return</span> state.count + <span class="built_in">this</span>.localState;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面是通过mapState的对象来赋值的，还可以通过mapState的数组来赋值</span></span><br><span class="line">computed: mapState([<span class="string">&#x27;count&#x27;</span>]);</span><br><span class="line"><span class="comment">//这种方式很简洁，但是组件中的state的名称就跟store中映射过来的同名</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象扩展运算符<br>mapState 函数返回的是一个对象，为了将它里面的计算属性与组件本身的局部计算属性组合起来，需<br>要用到对象扩展运算符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">localState () &#123;</span><br><span class="line">...mapState (&#123;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，mapState中的计算属性就与localState计算属性混合一起了</p><h5 id="3）getters"><a href="#3）getters" class="headerlink" title="3）getters"></a>3）getters</h5><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表表进行过滤并计数。此时可以用到<br>getters，getters可以看作是store的计算属性，其参数为state。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state: &#123;</span><br><span class="line">todos: [</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;reading&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;playBastketball&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">getters: &#123;</span><br><span class="line">doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>获取getters里面的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// [&#123; id: 1, text: &#x27;reading&#x27;, done: true &#125;]</span></span><br><span class="line"><span class="comment">//在组件中，则要写在计算属性中，</span></span><br><span class="line">computed: &#123;</span><br><span class="line">doneTodos () &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4）mutations"><a href="#4）mutations" class="headerlink" title="4）mutations"></a>4）mutations</h5><p>mutations里面是如何更改state中状态的逻辑。更改Vuex中的state的唯一方法是，提交mutation，即<br>store.commit(‘increment’)。</p><blockquote><p>注意：mutation必须是同步函数，不能是异步的，这是为了调试的方便。</p></blockquote><h5 id="5）actions"><a href="#5）actions" class="headerlink" title="5）actions"></a>5）actions</h5><p>因为mutations中只能是同步操作，但是在实际的项目中，会有异步操作，那么actions就是为了异步操<br>作而设置的。这样，就变成了在action中去提交mutation，然后在组件的methods中去提交action。只<br>是提交actions的时候使用的是dispatch函数，而mutations则是用commit函数。</p><h4 id="3、Vuex在Vue-Cli中的实践使用"><a href="#3、Vuex在Vue-Cli中的实践使用" class="headerlink" title="3、Vuex在Vue-Cli中的实践使用"></a>3、Vuex在Vue-Cli中的实践使用</h4><p>项目搭建及添加vuex<br>当我们使用vue-cli搭建一个vue项目的时候，搭建完成后的文件目录是这样子的</p><p><img src="/images/VueBasis-Vuex/image-20210507161550120.png" alt="image-20210507161550120"></p><p>首先使用 <code>npm install --save-dev vuex </code>把vuex添加到依赖，接下来就是如何在组件中使用vuex，大<br>体上来说有以下两种形式。</p><h5 id="1、通过-store-选项"><a href="#1、通过-store-选项" class="headerlink" title="1、通过 store 选项"></a>1、通过 store 选项</h5><p>如果vue-cli搭建成功，在src目录下会有一个main.js文件，main.js的主要作用是把项目中最顶层的<br>app.vue组件挂载到DOM中，其他所有的组件都可以看做是app.vue的子组件。<br>在main.js中，做如下操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意下面的代码</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state： &#123;&#125;，</span><br><span class="line">getters: &#123;&#125;,</span><br><span class="line">actions: &#123;&#125;,</span><br><span class="line">mutations: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注意router选项，此处的写法等同于store: store</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">    template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在组件中，就可以通过 this.$store 来使用store实例；<br>如果在项目中需要配置的vuex选项很多，我们则应该把vuex的相关代码分割到不同模块<br>在src下新建store文件夹，在文件夹中创建如下几个文件</p><p><img src="/images/VueBasis-Vuex/image-20210507161924220.png" alt="image-20210507161924220"></p><p>我们可以随意设置文件名，但最好可以通过文件名就能判断出这个文件是用来干嘛的<br><code>index.js</code>：整合各个模块，创建并导出vuex实例<br><code>rootState.js</code>：配置vuex实例的state选项<br><code>getters.js</code>：getter选项<br><code>mutations.js</code>：mutations选项<br><code>actions.js</code>：actions选项</p><p>在index.js中，我们需要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./rootState.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">&#x27;./mutations.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">&#x27;./actions.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state,</span><br><span class="line">getters,</span><br><span class="line">actions,</span><br><span class="line">mutations</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的四个文件配置都差不多一样，以<code>rootState.js</code>为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">count: <span class="number">0</span>,</span><br><span class="line">arr: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> state;</span><br></pre></td></tr></table></figure><p>如此这般，在main.js中，我们需要编写的代码就减少了很多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>将vuex实例挂载到vue原型链上</strong></p><p>这是一种非主流的方式，主要是受axios启发，在这种方法中，我们需要这样修改main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The Vue build version to load with the `import` command</span></span><br><span class="line"><span class="comment">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在vue中使用vuex必须先调用vue.use方法</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="comment">//具体挂载到vue原型的哪个属性上，可以由我们自行决定</span></span><br><span class="line"><span class="comment">//遇到配置繁多的情况也可以进行分割</span></span><br><span class="line">Vue.prototype.$store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">state： &#123;&#125;，</span><br><span class="line">getters: &#123;&#125;,</span><br><span class="line">actions: &#123;&#125;,</span><br><span class="line">mutations: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有了store选项</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">router,</span><br><span class="line">components: &#123; App &#125;,</span><br><span class="line">template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如此这般，还是可以通过 <code>this.$store</code> 来使用vuex。</p><h4 id="4、实践操作，修改state的值"><a href="#4、实践操作，修改state的值" class="headerlink" title="4、实践操作，修改state的值"></a>4、实践操作，修改state的值</h4><p>1）安装 vuex</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex -S</span><br></pre></td></tr></table></figure><p>2）在目录下创建store文件,并进行如下编辑</p><p><img src="/images/VueBasis-Vuex/image-20210507162519056.png" alt="image-20210507162519056"></p><p>3）然后再main.js中全局引入</p><p><img src="/images/VueBasis-Vuex/image-20210507162618400.png" alt="image-20210507162618400"></p><p>4）最后在组件中使用</p><p><img src="/images/VueBasis-Vuex/image-20210507162745928.png" alt="image-20210507162745928"></p><p>这个的功能是运用mutations 修改state中的值，演示效果如下：</p><p><img src="/images/VueBasis-Vuex/directive.gif" alt="directive"></p><h4 id="5、vuex-actions异步修改状态"><a href="#5、vuex-actions异步修改状态" class="headerlink" title="5、vuex actions异步修改状态"></a>5、vuex actions异步修改状态</h4><p>1）在store.js中声明actions</p><p>actions是可以调用Mutations里的方法的，我们还是继续在上节课的代码基础上进行学习，在actions里<br>调用add和reduce两个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions =&#123;</span><br><span class="line"><span class="function"><span class="title">addAction</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">context.commit(<span class="string">&#x27;add&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">reduceAction</span>(<span class="params">&#123;commit&#125;</span>)</span>&#123;</span><br><span class="line">commit(<span class="string">&#x27;reduce&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations<br>里边的方法。细心的小伙伴会发现这两个方法传递的参数也不一样。</p><ul><li><p>context：上下文对象，这里你可以理解称store本身。</p></li><li><p>{commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。</p></li></ul><p>2）模板中的使用</p><p>我们需要在count.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的<br>actions里的方法名，分别是：addAction和reduceAction。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addAction&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;reduceAction&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">...mapMutations([</span><br><span class="line"><span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;reduce&#x27;</span></span><br><span class="line">]),</span><br><span class="line">...mapActions([<span class="string">&#x27;addAction&#x27;</span>,<span class="string">&#x27;reduceAction&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>得用import把我们的mapActions引入才可以使用。</p></blockquote><p>3）增加异步检验</p><p>我们现在看的效果和我们用Mutations作的一模一样，肯定有的小伙伴会好奇，那actions有什么用，我<br>们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用<br>setTimeOut进行延迟执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeOut(<span class="function">()=&gt;</span>&#123;context.commit(reduce)&#125;,<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我比reduce提前执行&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vuex&quot;&gt;&lt;a href=&quot;#vuex&quot; class=&quot;headerlink&quot; title=&quot;vuex&quot;&gt;&lt;/a&gt;vuex&lt;/h3&gt;&lt;h4 id=&quot;1、什么是vuex？&quot;&gt;&lt;a href=&quot;#1、什么是vuex？&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="基础" scheme="http://example.com/categories/Vue/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vuex" scheme="http://example.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-VueRouter</title>
    <link href="http://example.com/2021/05/05/VueBasis-VueRouter/"/>
    <id>http://example.com/2021/05/05/VueBasis-VueRouter/</id>
    <published>2021-05-05T06:32:25.000Z</published>
    <updated>2021-09-17T07:34:22.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h4 id="1、vue-router如何响应-路由参数-的变化？"><a href="#1、vue-router如何响应-路由参数-的变化？" class="headerlink" title="1、vue-router如何响应 路由参数 的变化？"></a>1、vue-router如何响应 路由参数 的变化？</h4><p>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这<strong>也意味着组件的生命周期钩子不会再被调用。</strong></p><p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地<strong>watch (监测变化) $route 对象</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">watch: &#123;</span><br><span class="line"><span class="string">&#x27;$route&#x27;</span> (to, <span class="keyword">from</span>) &#123;</span><br><span class="line"><span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// react to route changes...</span></span><br><span class="line"><span class="comment">// don&#x27;t forget to call next()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意是：</span><br><span class="line">（<span class="number">1</span>）从同一个组件跳转到同一个组件。</span><br><span class="line">（<span class="number">2</span>）生命周期钩子created和mounted都不会调用。</span><br></pre></td></tr></table></figure><h4 id="2、完整的-vue-router-导航解析流"><a href="#2、完整的-vue-router-导航解析流" class="headerlink" title="2、完整的 vue-router 导航解析流"></a>2、完整的 vue-router 导航解析流</h4><p>1）导航被触发。</p><p>2）在失活的组件里调用离开守卫。</p><p>3）调用全局的 beforeEach 守卫。</p><p>4）在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p><p>5）在路由配置里调用 beforeEnter 。</p><p>6）解析异步路由组件。</p><p>7）在被激活的组件里调用 beforeRouteEnter 。</p><p>8）调用全局的 beforeResolve 守卫 (2.5+)。</p><p>9）导航被确认。</p><p>10）调用全局的 afterEach 钩子。</p><p>11）触发 DOM 更新。</p><p>12）用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p><p><img src="/images/VueBasis-VueRouter/image-20210429173157369.png" alt="image-20210429173157369"></p><h4 id="3、vue-router有哪几种导航钩子（-导航守卫-）？"><a href="#3、vue-router有哪几种导航钩子（-导航守卫-）？" class="headerlink" title="3、vue-router有哪几种导航钩子（ 导航守卫 ）？"></a>3、vue-router有哪几种导航钩子（ 导航守卫 ）？</h4><p>vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。</p><p>例如判断登录信息：没登录全部跳到登录页。判断必要操作是否进行没进行的话中断跳转。<br><strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察 <code>$route</code> 对象响应路由参数的变<br>化)来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。</p><p><strong>分为三大类：全局守卫、路由守卫、组件守卫</strong></p><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><p>可以使用 router.beforeEach 注册一个全局前置守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫<br>resolve 完之前一直处于 等待中。<br>    &nbsp; 每个守卫方法接收三个参数：</p><ul><li><code>to: Route</code> : 即将要进入的目标 路由对象</li><li><code>from: Route</code> : 当前导航正要离开的路由</li><li><code>next: Function</code> : 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。</li><li><code>next()</code> : 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li><code>next(false</code>) : 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</li><li><code>next(&#39;/&#39;) </code><strong>或者</strong> <code>next(&#123; path: &#39;/&#39; &#125;)</code> : 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 <code>replace: true</code> 、 <code>name:&#39;home&#39; </code>之类的选项以及任何用在 <code>router-link </code>的 <code>to </code>prop或 <code>router.push</code> `中的选项。</li><li><code>next(error) :</code> (2.4.0+) 如果传入 <code>next </code>的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <code>router.onError() </code>注册过的回调。</li></ul><p><strong>确保要调用 <code>next </code>方法，否则钩子就不会被 resolved。</strong></p><h5 id="全局解析守卫"><a href="#全局解析守卫" class="headerlink" title="全局解析守卫"></a>全局解析守卫</h5><p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 router.beforeEach 类似，区<br>别是在导航被确认之前，<strong>同时在所有组件内守卫和异步路由组件被解析之后</strong>，解析守卫就被调用。</p><h5 id="全局后置钩子"><a href="#全局后置钩子" class="headerlink" title="全局后置钩子"></a>全局后置钩子</h5><p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 <code>next </code>函数也不会改变导航本<br>身：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h5><p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line">&#123;</span><br><span class="line">path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">component: Foo,</span><br><span class="line">beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这些守卫与全局前置守卫的方法参数是一样的。</p><h5 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h5><p>最后，可以在路由组件内直接定义以下路由导航守卫：</p><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">template: <span class="string">`...`</span>,</span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line"><span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line"><span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line"><span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line"><span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line"><span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line"><span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beforeRouteEnter </code>守卫 <strong>不能</strong> 访问 <code>this</code> ，因为守卫在导航确认前被调用,因此即将登场的新组件还没<br>被创建。<br>不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实<br>例作为回调方法的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next </code>传递回调的唯一守卫。对于 <code>beforeRouteUpdate </code>和<br><code>beforeRouteLeave</code> 来说， <code>this</code> 已经可用了，所以不支持传递回调，因为没有必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line"><span class="comment">// just use `this`</span></span><br><span class="line"><span class="built_in">this</span>.name = to.params.name</span><br><span class="line">next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span> , next) &#123;</span><br><span class="line"><span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to leave? you have unsaved</span></span><br><span class="line"><span class="string">changes!&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (answer) &#123;</span><br><span class="line">next()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、vue-router传递参数的几种方式"><a href="#4、vue-router传递参数的几种方式" class="headerlink" title="4、vue-router传递参数的几种方式"></a>4、vue-router传递参数的几种方式</h4><h5 id="1）使用name传递"><a href="#1）使用name传递" class="headerlink" title="1）使用name传递"></a>1）使用name传递</h5><p>之前一直在配置路由的时候出现一个name,但不知道他具体有什么用，在路由里他可以用来传递参数。<br>在index.js中将路由的name都写好</p><p><img src="/images/VueBasis-VueRouter/image-20210429213649393.png" alt="image-20210429213649393"></p><p>接收参数：</p><p>在我们需要接收它的页面里添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是router-name:&#123;&#123;$route.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/images/VueBasis-VueRouter/image-20210429213719976.png" alt="image-20210429213719976"></p><p>比如我在这里是在APP.vue中接收的，我希望切换每个页面都能看见参数。<br>但这种方法不太常用，因为我们觉得它不太规整。</p><h5 id="2）to来传递"><a href="#2）to来传递" class="headerlink" title="2）to来传递"></a>2）to来传递</h5><p>利用router-link 中的to来传参，看语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link v-bind:to&#x3D;&quot;&#123;name:&#39;xxx&#39;,params:&#123;key:value&#125;&#125;&quot;&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li><p>a.首先：to需要绑定；</p></li><li><p>b.传参使用类似与对象的形式；</p></li><li><p>c.name就是我们在配置路由时候取的名字；</p></li><li><p>d.参数也是采用对象的形式。</p></li><li><p>实际操作一下：</p><p>=&gt; a.在APP.vue中将to里面的路径改成上面那样</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123;name:&#39;hellovue&#39;,params:&#123;username:&#39;tomcat&#39;&#125;&#125;&quot;&gt;hellovue页面</span><br><span class="line">&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><p>这里我们注意to的写法，前面加了冒号，因为那是绑定的，传递一个username过去，值为tomcat</p><p>​    =&gt; b.在index.js里面给hellovue配置名字叫hellovue,与上面name相对应</p><p><img src="/images/VueBasis-VueRouter/image-20210429214048560.png" alt="image-20210429214048560"></p><p>​    =&gt; c、在hellovue.vue中接收参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>传递的名字是：&#123;&#123;$route.params.username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3）采用url传参"><a href="#3）采用url传参" class="headerlink" title="3）采用url传参"></a>3）采用url传参</h5><p>在路由文件里采用冒号的形式传参，这就是对参数的绑定</p><ul><li><p>a、修改index.js里的path，这里我们修改myjob.vue组件</p><p><img src="/images/VueBasis-VueRouter/image-20210429214435188.png" alt="image-20210429214435188"></p></li><li><p>b、在App.vue组件里传递参数</p><p><img src="/images/VueBasis-VueRouter/image-20210429214445901.png" alt="image-20210429214445901"></p></li><li><p>c、在myjob.vue组件里显示我们要展示的内容（接收参数）</p></li></ul><p><img src="/images/VueBasis-VueRouter/image-20210429214453495.png" alt="image-20210429214453495"></p><h4 id="5、vue-router的动态路由匹配"><a href="#5、vue-router的动态路由匹配" class="headerlink" title="5、vue-router的动态路由匹配"></a>5、vue-router的动态路由匹配</h4><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对<br>于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中<br>使用“动态路径参数”(dynamic segment) 来达到这个效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;User&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line"><span class="comment">// 动态路径参数 以冒号开头</span></span><br><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在呢，像<code>/user/foo</code>和 <code>/user/bar</code> 都将映射到相同的路由。</p><p>一个“路径参数”使用冒号 <code>: </code>标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，<br>可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 ID：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>/user/:username</td><td>/user/evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>/user/:username/post/:post_id</td><td>/user/evan/post/123</td><td><code>&#123; username: &#39;evan&#39;, post_id:&#39;123&#39; &#125;</code></td></tr></tbody></table><p>除了 <code>$route.params</code> 外， <code>$route</code> 对象还提供了其它有用的信息，例如， <code>$route.query</code> (如果 URL<br>中有查询参数)、 <code>$route.hash</code> 等等。</p><h4 id="6、vue-router如何定义嵌套路由？"><a href="#6、vue-router如何定义嵌套路由？" class="headerlink" title="6、vue-router如何定义嵌套路由？"></a>6、vue-router如何定义嵌套路由？</h4><p>任何子路由都是在其父路由的组件中切换显示，不管是多少层的路由嵌套，都是这样的理解，所以父路由需要有以下两点，二者缺一不可</p><blockquote><p>有组件引用<br>组件中有router-view组件</p></blockquote><p>父路由没有引用组件，导致子路由没有承载容器，自然而然就出现了两层路由跳不起来等不起效的情况</p><h4 id="7、-lt-router-link-gt-lt-router-link-gt-组件及其属性"><a href="#7、-lt-router-link-gt-lt-router-link-gt-组件及其属性" class="headerlink" title="7、 &lt;router-link&gt; &lt;/router-link&gt; 组件及其属性"></a>7、 <code>&lt;router-link&gt; &lt;/router-link&gt;</code> 组件及其属性</h4><p>支持用户在具有路由功能的应用中 (点击) 导航 通过 to 属性指定目标地址<br>一：router-link组件的props：</p><ul><li><strong>to</strong></li></ul><p>表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&#39;&#x2F;Home&#39;&gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">渲染结果：</span><br><span class="line">&lt;a href&#x3D;&quot;Home&quot;&gt;Home&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;register&#39;, query: &#123; name: &#39;fjw&#39; &#125;&#125;&quot;&gt;router&lt;&#x2F;routerlink&gt;</span><br><span class="line">渲染结果：</span><br><span class="line">&lt;a href&#x3D;&quot;&#x2F;register?name&#x3D;fjw&quot;&gt;router&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>tag</strong></li></ul><p>指定<code>&lt;router-link&gt;</code>组件最终被渲染成什么标签；非必须；如果没有tag属性，<code>router-link</code>默认会被渲染成a标签。在下面的例子中，渲染成了li标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&#39;&#x2F;Home&#39; tag&#x3D;&quot;li&quot; &gt;Home&lt;&#x2F;router-link&gt;</span><br><span class="line">渲染结果：</span><br><span class="line">&lt;li&gt;Home&lt;&#x2F;li&gt;</span><br><span class="line">此时依旧会监听点击事件，触发导航</span><br></pre></td></tr></table></figure><ul><li><strong>replace</strong></li></ul><p>当点击时，会调用 <code>router.replace() </code>而不是 <code>router.push()</code>，于是导航后不会留下 history 记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;abc&#39;&#125;&quot; replace&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>append</strong></li></ul><p>则在当前 (相对) 路径前添加基路径。/a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;relative&#x2F;path&#39;&#125;&quot; append&gt;&lt;&#x2F;router-link&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>active-class</strong></li></ul><p>表示激活这个链接时，添加的class，默认是<code>router-link-class</code>。默认值可以通过路由的构造选项<br><code>linkActiveClass</code> 来全局配置。</p><ul><li><strong>exact</strong></li></ul><p>“是否激活” 默认类名的依据是 inclusive match (全包含匹配)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这个链接只会在地址为 &#x2F; 的时候被激活 --&gt;</span><br><span class="line">&lt;router-link to&#x3D;&quot;&#x2F;&quot; exact&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>event</strong></li></ul><p>默认值: ‘click’ 声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。</p><ul><li><strong>exact-active-class</strong></li></ul><p>默认值: “router-link-exact-active” 配置当链接被精确匹配的时候应该激活的 class。</p><h4 id="8、vue-router实现路由懒加载"><a href="#8、vue-router实现路由懒加载" class="headerlink" title="8、vue-router实现路由懒加载"></a>8、vue-router实现路由懒加载</h4><p>在项目router/index.js文件中将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../views/About.vue&#x27;</span></span><br></pre></td></tr></table></figure><p>更改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1：</span></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/About&#x27;</span>)</span><br><span class="line"><span class="comment">//方法2：</span></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;../views/About&#x27;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="built_in">module</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可实现路由懒加载的效果</p><h4 id="9、vue-router路由的两种模式"><a href="#9、vue-router路由的两种模式" class="headerlink" title="9、vue-router路由的两种模式"></a>9、vue-router路由的两种模式</h4><p>类型: <code>string</code></p><p>默认值: <code>&quot;hash&quot; (浏览器环境) | &quot;abstract&quot; (Node.js 环境)</code></p><p>可选值: <code>&quot;hash&quot; | &quot;history&quot; | &quot;abstract</code></p><p>配置路由模式:</p><ul><li><p><code>hash </code>: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</p></li><li><p><code>history </code>: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p></li><li><p><code>abstract </code>: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。<strong>如果发现没有浏览器的 API，路由会自动强制进入这个模式</strong></p></li></ul><h5 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a><strong>Hash模式</strong></h5><p>Hash 模式是 Vue-Router 的默认模式，具体的体现是在浏览器地址栏上 URL 路径永远带着一个「#」号。在浏览器支持度上面，Hash 模式是比较强势的，甚至能兼容低版本的 IE 浏览器。「#」号后面内容的改变，不会引起页面对服务端的请求，所以也就不会重新加载页面。在部署服务器方面，个人认为 Hash 模式比 History 模式来得更为方便，因为 History 有 URL 重定向问题，需要在服务端去配置 url 重定向，否则会报 404 错误。市面上也有不少大厂是使用 Hash 模式进行开发的，比如网易云音乐</p><h5 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a><strong>History 模式</strong></h5><p>HTML5 History API 提供了一个 <code>history.pushState</code> 和 <code>history.reolaceState</code> 方法（浏览器支持情况不是很乐观），它能让开发人员在不刷新网页的情况下改变站点的 URL。因为 Hash 模式会带上一个「#」号，会让 URL 地址变得比较难看，所以很多开发者都会选择 History 模式开发。但有个缺点，前端的 URL 必须和实际向服务端发起的请求的 URL 保持一致，如果服务端没有对相应的路由做处理，则会返回 404 错误页面。</p><blockquote><p>拓展：前进，后退，跳转操作方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.go(-<span class="number">3</span>);<span class="comment">//后退3次</span></span><br><span class="line">history.go(<span class="number">2</span>);<span class="comment">//前进2次</span></span><br><span class="line">history.go(<span class="number">0</span>);<span class="comment">//刷新当前页面</span></span><br><span class="line">history.back(); <span class="comment">//后退</span></span><br><span class="line">history.forward(); <span class="comment">//前进</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a><strong>abstract 模式</strong></h5><p>abstract 模式针对的是没有浏览器环境的情况，比如 Weex 客户端开发，内部是没有浏览器 API 的，那么 Vue-Router 自身会对环境做校验，强制切换到 abstract 模式，如果默认在 Vue-Router 的配置项中不写 mode 的值，在浏览器环境下会默认启用 Hash 模式，在移动客户端下使用 abstract 模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h3&gt;&lt;h4 id=&quot;1、vue-router如何响应-路由参数-的变化？&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="基础" scheme="http://example.com/categories/Vue/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue Router" scheme="http://example.com/tags/Vue-Router/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-Vue-cli工程</title>
    <link href="http://example.com/2021/05/03/VueBasis-VueCli/"/>
    <id>http://example.com/2021/05/03/VueBasis-VueCli/</id>
    <published>2021-05-03T04:22:45.000Z</published>
    <updated>2021-09-17T07:34:15.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue-cli工程"><a href="#vue-cli工程" class="headerlink" title="vue-cli工程"></a>vue-cli工程</h3><h4 id="1、构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？"><a href="#1、构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？" class="headerlink" title="1、构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？"></a>1、构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</h4><p>(1) <code>vue.js</code>：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。<br>(2) <code>vue-route</code>r：vue官方推荐使用的路由框架。<br>(3) <code>vuex</code>：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。<br>(4) <code>axios</code>（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。<br>(5) <code>vux</code>等：一个专为vue设计的移动端UI组件库。<br>(6) 创建一个emit.js文件，用于vue事件机制的管理。<br>(7) <code>webpack</code>：模块加载和vue-cli工程打包器。</p><h4 id="2、vue-cli-工程常用的-npm-命令有哪些？"><a href="#2、vue-cli-工程常用的-npm-命令有哪些？" class="headerlink" title="2、vue-cli 工程常用的 npm 命令有哪些？"></a>2、vue-cli 工程常用的 npm 命令有哪些？</h4><p>下载 node_modules 资源包的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>启动 vue-cli 开发环境的 npm命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>vue-cli 生成 生产环境部署资源 的 npm命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>用于查看 vue-cli 生产环境部署资源文件大小的 npm命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build --report</span><br></pre></td></tr></table></figure><h4 id="3、请说出vue-cli工程中每个文件夹和文件的用处"><a href="#3、请说出vue-cli工程中每个文件夹和文件的用处" class="headerlink" title="3、请说出vue-cli工程中每个文件夹和文件的用处"></a>3、请说出vue-cli工程中每个文件夹和文件的用处</h4><p>vue-cli目录解析：<br>(1) <code>build </code>文件夹：用于存放 webpack 相关配置和脚本。开发中仅 偶尔使用 到此文件夹下<br>webpack.base.conf.js 用于配置 less、sass等css预编译库，或者配置一下 UI 库。<br>(2) <code>config </code>文件夹：主要存放配置文件，用于区分开发环境、线上环境的不同。 常用到此文件夹下<br>config.js 配置开发环境的 端口号、是否开启热加载 或者 设置生产环境的静态资源相对路径、是否开启<br>gzip压缩、npm run build 命令打包生成静态资源的名称和路径等。<br>(3) <code>dist </code>文件夹：默认 npm run build 命令打包生成的静态资源文件，用于生产部署。<br>(4) <code>node_modules</code>：存放npm命令下载的开发环境和生产环境的依赖包。<br>(5) <code>src</code>: 存放项目源码及需要引用的资源文件。<br>(6) src下<code>assets</code>：存放项目中需要用到的资源文件，css、js、images等。<br>(7) src下<code>componets</code>：存放vue开发中一些公共组件：header.vue、footer.vue等。<br>(8) src下<code>emit</code>：自己配置的vue集中式事件管理机制。<br>(9) src下<code>router：vue</code>-router vue路由的配置文件。<br>(10) src下<code>service</code>：自己配置的vue请求后台接口方法。<br>(11) src下<code>page</code>：存在vue页面组件的文件夹。<br>(12) src下<code>util</code>：存放vue开发过程中一些公共的.js方法。<br>(13) src下<code>vuex</code>：存放 vuex 为vue专门开发的状态管理器。<br>(14) src下<code>app.vue</code>：使用标签 <code>&lt;route-view&gt;</code>  <code>&lt;/router-view&gt; </code>渲染整个工程的.vue组件。<br>(15) src下<code>main.js</code>：vue-cli工程的入口文件。<br>(16) <code>index.html</code>：设置项目的一些meta头信息和提供 <code>&lt;div id=&quot;app&quot;&gt;</code> <code>&lt;/div&gt;</code> 用于挂载 vue 节点。<br>(17) <code>package.json</code>：用于 node_modules资源部 和 启动、打包项目的 npm 命令管理。</p><h4 id="4、config文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置"><a href="#4、config文件夹-下-index-js-的对于工程-开发环境-和-生产环境-的配置" class="headerlink" title="4、config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置"></a>4、config文件夹 下 index.js 的对于工程 开发环境 和 生产环境 的配置</h4><p>(1) <code>index</code>：配置打包后入口.html文件的名称以及文件夹名称<br>(2) <code>assetsRoot</code>：配置打包后生成的文件名称和路径<br>(3) <code>assetsPublicPath</code>：配置 打包后 .html 引用静态资源的路径，一般要设置成 “./“<br>(4) <code>productionGzip</code>：是否开发 gzip 压缩，以提升加载速度</p><h5 id="dev-对象下对于开发环境的配置："><a href="#dev-对象下对于开发环境的配置：" class="headerlink" title="dev 对象下对于开发环境的配置："></a>dev 对象下对于开发环境的配置：</h5><p>(1) <code>port</code>：设置端口号<br>(2) <code>autoOpenBrowser</code>：启动工程时，自动打开浏览器<br>(3) <code>proxyTable</code>：vue设置的代理，用以解决 跨域 问题</p><h4 id="5、详细介绍一些-package-json-里面的配置"><a href="#5、详细介绍一些-package-json-里面的配置" class="headerlink" title="5、详细介绍一些 package.json 里面的配置"></a>5、详细介绍一些 package.json 里面的配置</h4><p>常用对象解析：<br>(1) <code>scripts</code>：npm run xxx 命令调用node执行的 .js 文件<br>(2) <code>dependencies</code>：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里面<br>(3) <code>devDependencies</code>：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不<br>会打包进 生产环境js文件 里面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue-cli工程&quot;&gt;&lt;a href=&quot;#vue-cli工程&quot; class=&quot;headerlink&quot; title=&quot;vue-cli工程&quot;&gt;&lt;/a&gt;vue-cli工程&lt;/h3&gt;&lt;h4 id=&quot;1、构建的-vue-cli-工程都到了哪些技术，它们的作用分别是什么？&quot;&gt;</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="基础" scheme="http://example.com/categories/Vue/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
    <category term="Vue Cli" scheme="http://example.com/tags/Vue-Cli/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础知识总结-核心知识点</title>
    <link href="http://example.com/2021/05/01/VueBasis-Core/"/>
    <id>http://example.com/2021/05/01/VueBasis-Core/</id>
    <published>2021-05-01T01:13:11.000Z</published>
    <updated>2021-09-17T07:34:28.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、对于Vue是一套渐进式框架的理解"><a href="#1、对于Vue是一套渐进式框架的理解" class="headerlink" title="1、对于Vue是一套渐进式框架的理解"></a>1、对于Vue是一套渐进式框架的理解</h4><p>渐进式代表的含义是：没有多做职责之外的事，vue.js只提供了vue-cli生态中最核心的组件系统和双向<br>数据绑定，就好像 vuex、vue-router都属于围绕vue.js开发的库。<br>示例：</p><h5 id="使用Angular，必须接受以下东西："><a href="#使用Angular，必须接受以下东西：" class="headerlink" title="使用Angular，必须接受以下东西："></a>使用Angular，必须接受以下东西：</h5><p>1）必须使用它的模块机制。<br>2）必须使用它的依赖注入。<br>3）必须使用它的特殊形式定义组件（这一点每个视图框架都有，这是难以避免的）<br>所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西<br>集成，这些主张会带来一些困扰。</p><h5 id="使用React，你必须理解："><a href="#使用React，你必须理解：" class="headerlink" title="使用React，你必须理解："></a>使用React，你必须理解：</h5><p>1）函数式编程的理念。<br>2）需要知道它的副作用。<br>3）什么是纯函数。<br>4）如何隔离、避免副作用。<br>5）它的侵入性看似没有Angular那么强，主要因为它是属于软性侵入的。</p><h5 id="Vue与React、Angular的不同是，但它是渐进的："><a href="#Vue与React、Angular的不同是，但它是渐进的：" class="headerlink" title="Vue与React、Angular的不同是，但它是渐进的："></a>Vue与React、Angular的不同是，但它是渐进的：</h5><p>1）可以在原有的大系统的上面，把一两个组件改用它实现，就是当成jQuery来使用。<br>2）可以整个用它全家桶开发，当Angular来使用。<br>3）可以用它的视图，搭配你自己设计的整个下层使用。<br>4）可以在底层数据逻辑的地方用OO和设计模式的那套理念。<br>5）可以函数式，它只是个轻量视图而已，只做了最核心的东西。</p><h4 id="2、vue-js的两个核心是什么？"><a href="#2、vue-js的两个核心是什么？" class="headerlink" title="2、vue.js的两个核心是什么？"></a>2、vue.js的两个核心是什么？</h4><p>数据驱动和组件系统：<br><strong>数据驱动</strong>：ViewModel，保证数据和视图的一致性。<br><strong>组件系统</strong>：应用类UI可以看作全部是由组件树构成的。</p><h4 id="3、-v-if-和-v-show-有什么区别"><a href="#3、-v-if-和-v-show-有什么区别" class="headerlink" title="3、 v-if 和 v-show 有什么区别"></a>3、 v-if 和 v-show 有什么区别</h4><p><strong>相同点</strong>：<br>两者都是在判断DOM节点是否要显示。<br><strong>不同点</strong>：<br>(1) 实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。 v-show只是在<br>修改元素的css样式，也就是display的属性值，元素始终在Dom树上。<br>(2) 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子<br>组件； v-show只是简单的基于css切换；<br>(3) 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局<br>部编译； v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被<br>保留；<br>(4) 性能消耗：v-if有更高的切换消耗，不适合做频繁的切换； v-show有更高的初始渲染消耗，适合做频<br>繁的额切换；</p><h4 id="4、vue常用的修饰符"><a href="#4、vue常用的修饰符" class="headerlink" title="4、vue常用的修饰符"></a>4、vue常用的修饰符</h4><h5 id="a、按键修饰符"><a href="#a、按键修饰符" class="headerlink" title="a、按键修饰符"></a>a、按键修饰符</h5><p>如：.delete（捕获“删除”和”退格“键） 用法上和事件修饰符一样，挂载在v-on:后面，<br>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">&#x27;aaa&#x27;</span> v-model=<span class="string">&quot;inputValue&quot;</span> @keyup.delete=<span class="string">&quot;onKey&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><h5 id="b、系统修饰符"><a href="#b、系统修饰符" class="headerlink" title="b、系统修饰符"></a>b、系统修饰符</h5><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器<br>(1) .ctrl<br>(2) .alt<br>(3) .shift<br>(4) .meta</p><h5 id="c、鼠标按钮修饰符"><a href="#c、鼠标按钮修饰符" class="headerlink" title="c、鼠标按钮修饰符"></a>c、鼠标按钮修饰符</h5><p>(1) .left<br>(2) .right<br>(3) .middle<br>这些修饰符会限制处理函数仅响应特定的鼠标按钮。<br>如： 鼠标滚轮单击触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.middle =<span class="string">&quot;onClick&quot;</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Click默认是鼠标左键单击</p></blockquote><h5 id="d、其他修饰符"><a href="#d、其他修饰符" class="headerlink" title="d、其他修饰符"></a>d、其他修饰符</h5><p>(1) .lazy<br>在默认情况下， v-model 在每次 input 事件触发后将输入框的值与数据进行同步 ，我们可以添<br>加 lazy 修饰符，从而转变为使用 change 事件进行同步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.lazy=<span class="string">&quot;msg&quot;</span> &gt;</span><br></pre></td></tr></table></figure><p>(2) .number<br>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 .number 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值<br>无法被 parseFloat() 解析，则会返回原始的值。<br>(3) .trim<br>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=<span class="string">&quot;msg&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>同样前面都有空格加上.trim后 将前后空格都去掉了。</p><h4 id="5、v-on可以监听多个方法"><a href="#5、v-on可以监听多个方法" class="headerlink" title="5、v-on可以监听多个方法"></a>5、v-on可以监听多个方法</h4><p>v-on可以监听多个方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-on在vue2.x中测试,以下两种均可--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123;mouseenter: onEnter,mouseleave: onLeave&#125;&quot;</span>&gt;</span>鼠标进来1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">mouseenter</span>=<span class="string">&quot;onEnter&quot;</span> @<span class="attr">mouseleave</span>=<span class="string">&quot;onLeave&quot;</span>&gt;</span>鼠标进来2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个事件绑定多个函数，按顺序执行，这里分隔函数可以用逗号也可以用分号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;a(),b()&quot;</span>&gt;</span>点我ab<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;one()&quot;</span>&gt;</span>点我onetwothree<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6、vue中-key-值的作用"><a href="#6、vue中-key-值的作用" class="headerlink" title="6、vue中 key 值的作用"></a>6、vue中 key 值的作用</h4><p>使用key来给每个节点做一个<strong>唯一标识</strong><br>key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使<br>用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效<br>果。</p><h4 id="7、vue-cli工程升级vue版本"><a href="#7、vue-cli工程升级vue版本" class="headerlink" title="7、vue-cli工程升级vue版本"></a>7、vue-cli工程升级vue版本</h4><p>npm install -g @vue/cli</p><h4 id="8、vue事件中如何使用event对象？"><a href="#8、vue事件中如何使用event对象？" class="headerlink" title="8、vue事件中如何使用event对象？"></a>8、vue事件中如何使用event对象？</h4><blockquote><p>注意在事件中要使用 $ 符号</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html部分</span></span><br><span class="line">&lt;a href=<span class="string">&quot;javascript:void(0);&quot;</span> data-id=<span class="string">&quot;12&quot;</span> @click=<span class="string">&quot;showEvent($event)&quot;</span>&gt;event&lt;/a&gt;</span><br><span class="line"><span class="comment">//js部分</span></span><br><span class="line"><span class="function"><span class="title">showEvent</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="comment">//获取自定义data-id</span></span><br><span class="line"><span class="built_in">console</span>.log(event.target.dataset.id)</span><br><span class="line"><span class="comment">//阻止事件冒泡</span></span><br><span class="line">event.stopPropagation();</span><br><span class="line"><span class="comment">//阻止默认</span></span><br><span class="line">event.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9、-nextTick的使用"><a href="#9、-nextTick的使用" class="headerlink" title="9、$nextTick的使用"></a>9、$nextTick的使用</h4><blockquote><p>参数： {Function} [callback]</p></blockquote><p><strong>用法</strong>：将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。<br>它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</p><p><strong>理解</strong>：<strong>nextTick()，是将回调函数延迟在下一次dom更新数据后调用</strong>，简单的理解是：<strong>当数据更新了，在dom中渲染后，自动执行该函数，</strong></p><p>实例：</p><p>未使用this.$nextTick()</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">&quot;msgp&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>$nextTick<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">name: <span class="string">&#x27;nextTick&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">msg: <span class="string">&#x27;未更新&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="javascript"><span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 修改数据</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.msg = <span class="string">&#x27;被更新了&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// DOM还没有更新</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.msgp.innerHTML)</span></span><br><span class="line"><span class="javascript"><span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// DOM更新了</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">&#x27;$nextTick:&#x27;</span> + <span class="built_in">this</span>.$refs.msgp.innerHTML)</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="javascript"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用this.$nextTick()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;    </span><br><span class="line">    testClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">        <span class="keyword">let</span> that=<span class="built_in">this</span>;      </span><br><span class="line">        that.testMsg=<span class="string">&quot;修改后的值&quot;</span>;      </span><br><span class="line">        that.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;        </span><br><span class="line">            <span class="built_in">console</span>.log(that.$refs.aa.innerText);  /</span><br><span class="line">            /输出：修改后的值      </span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。<code>$nextTick</code> 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code>，则可以在回调中获取更新后的 DOM。</p></blockquote><h5 id="nextTick-的应用场景"><a href="#nextTick-的应用场景" class="headerlink" title="$nextTick() 的应用场景:"></a>$nextTick() 的应用场景:</h5><p>在vue的生命周期 <strong>created() 钩子函数中进行 dom 操作</strong>，一定要放在 <code>$nextTick()</code> 函数中执行。在created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的代码放进 nextTick() 的回调函数中。</p><p><strong>mounted() 钩子函数</strong>，因为该钩子函数执行时，所有的 DOM 挂载和 渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题，</p><p>在<strong>数据变化后要执行某个操作</strong>，而这个操作需要随数据改变而改变DOM结构时，这个操作都是需要放置<code>$nextTick()</code> 的回调函数中。</p><h4 id="10、Vue-组件中-data-为什么必须是函数"><a href="#10、Vue-组件中-data-为什么必须是函数" class="headerlink" title="10、Vue 组件中 data 为什么必须是函数"></a>10、Vue 组件中 data 为什么必须是函数</h4><p>在 new Vue() 中， data 是可以作为一个对象进行操作的，然而在 component 中， data 只能以函数的形式存在，不能直接将对象赋值给它。</p><p>当data选项是一个函数的时候，每个实例可以维护一份被返回对象的独立的拷贝，这样各个实例中的<br>data不会相互影响，是独立的。</p><h4 id="11、v-for-与-v-if-的优先级"><a href="#11、v-for-与-v-if-的优先级" class="headerlink" title="11、v-for 与 v-if 的优先级"></a>11、v-for 与 v-if 的优先级</h4><p>当它们处于同一节点，v-for的优先级比v-if更高，这意味着 v-if将分别重复运行于每个 v-for循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;todo in todos&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>上面的代码只传递了未完成的 todos。</p><p>而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 <code>&lt;template&gt;</code> )上。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul v-<span class="keyword">if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span><br><span class="line">    &lt;li v-<span class="keyword">for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span><br><span class="line">        &#123;&#123; todo &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;p v-<span class="keyword">else</span>&gt;No todos left!&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="12、vue中子组件调用父组件的方法"><a href="#12、vue中子组件调用父组件的方法" class="headerlink" title="12、vue中子组件调用父组件的方法"></a>12、vue中子组件调用父组件的方法</h4><h5 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h5><p>直接在子组件中通过this.$parent.event来调用父组件的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;    </span><br><span class="line">&lt;div&gt;        </span><br><span class="line">    &lt;child&gt;&lt;/child&gt;    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        components: &#123;        </span><br><span class="line">            child            </span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;        </span><br><span class="line">            <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;测试&#x27;</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;&lt;/</span>template&gt;&lt;script&gt;<span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$parent.fatherMethod();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h5><p>在子组件里用 $emit 向父组件触发一个事件，父组件监听这个事件就行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;    </span><br><span class="line">&lt;div&gt;        </span><br><span class="line">    &lt;child @fatherMethod=<span class="string">&quot;fatherMethod&quot;</span>&gt;&lt;/child&gt;    </span><br><span class="line">    &lt;<span class="regexp">/div&gt;&lt;/</span>template&gt;&lt;script&gt;<span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        components: &#123;        </span><br><span class="line">            child            </span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;        </span><br><span class="line">            <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;测试&#x27;</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.$emit(<span class="string">&#x27;fatherMethod&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h5><p>父组件把方法传入子组件中，在子组件里直接调用这个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;template&gt;    </span><br><span class="line">&lt;div&gt;        </span><br><span class="line">    &lt;child :fatherMethod=<span class="string">&quot;fatherMethod&quot;</span>&gt;&lt;/child&gt;    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> child <span class="keyword">from</span> <span class="string">&#x27;~/components/dam/child&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        components: &#123;        </span><br><span class="line">            child            </span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;        </span><br><span class="line">            <span class="function"><span class="title">fatherMethod</span>(<span class="params"></span>)</span> &#123;           </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;测试&#x27;</span>);            </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;childMethod()&quot;</span>&gt;点击&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;&lt;/</span>template&gt;&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;    </span><br><span class="line">        props: &#123;</span><br><span class="line">            fatherMethod: &#123;</span><br><span class="line">                type: <span class="built_in">Function</span>,</span><br><span class="line">                <span class="keyword">default</span>: <span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,    </span><br><span class="line">        methods: &#123;</span><br><span class="line">            <span class="function"><span class="title">childMethod</span>(<span class="params"></span>)</span> &#123;            </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.fatherMethod)&#123;                </span><br><span class="line">                    <span class="built_in">this</span>.fatherMethod();            </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="13、vue中-keep-alive-组件的作用"><a href="#13、vue中-keep-alive-组件的作用" class="headerlink" title="13、vue中 keep-alive 组件的作用"></a>13、vue中 keep-alive 组件的作用</h4><p><strong>作用</strong>：用于保留组件状态或避免重新渲染（缓存的作用）<br><strong>例子</strong>：当一个目录页面与一个详情页面，用户<strong>经常</strong>：打开目录页面**=&gt;<strong>进入详情页面</strong>=&gt;<strong>返回目录页面</strong>=&gt;**打开详情页面，这样目录页面就是一个使用频率很高的页面，那么就可以对目录组件使用 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt; </code>进行缓存，这样用户每次返回目录时，都能从缓存中快速渲染，而不用重新渲染。</p><h4 id="14、vue中如何编写可复用的组件？"><a href="#14、vue中如何编写可复用的组件？" class="headerlink" title="14、vue中如何编写可复用的组件？"></a>14、vue中如何编写可复用的组件？</h4><p><strong>组件定义</strong>：是一个具有一定功能，且不同组件间功能相对独立的模块。高内聚、低耦合。</p><p>开发可复用性的组件应遵循以下<strong>原则</strong>：</p><p>1）规范化命名：组件的命名应该跟业务无关，而是依据组件的功能命名。<br>2）数据扁平化：定义组件接口时，尽量不要将整个对象作为一个 prop 传进来。每个 prop 应该是一个简单类型的数据。这样做有下列几点好处：<br>    (1) 组件接口清晰。<br>    (2) props 校验方便。<br>    (3) 当服务端返回的对象中的 key 名称与组件接口不一样时，不需要重新构造一个对象。扁平化的          props 能让我们更直观地理解组件的接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 反例 --&gt;</span><br><span class="line">&lt;card :item=<span class="string">&quot;&#123; title: item.name, description: item.desc, poster: item.img &#125;&gt;</span></span><br><span class="line"><span class="string">&lt;/card&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 正例 --&gt;</span><br><span class="line">&lt;card:title=<span class="string">&quot;item.name&quot;</span>:description=<span class="string">&quot;item.desc&quot;</span>:poster=<span class="string">&quot;item.img&quot;</span>&gt;</span><br><span class="line">&lt;/card&gt;</span><br></pre></td></tr></table></figure><p>3）可复用组件只实现 UI 相关的功能，即展示、交互、动画，如何获取数据跟它无关，因此不要在组件<br>内部去获取数据。<br>4）可复用组件应尽量减少对外部条件的依赖，所有与 vuex 相关的操作都不应在可复用组件中出现。<br>5）组件在功能独立的前提下应该尽量简单，越简单的组件可复用性越强。<br>6）组件应具有一定的容错性。<br>7）组件应当避免对其父组件的依赖，不要通过 this.parent 来操作父组件的示例。父组件也不要通过<br>this.children 来引用子组件的示例，而是通过子组件的接口与之交互。<br>8）可复用组件除了定义一个清晰的公开接口外，还需要有命名空间。命名空间可以避免与浏览器保留标签和其他组件的冲突。特别是当项目引用外部 UI 组件或组件迁移到其他项目时，命名空间可以避免很多命名冲突的问题。</p><h4 id="15、什么是vue生命周期？"><a href="#15、什么是vue生命周期？" class="headerlink" title="15、什么是vue生命周期？"></a>15、什么是vue生命周期？</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>vue生命周期是指vue实例对象从创建之初到销毁的过程，vue所有功能的实现都是围绕其生命周期进行<br>的，在生命周期的不同阶段调用对应的钩子函数实现组件数据管理和DOM渲染两大重要功能。</p><p><img src="/images/VueBasis-Core/11370083-f279314aef6741db.jpg" alt="img"></p><h5 id="八个阶段"><a href="#八个阶段" class="headerlink" title="八个阶段:"></a>八个阶段:</h5><blockquote><p>1）创建前(beforeCreate)<br>对应的钩子函数为beforeCreate。此阶段为实例初始化之后，此时的数据观察和事件机制都未形<br>成，不能获得DOM节点。</p><p>2）创建后（created）<br>对应的钩子函数为created。在这个阶段vue实例已经创建，仍然不能获取DOM元素。</p><p>3，载入前（beforeMount）<br>对应的钩子函数是beforeMount，在这一阶段，我们虽然依然得不到具体的DOM元素，但vue挂<br>载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行；beforeMount这个阶<br>段是过渡性的，一般一个项目只能用到一两次。</p><p>4，载入后（mounted）<br>对应的钩子函数是mounted。mounted是平时我们使用最多的函数了，一般我们的异步请求都写<br>在这里。在这个阶段，数据和DOM都已被渲染出来。</p><p>5，更新前（beforeUpdate）<br>对应的钩子函数是beforeUpdate。在这一阶段，vue遵循数据驱动DOM的原则。beforeUpdate<br>函数在数据更新后虽然没立即更新数据，但是DOM中的数据会改变，这是Vue双向数据绑定的作用。</p><p>6，更新后（updated）<br>对应的钩子函数是updated。在这一阶段DOM会和更改过的内容同步。</p><p>7，销毁前（beforeDestroy）<br>对应的钩子函数是beforeDestroy。在上一阶段Vue已经成功的通过数据驱动DOM更新，当我们不<br>再需要vue操纵DOM时，就要销毁Vue,也就是清除vue实例与DOM的关联，调用destroy方法可以<br>销毁当前组件。在销毁前，会触发beforeDestroy钩子函数。</p><p>8，销毁后(destroyed)对应的钩子函数是destroyed。<br>在销毁后，会触发destroyed钩子函数。<br>vue生命周期的思想贯穿在组件开发的始终,通过熟悉其生命周期调用不同的钩子函数，我们可<br>以准确的控制数据流和其对DOM的影响；vue生命周期的思想是Vnode和MVVM的生动体现和继承。</p></blockquote><h4 id="16、vue生命周期钩子函数有哪些？"><a href="#16、vue生命周期钩子函数有哪些？" class="headerlink" title="16、vue生命周期钩子函数有哪些？"></a>16、vue生命周期钩子函数有哪些？</h4><p> 1）vue生命周期是vue实例化或者组件创建到消亡的过程。<br> 2）beforeCreate 创建前的状态，初始化事件和生命周期。<br> 3）创建完毕状态Init (初始化) injections (依赖注入) &amp; reactivity (开始响应)。<br> 4）beforeMount 挂载前状态， 是否有元素el，是否有模板，是否渲染到了函数内，是否作为模板进行了outerHTML渲染到了页 面，向虚拟DOM上挂载的过程，并且还是把我们的‘#app’生成虚拟DOM，生成完毕后并渲染到view层。<br> 5）mounted 挂载结束状态，渲染到真正的DOM。<br> 6）beforeUpdate可以拿到Vue实例化改变前的状态。<br> 7）Updated拿到变动完成的状态。<br> 8）beforeDestroy消亡前的状态。<br> 9）destroyed实例化或组件被摧毁消亡。</p><h4 id="17、vue如何监听键盘事件中的按键？"><a href="#17、vue如何监听键盘事件中的按键？" class="headerlink" title="17、vue如何监听键盘事件中的按键？"></a>17、vue如何监听键盘事件中的按键？</h4><p>在Vue中，已经为常用的按键设置了别名，这样我们就无需再去匹配 keyCode ，<strong>直接使用别名</strong>就能监听按键的事件。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;function&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应表如下：</p><table><thead><tr><th>别名</th><th>实际键值</th></tr></thead><tbody><tr><td>.delete</td><td>delete（删除）/BackSpace（退格）</td></tr><tr><td>.tab</td><td>Tab</td></tr><tr><td>.enter</td><td>Enter（回车）</td></tr><tr><td>esc</td><td>Esc（退出）</td></tr><tr><td>.space</td><td>Space（空格键）</td></tr><tr><td>.left</td><td>Left（左箭头）</td></tr><tr><td>.up</td><td>Up（上箭头）</td></tr><tr><td>.right</td><td>Right（右箭头）</td></tr><tr><td>.down</td><td>Down（下箭头）</td></tr><tr><td>.ctrl</td><td>Ctrl</td></tr><tr><td>.alt</td><td>Alt</td></tr><tr><td>.shift</td><td>Shift</td></tr><tr><td>.meta</td><td>(window系统下是window键，mac下是command键)</td></tr></tbody></table><p>另外，Vue中还支持<strong>组合写法</strong>：</p><table><thead><tr><th>组合写法</th><th>按键组合</th></tr></thead><tbody><tr><td>@keyup.alt.67=”function”</td><td>Alt + C</td></tr><tr><td>@click.ctrl=”function”</td><td>Ctrl + Click</td></tr></tbody></table><p>但是，如果是在自己封装的组件或者是使用一些<strong>第三方的UI库</strong>时，会发现并不起效果，这时就需要用到 .native 修饰符了，如：(使用Element-UI)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">&quot;inputName&quot;</span><span class="attr">placeholder</span>=<span class="string">&quot;搜索你的文件&quot;</span>@<span class="attr">keyup.enter.native</span>=<span class="string">&quot;searchFile(params)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果遇到 .native 修饰符也无效的情况，可能就需要用到 $listeners 了.</p></blockquote><ul><li><h4 id="18、vue更新数组时触发视图更新的方法"><a href="#18、vue更新数组时触发视图更新的方法" class="headerlink" title="18、vue更新数组时触发视图更新的方法"></a>18、vue更新数组时触发视图更新的方法</h4><h5 id="1）Vue-set-响应式新增与修改数据"><a href="#1）Vue-set-响应式新增与修改数据" class="headerlink" title="1）Vue.set 响应式新增与修改数据"></a>1）<strong>Vue.set</strong> 响应式新增与修改数据</h5><p>可以设置对象或数组的值，通过key或数组索引，可以触发视图更新</p><p>​    Vue.set(target,key,value)</p><ul><li><p>参数：</p><ul><li><p>｛object | Array｝ target</p></li><li><p>{ string | number} key</p></li><li><p>｛any｝ value</p></li></ul></li><li><p>返回值：设置的值</p></li><li><p>用法：设置对象的属性，如果对象是响应式的，确保属性被创建后也是响应式的，同时出发视图更新。这个方法主要用于避开Vue不能检测属性被添加的限制。</p><blockquote><p>对象不能是Vue实例，或者Vue实例的根数据对象。</p></blockquote><p>target：要更改的<strong>数据源</strong>(可以是对象或者数组)<br> key：要更改的<strong>具体数据</strong><br> value ：<strong>重新赋的值</strong></p></li></ul><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组修改</span></span><br><span class="line">Vue.set(array, indexOfItem, newValue)<span class="built_in">this</span>.array.$set(indexOfItem, newValue)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象修改</span></span><br><span class="line">Vue.set(obj, keyOfItem, newValue)<span class="built_in">this</span>.obj.$set(keyOfItem, newValue)</span><br></pre></td></tr></table></figure><h5 id="2）Vue-delete（target，key）"><a href="#2）Vue-delete（target，key）" class="headerlink" title="2）Vue.delete（target，key）"></a>2）Vue.delete（target，key）</h5><ul><li><p>删除对象或数组中元素，通过key或数组索引，可以触发视图更新</p></li><li><p><strong>用法：</strong>删除对象的属性。如果对象是响应式的，确保删除能出发更新视图。这个方法主要用于避开Vue不能检测到属性被删除的限制。（至少会用）</p><blockquote><p>对象不能是Vue实例，或者Vue实例的根数据对象。</p></blockquote></li></ul><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组修改</span></span><br><span class="line">Vue.delete(array, indexOfItem)<span class="built_in">this</span>.array.$delete(indexOfItem)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象修改</span></span><br><span class="line">Vue.delete(obj, keyOfItem)<span class="built_in">this</span>.obj.$delete(keyOfItem)</span><br></pre></td></tr></table></figure><h5 id="3）数组对象直接修改属性，可以触发视图更新"><a href="#3）数组对象直接修改属性，可以触发视图更新" class="headerlink" title="3）数组对象直接修改属性，可以触发视图更新"></a>3）数组对象直接修改属性，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.array[<span class="number">0</span>].show = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    item.show = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="4）splice方法修改数组，可以触发视图更新"><a href="#4）splice方法修改数组，可以触发视图更新" class="headerlink" title="4）splice方法修改数组，可以触发视图更新"></a>4）splice方法修改数组，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.array.splice(indexOfItem, <span class="number">1</span>, newElement)</span><br></pre></td></tr></table></figure><h5 id="5）数组整体修改，可以触发视图更新"><a href="#5）数组整体修改，可以触发视图更新" class="headerlink" title="5）数组整体修改，可以触发视图更新"></a>5）数组整体修改，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tempArray = <span class="built_in">this</span>.array;</span><br><span class="line">tempArray[<span class="number">0</span>].show = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.array = tempArray;</span><br></pre></td></tr></table></figure><h5 id="6）用Object-assign或lodash-assign可以为对象添加响应式属性，可以触发视图更新"><a href="#6）用Object-assign或lodash-assign可以为对象添加响应式属性，可以触发视图更新" class="headerlink" title="6）用Object.assign或lodash.assign可以为对象添加响应式属性，可以触发视图更新"></a>6）用Object.assign或lodash.assign可以为对象添加响应式属性，可以触发视图更新</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object.assign的单层的覆盖前面的属性，不会递归的合并属性</span></span><br><span class="line"><span class="built_in">this</span>.obj = <span class="built_in">Object</span>.assign(&#123;&#125;,<span class="built_in">this</span>.obj,&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">//assign与Object.assign一样</span></span><br><span class="line"><span class="built_in">this</span>.obj = _.assign(&#123;&#125;,<span class="built_in">this</span>.obj,&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line"><span class="comment">//merge会递归的合并属性</span></span><br><span class="line"><span class="built_in">this</span>.obj = _.merge(&#123;&#125;,<span class="built_in">this</span>.obj,&#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure><h5 id="7）-Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新"><a href="#7）-Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新" class="headerlink" title="7） Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新"></a>7） Vue包含一组观察数组变异的方法，使用它们改变数组也会触发视图更新</h5><blockquote><ul><li>push() =&gt;向数组的末尾添加一个或多个元素，并返回新的长度。</li><li>pop() =&gt;删除最后一个元素，把数组长度减 1，并且返回它删除的元素的值。</li><li>shift() =&gt;把数组的第一个元素从其中删除，并返回第一个元素的值。</li><li>unshift() =&gt;向数组的开头添加一个或更多元素，并返回新的长度。</li><li>splice() =&gt;向/从数组中添加/删除项目，然后返回被删除的项目。 该方法会改变原始数组。</li><li>sort() =&gt;对数组的元素进行排序。</li><li>reverse() =&gt;颠倒数组中元素的顺序。</li></ul></blockquote><p>不变异的方法:</p><blockquote><ul><li>filter()</li><li>concat()</li><li>slice()<br>他们返回的是一个新数组，使用这些方法时，<strong>可以用新数组来替换原始数组</strong></li></ul></blockquote><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><ul><li><p>Vue 在检测到<strong>数组变化时</strong>，并不是直接重新渲染整个列表，而是<strong>最大化复用DOM元素</strong>。替换的数组中，含有<strong>相同元素的项不会被重新渲染</strong>，因此可以大胆的用新数组来替换旧数组，不用担心性能问题。</p></li><li><p>值得注意的是：<br>以下变动的数组中Vue是不能检测到的，也<strong>不会触发视图更新</strong>。<br> 1.通过索引直接设置项， 比如this.books[3]={…}<br> 2.修改数组长度， 比如 this.books.length = 1;</p><blockquote><p>两个问题都可以用splice来解决：<br>第一个问题 还可以用 set方法 this.$set(this.books,3,{…})</p></blockquote></li></ul><h4 id="19、vue中对象更改检测的注意事项"><a href="#19、vue中对象更改检测的注意事项" class="headerlink" title="19、vue中对象更改检测的注意事项"></a>19、vue中对象更改检测的注意事项</h4><p>还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">    &#125;&#125;)</span><br><span class="line"><span class="comment">// `qs.a` 现在是响应式的qs.b = 2</span></span><br><span class="line"><span class="comment">// `qs.b` 不是响应式的</span></span><br></pre></td></tr></table></figure><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object,<br>propertyName, value) 方法向嵌套对象添加响应式属性。例如，对于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        userProfile: &#123;</span><br><span class="line">            name: <span class="string">&#x27;Jungle&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以添加一个新的 age 属性到嵌套的 userProfile 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(qs.userProfile, <span class="string">&#x27;age&#x27;</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qs.$set(qs.userProfile, <span class="string">&#x27;age&#x27;</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure><p>有时你可能需要<strong>为已有对象赋值多个新属性</strong>，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新，在这种情况下，你应该用两个对象（原对象和要混合进去的对象）的属性创建一个新的对象。所以，如果你想添加新的响应式属性，这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">qs.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, qs.userProfile, &#123;</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    favoriteFood: <span class="string">&#x27;Vue huimian&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p><p><strong>Object.assign()</strong> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><p>const target = { a: 1, b: 2 };<br>const source = { b: 4, c: 5 };</p><p>const returnedTarget = Object.assign(target, source);</p><p>console.log(target);<br>// expected output: Object { a: 1, b: 4, c: 5 }</p><p>console.log(returnedTarget);<br>// expected output: Object { a: 1, b: 4, c: 5 }</p></blockquote><h4 id="20、解决非工程化项目初始化页面闪动问题"><a href="#20、解决非工程化项目初始化页面闪动问题" class="headerlink" title="20、解决非工程化项目初始化页面闪动问题"></a>20、解决非工程化项目初始化页面闪动问题</h4><p>vue页面在加载的时候闪烁花括号{}，v-cloak指令和css规则如[v-cloak]{display:none}一起用时，这个指令可以隐藏未编译的Mustache(前端模板引擎)标签直到实例准备完毕。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--html代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in tabs&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;data.text&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="21、v-for产生的列表，实现active的切换"><a href="#21、v-for产生的列表，实现active的切换" class="headerlink" title="21、v-for产生的列表，实现active的切换"></a>21、v-for产生的列表，实现active的切换</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(desc,tableIndex) in descriptions.firstface&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;controller-checkboxs clearfix&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;currentIndex=index,currentTable=tableIndex&quot;</span>    <span class="attr">class</span>=<span class="string">&quot;controller-checkbox-item&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:class</span>=<span class="string">&quot;&#123;active:index===currentIndex&amp;&amp;tableIndex==currentTable&#125;&quot;</span><span class="attr">v-for</span>=<span class="string">&quot;(ctrlValue,index) in desc.args&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="22、v-model语法糖的组件中的使用"><a href="#22、v-model语法糖的组件中的使用" class="headerlink" title="22、v-model语法糖的组件中的使用"></a>22、v-model语法糖的组件中的使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">此时msg值就与input的值进行双向绑定，实际上上面的代码是下面代码的语法糖。</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;msg= $event.target.value&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>要理解这行代码，首先你要知道 input 元素本身有个 oninput 事件，这是 HTML5 新增加的，类似<br>onchange ，每当输入框内容发生变化，就会触发 oninput ，把最新的value传递给 msg。从而实现了vmodel。</p><h4 id="23、Vue中自定义过滤器"><a href="#23、Vue中自定义过滤器" class="headerlink" title="23、Vue中自定义过滤器"></a>23、Vue中自定义过滤器</h4><p>过滤器是一个通过输入数据，能够及时对数据进行处理并返回一个数据结果的简单函数。Vue有很多很<br>便利的过滤器，过滤器通常会使用管道标志 “ | ”。使用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;item.ctime | dataFormat(&#x27;yyyy-mm-dd&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>自定义全局过滤器</strong><br>虽然VueJs给我们提供了很多强有力的过滤器，但有时候还是不够。值得庆幸的，Vue给我们提供了一个干净简洁的方式来定义我们自己的过滤器，之后我们就可以利用管道 “ | ” 来完成过滤。</p><p>定义一个全局的自定义过滤器，需要使用 Vue.filter() 构造器。这个构造器需要两个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局过滤器</span></span><br><span class="line">Vue.filter(<span class="string">&#x27;dataFormat&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">input, pattern = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(input);</span><br><span class="line"><span class="comment">// 获取年月日</span></span><br><span class="line"><span class="keyword">var</span> y = dt.getFullYear();</span><br><span class="line"><span class="keyword">var</span> m = (dt.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> d = dt.getDate().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="comment">// 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日</span></span><br><span class="line"><span class="comment">// 否则，就返回 年-月-日 时：分：秒</span></span><br><span class="line"><span class="keyword">if</span> (pattern.toLowerCase() === <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 获取时分秒</span></span><br><span class="line"><span class="keyword">var</span> hh = dt.getHours().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> mm = dt.getMinutes().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ss = dt.getSeconds().toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>拓展</p><p><strong><code>padStart()</code></strong> 方法用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>);          <span class="comment">//&quot;       abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&quot;foo&quot;</span>);  <span class="comment">// &quot;foofoofabc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">6</span>,<span class="string">&quot;123465&quot;</span>); <span class="comment">// &quot;123abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">8</span>, <span class="string">&quot;0&quot;</span>);     <span class="comment">// &quot;00000abc&quot;</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">1</span>);          <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p><strong>返回值：</strong>在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。</p></blockquote><h4 id="24、vue等单页面应用及其优缺点"><a href="#24、vue等单页面应用及其优缺点" class="headerlink" title="24、vue等单页面应用及其优缺点"></a>24、vue等单页面应用及其优缺点</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p> 1）用户体验好，快，内容的改变不需要重新加载整个页面，对服务器压力较小。<br> 2）前后端分离，比如vue项目<br> 3）完全的前端组件化，前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方<br>式更加规范化，便于修改 和调整；</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1）首次加载页面的时候需要加载大量的静态资源，这个加载时间相对比较长。<br> 2）不利于 SEO优化，单页页面，数据在前端渲染，就意味着没有 SEO。<br> 3）页面导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进<br>后退功能，所以需要自 己建立堆栈管理）</p><h4 id="25、什么是vue的计算属性？"><a href="#25、什么是vue的计算属性？" class="headerlink" title="25、什么是vue的计算属性？"></a>25、什么是vue的计算属性？</h4><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板<br>过重且难以维护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;翻转字符串</span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这里的表达式包含3个操作，并不是很清晰，所以遇到复杂逻辑时应该使用Vue特带的计算属性<br>computed 来进行处理。</p><h4 id="26、vue-cli提供的几种脚手架模板"><a href="#26、vue-cli提供的几种脚手架模板" class="headerlink" title="26、vue-cli提供的几种脚手架模板"></a>26、vue-cli提供的几种脚手架模板</h4><p>vue-cli 的脚手架项目模板有browserify 和 webpack , 官网给出了两个模板： webpack-simple 和<br>webpack 两种。两种的区别在于webpack-simple 没有包括Eslint 检查功能等等功能，普通项目基本用<br>webpack-simple 就足够了.<br><strong>搭建官方项目模板步骤：</strong></p><ul><li><p>1、npm install vue-cli (安装vue-cli ) 有的时候有看到其它两种写法: –save-dev 和 –save的写法。这两个有一定的区别，我们都知道package.json 中有一个 “dependencies” 和 “devDependencies” 的。<br>dependencies 是用在开发完上线模式的，就是有些东西你上线以后还需要依赖的，比如juqery , 我们这里的vue 和 babel-runtime（Babel 转码器 可以将ES6 转为ES5 ）， 而devDependencies 则是在开发模式执行的，比如我们如果需要安装一个node-sass 等等。</p><blockquote><ul><li>有的时候看到package.json中安装的模块版本号前面有一个波浪线。</li></ul><p>例如: ~1.2.3 这里表示安装1.2.x以上版本。但是不安装1.3以上。</p><ul><li>插入符号^ 更宽松。 它匹配的是最新次要版本号，也就是第二个数字。</li></ul><p>比如：^ 1.2.3将匹配任何1.x.x版本，包括1.3.0，但将在2.0.0上停止。</p></blockquote></li><li><p>2、vue init webpack-simple yourdemoname 下载一个webpack-simple项目，这里的webpacksimple 是固定的，也就是官网的项目模板。youdemoname 这个是你自己项目的名字。 执行这个步骤<br>以后。就会弹出询问 “项目名称..项目描述“等等问题 直接按照提示操作。这个时候对应的项目目录下就<br>出现刚刚建立的项目了。</p></li><li><p>3、我们还需要把项目的依赖下载下来。使用命令: cd youdemoname 然后执行npm install 就可以了，<br>这个时候你的项目中有多了一个node_modules 目录</p></li><li><p>4、使用”npm - run - dev” 命令来运行项目 “npm-run-bulid” 来执行发布，会自动生成dist文件</p></li></ul><h4 id="27、vue父组件如何向子组件中传递数据？"><a href="#27、vue父组件如何向子组件中传递数据？" class="headerlink" title="27、vue父组件如何向子组件中传递数据？"></a>27、vue父组件如何向子组件中传递数据？</h4><ul><li><p>子组件在props中创建一个属性，用以接收父组件传过来的值(也可以是对象)</p></li><li><p>父组件中注册子组件，并在<code>&lt;template&gt;</code>中添加child标签，标签中添加message属性并赋值</p></li><li><p>在子组件标签中添加子组件props中创建的属性</p></li><li><p>把需要传给子组件的值赋给该属性</p></li></ul><h4 id="28、计算属性的缓存和方法调用的区别"><a href="#28、计算属性的缓存和方法调用的区别" class="headerlink" title="28、计算属性的缓存和方法调用的区别"></a>28、计算属性的缓存和方法调用的区别</h4><ul><li><p>计算属性必须返回结果</p></li><li><p>计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值。</p></li><li><p>使用计算属性还是methods取决于是否需要<strong>缓存</strong>，当遍历大数组和做大量计算时，应当使用计算属<br>性，除非你不希望得到缓存。</p></li><li><p>计算属性是根据依赖自动执行的，methods需要事件调用</p></li></ul><h4 id="29、vue-cli中自定义指令的使用"><a href="#29、vue-cli中自定义指令的使用" class="headerlink" title="29、vue-cli中自定义指令的使用"></a>29、vue-cli中自定义指令的使用</h4><ul><li>vue中除了内置的指令（v-show,v-model）还允许我们<strong>自定义指令</strong></li><li>想要创建自定义指令，就要注册指令（以输入框获取焦点为例） 注意：autofocus 在移动版 Safari 上不工作</li></ul><h5 id="一、注册全局指令："><a href="#一、注册全局指令：" class="headerlink" title="一、注册全局指令："></a>一、注册全局指令：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el,binding</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前指令绑定的dom元素</span></span><br><span class="line"><span class="comment">//console.log(el);</span></span><br><span class="line"><span class="comment">// 指令传入的参数、修饰符、值 v-指令名称:参数.修饰符=值</span></span><br><span class="line"><span class="comment">// console.log(binding)</span></span><br><span class="line"><span class="comment">// 聚焦元素</span></span><br><span class="line">el.focus()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="二、注册局部指令：-组件中也接受一个-directives-的选项"><a href="#二、注册局部指令：-组件中也接受一个-directives-的选项" class="headerlink" title="二、注册局部指令： 组件中也接受一个 directives 的选项"></a>二、注册局部指令： 组件中也接受一个 directives 的选项</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">focus: &#123;</span><br><span class="line"><span class="comment">// 指令的定义</span></span><br><span class="line">inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">el.focus()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用也很简单：直接在元素上面使用v-focus即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="三、举一个自定义指令的小例子：拖拽"><a href="#三、举一个自定义指令的小例子：拖拽" class="headerlink" title="三、举一个自定义指令的小例子：拖拽"></a>三、举一个自定义指令的小例子：<strong>拖拽</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;drag&#x27;</span>, &#123;</span><br><span class="line"><span class="comment">// 当指令绑定到元素上的时候执行</span></span><br><span class="line"><span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;bind&#x27;);</span></span><br><span class="line"><span class="comment">// 当前指令绑定的dom元素</span></span><br><span class="line"><span class="comment">//console.log(el);</span></span><br><span class="line"><span class="comment">// 指令传入的参数、修饰符、值 v-指令名称:参数.修饰符=值</span></span><br><span class="line"><span class="comment">// console.log(binding)</span></span><br><span class="line">el.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = e||event;</span><br><span class="line"><span class="keyword">let</span> disX = e.clientX - el.offsetLeft;</span><br><span class="line"><span class="keyword">let</span> disY = e.clientY - el.offsetTop;</span><br><span class="line">                </span><br><span class="line"><span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> e = e||event;</span><br><span class="line"><span class="keyword">let</span> L = e.clientX - disX;</span><br><span class="line"><span class="keyword">let</span> T = e.clientY - disY;</span><br><span class="line">                    <span class="keyword">if</span> (binding.modifiers.limit) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt; <span class="number">0</span>) &#123;</span><br><span class="line">L = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">el.style.left = L + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">el.style.top = T + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用也很简单，只用在元素上添加v-drag或者v-drag.limit</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">v-drag.limit</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span> <span class="attr">v-drag</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、对于Vue是一套渐进式框架的理解&quot;&gt;&lt;a href=&quot;#1、对于Vue是一套渐进式框架的理解&quot; class=&quot;headerlink&quot; title=&quot;1、对于Vue是一套渐进式框架的理解&quot;&gt;&lt;/a&gt;1、对于Vue是一套渐进式框架的理解&lt;/h4&gt;&lt;p&gt;渐进式代表的</summary>
      
    
    
    
    <category term="Vue" scheme="http://example.com/categories/Vue/"/>
    
    <category term="基础" scheme="http://example.com/categories/Vue/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
</feed>
