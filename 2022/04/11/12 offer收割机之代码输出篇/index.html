<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>12 offer收割机之代码输出篇 | Jungle</title><meta name="keywords" content="面试,代码输出"><meta name="author" content="Jungle"><meta name="copyright" content="Jungle"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目前言：代码输出结果也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行">
<meta property="og:type" content="article">
<meta property="og:title" content="12 offer收割机之代码输出篇">
<meta property="og:url" content="http://example.com/2022/04/11/12%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/index.html">
<meta property="og:site_name" content="Jungle">
<meta property="og:description" content="建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目前言：代码输出结果也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/cover/fe-interview-all.jpg">
<meta property="article:published_time" content="2022-04-11T08:22:44.000Z">
<meta property="article:modified_time" content="2022-05-11T05:12:30.000Z">
<meta property="article:author" content="Jungle">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="代码输出">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/cover/fe-interview-all.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://example.com/2022/04/11/12%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-11 13:12:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Jungle" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 爱好</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 留声机</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书架</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 观影区</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/foot/"><i class="fa-fw fas fa-paw"></i><span> 足迹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../images/cover/fe-interview-all.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jungle</a></span><span id="weather-v2-plugin-simple"></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 爱好</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 留声机</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-book"></i><span> 读书架</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 观影区</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/foot/"><i class="fa-fw fas fa-paw"></i><span> 足迹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">12 offer收割机之代码输出篇<a class="post-edit-link" href="null_posts/12 offer收割机之代码输出篇.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-11T08:22:44.000Z" title="发表于 2022-04-11 16:22:44">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-11T05:12:30.000Z" title="更新于 2022-05-11 13:12:30">2022-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/offer%E6%94%B6%E5%89%B2%E6%9C%BA/">offer收割机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="建议有时间或者校招要做笔试的同学看下-社招基本只需要看看事件循环的题目"><a href="#建议有时间或者校招要做笔试的同学看下-社招基本只需要看看事件循环的题目" class="headerlink" title="建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目"></a>建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><strong>代码输出结果</strong>也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：<strong>异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承</strong>等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。</p>
<p><strong>注：</strong>本文中所有例题收集自牛客网面经、网络博文等，如果侵权，请联系删除！</p>
<h2 id="一、异步-amp-事件循环"><a href="#一、异步-amp-事件循环" class="headerlink" title="一、异步&amp;事件循环"></a>一、异步&amp;事件循环</h2><h3 id="1-代码输出结果"><a href="#1-代码输出结果" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(() =&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p>
<h3 id="2-代码输出结果"><a href="#2-代码输出结果" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;)</span><br><span class="line">  resolve(&#x27;resolve1&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">const promise2 = promise1.then(res =&gt; &#123;</span><br><span class="line">  console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;1&#x27;, promise1);</span><br><span class="line">console.log(&#x27;2&#x27;, promise2);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise1</span><br><span class="line">1 Promise&#123;&lt;resolved&gt;: resolve1&#125;</span><br><span class="line">2 Promise&#123;&lt;pending&gt;&#125;</span><br><span class="line">resolve1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p>
<p>代码执行过程如下：</p>
<ol>
<li>script是一个宏任务，按照顺序执行这些代码；</li>
<li>首先进入Promise，执行该构造函数中的代码，打印<code>promise1</code>；</li>
<li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来；</li>
<li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列；</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code>；</li>
<li>执行同步代码1， 同时打印出<code>promise1</code>的状态是<code>resolved</code>；</li>
<li>执行同步代码2，同时打印出<code>promise2</code>的状态是<code>pending</code>；</li>
<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ol>
<h3 id="3-代码输出结果"><a href="#3-代码输出结果" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;timerStart&quot;);</span><br><span class="line">    resolve(&quot;success&quot;);</span><br><span class="line">    console.log(&quot;timerEnd&quot;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">timerStart</span><br><span class="line">timerEnd</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ul>
<li>首先遇到Promise构造函数，会先执行里面的内容，打印<code>1</code>；</li>
<li>遇到定时器<code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li>
<li>继续向下执行，打印出2；</li>
<li>由于<code>Promise</code>的状态此时还是<code>pending</code>，所以<code>promise.then</code>先不执行；</li>
<li>继续执行下面的同步任务，打印出4；</li>
<li>此时微任务队列没有任务，继续执行下一轮宏任务，执行<code>steTimeout</code>；</li>
<li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列，再执行<code>timerEnd</code>；</li>
<li>执行完这个宏任务，就去执行微任务<code>promise.then</code>，打印出<code>resolve</code>的结果。</li>
</ul>
<h3 id="4-代码输出结果"><a href="#4-代码输出结果" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;);</span><br><span class="line">  const timer2 = setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer2&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;);</span><br><span class="line">const timer1 = setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer1&#x27;)</span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise2&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(&#x27;start&#x27;);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">promise1</span><br><span class="line">timer1</span><br><span class="line">promise2</span><br><span class="line">timer2</span><br></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li>
<li>执行timer1，它是一个宏任务，加入宏任务队列</li>
<li>继续执行下面的同步代码，打印出<code>start</code></li>
<li>这样第一轮宏任务就执行完了，开始执行微任务<code>Promise.resolve().then</code>，打印出<code>promise1</code></li>
<li>遇到<code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是<code>timer1</code>、<code>timer2</code>；</li>
<li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器<code>timer1</code>，打印<code>timer1</code>；</li>
<li>遇到<code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li>
<li>开始执行微任务队列中的任务，打印<code>promise2</code>；</li>
<li>最后执行宏任务<code>timer2</code>定时器，打印出<code>timer2</code>；</li>
</ol>
<h3 id="5-代码输出结果"><a href="#5-代码输出结果" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&#x27;success1&#x27;);</span><br><span class="line">    reject(&#x27;error&#x27;);</span><br><span class="line">    resolve(&#x27;success2&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;then:&#x27;, res);</span><br><span class="line">&#125;).catch((err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;catch:&#x27;, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then：success1</span><br></pre></td></tr></table></figure>

<p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由<code>pending</code>变为<code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p>
<h3 id="6-代码输出结果"><a href="#6-代码输出结果" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p>
<h3 id="7-代码输出结果"><a href="#7-代码输出结果" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;success&#x27;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const promise2 = promise1.then(() =&gt; &#123;</span><br><span class="line">  throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;promise1&#x27;, promise1)</span><br><span class="line">console.log(&#x27;promise2&#x27;, promise2)</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;promise1&#x27;, promise1)</span><br><span class="line">  console.log(&#x27;promise2&#x27;, promise2)</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise1 Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 Promise &#123;&lt;pending&gt;&#125;</span><br><span class="line"></span><br><span class="line">Uncaught (in promise) Error: error!!!</span><br><span class="line">promise1 Promise &#123;&lt;fulfilled&gt;: &quot;success&quot;&#125;</span><br><span class="line">promise2 Promise &#123;&lt;rejected&gt;: Error: error!!&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-代码输出结果"><a href="#8-代码输出结果" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    return 3;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1   </span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p>
<p>上面的输出结果之所以依次打印出1和2，是因为<code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成<code>resolve(2)</code>，被最后的then打印输出2。</p>
<h3 id="9-代码输出结果"><a href="#9-代码输出结果" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">  return new Error(&#x27;error!!!&#x27;)</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(&quot;then: &quot;, res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">  console.log(&quot;catch: &quot;, err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;then: &quot; &quot;Error: error!!!&quot;</span><br></pre></td></tr></table></figure>

<p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p>
<h3 id="10-代码输出结果"><a href="#10-代码输出结果" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const promise = Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">  return promise;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(console.err)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure>

<p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<h3 id="11-代码输出结果"><a href="#11-代码输出结果" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .then(console.log)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或<code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p>
<p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p>
<h3 id="12-代码输出结果"><a href="#12-代码输出结果" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(&#x27;err!!!&#x27;)</span><br><span class="line">  .then((res) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;success&#x27;, res)</span><br><span class="line">  &#125;, (err) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;error&#x27;, err)</span><br><span class="line">  &#125;).catch(err =&gt; &#123;</span><br><span class="line">    console.log(&#x27;catch&#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error err!!!</span><br></pre></td></tr></table></figure>

<p>我们知道，<code>.then</code>函数中的两个参数：</p>
<ul>
<li>第一个参数是用来处理Promise成功的函数</li>
<li>第二个则是处理失败的函数</li>
</ul>
<p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>
<p>在这道题中，错误直接被<code>then</code>的第二个参数捕获了，所以就不会被<code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p>
<p>但是，如果是像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve()</span><br><span class="line">  .then(function success (res) &#123;</span><br><span class="line">    throw new Error(&#x27;error!!!&#x27;)</span><br><span class="line">  &#125;, function fail1 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail1&#x27;, err)</span><br><span class="line">  &#125;).catch(function fail2 (err) &#123;</span><br><span class="line">    console.log(&#x27;fail2&#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>在<code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的<code>catch</code>捕获到。</p>
<h3 id="13-代码输出结果"><a href="#13-代码输出结果" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#x27;1&#x27;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">Promise.resolve(&#x27;2&#x27;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally2&#x27;)</span><br><span class="line">    return &#x27;我是finally2返回的值&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally2后面的then函数&#x27;, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">finally2</span><br><span class="line">finally</span><br><span class="line">finally2后面的then函数 2</span><br></pre></td></tr></table></figure>

<p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p>
<ul>
<li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li>
<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是无法知道Promise最终的状态是<code>resolved</code>还是<code>rejected</code>的</li>
<li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li>
<li>finally本质上是then方法的特例</li>
</ul>
<p><code>.finally()</code>的错误捕获：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&#x27;1&#x27;)</span><br><span class="line">  .finally(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally1&#x27;)</span><br><span class="line">    throw new Error(&#x27;我是finally中抛出的异常&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(&#x27;finally后面的then函数&#x27;, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    console.log(&#x27;捕获错误&#x27;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;finally1&#x27;</span><br><span class="line">&#x27;捕获错误&#x27; Error: 我是finally中抛出的异常</span><br></pre></td></tr></table></figure>

<h3 id="14-代码输出结果"><a href="#14-代码输出结果" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p>
<p>之后再使用<code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p>
<h3 id="15-代码输出结果"><a href="#15-代码输出结果" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">  return p</span><br><span class="line">&#125;</span><br><span class="line">function runReject (x) &#123;</span><br><span class="line">  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x))</span><br><span class="line">  return p</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])</span><br><span class="line">       .then(res =&gt; console.log(res))</span><br><span class="line">       .catch(err =&gt; console.log(err))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1s后输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">// 2s后输出</span><br><span class="line">2</span><br><span class="line">Error: 2</span><br><span class="line">// 4s后输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是<code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。会被<code>.then()</code>的第二个回调函数捕获。</p>
<h3 id="16-代码输出结果"><a href="#16-代码输出结果" class="headerlink" title="16. 代码输出结果"></a>16. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function runAsync (x) &#123;</span><br><span class="line">  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span><br><span class="line">  return p</span><br><span class="line">&#125;</span><br><span class="line">Promise.race([runAsync(1), runAsync(2), runAsync(3)])</span><br><span class="line">  .then(res =&gt; console.log(&#x27;result: &#x27;, res))</span><br><span class="line">  .catch(err =&gt; console.log(err))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">&#x27;result: &#x27; 1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p>
<h3 id="17-代码输出结果"><a href="#17-代码输出结果" class="headerlink" title="17. 代码输出结果"></a>17. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function runAsync(x) &#123;</span><br><span class="line">  const p = new Promise(r =&gt;</span><br><span class="line">    setTimeout(() =&gt; r(x, console.log(x)), 1000)</span><br><span class="line">  );</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line">function runReject(x) &#123;</span><br><span class="line">  const p = new Promise((res, rej) =&gt;</span><br><span class="line">    setTimeout(() =&gt; rej(`Error: $&#123;x&#125;`, console.log(x)), 1000 * x)</span><br><span class="line">  );</span><br><span class="line">  return p;</span><br><span class="line">&#125;</span><br><span class="line">Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])</span><br><span class="line">  .then(res =&gt; console.log(&quot;result: &quot;, res))</span><br><span class="line">  .catch(err =&gt; console.log(err));</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">Error: 0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p>
<p>注意：<code>all</code>和<code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p>
<h3 id="18-代码输出结果"><a href="#18-代码输出结果" class="headerlink" title="18. 代码输出结果"></a>18. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">console.log(&#x27;start&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行函数中的同步代码<code>async1 start</code>，之后遇到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code>；</li>
<li>跳出<code>async1</code>函数后，执行同步代码<code>start</code>；</li>
<li>在一轮宏任务全部执行完之后，再来执行<code>await</code>后面的内容<code>async1 end</code>。</li>
</ol>
<p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p>
<h3 id="19-代码输出结果"><a href="#19-代码输出结果" class="headerlink" title="19. 代码输出结果"></a>19. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer1&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer2&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer3&#x27;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(&quot;start&quot;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">start</span><br><span class="line">async1 end</span><br><span class="line">timer2</span><br><span class="line">timer3</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先进入<code>async1</code>，打印出<code>async1 start</code>；</li>
<li>之后遇到<code>async2</code>，进入<code>async2</code>，遇到定时器<code>timer2</code>，加入宏任务队列，之后打印<code>async2</code>；</li>
<li>由于<code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器<code>timer3</code>，将其加入宏任务队列，之后打印<code>start</code>；</li>
<li>然后执行async2后面的代码，打印出<code>async1 end</code>，遇到定时器timer1，将其加入宏任务队列；</li>
<li>最后，宏任务队列有三个任务，先后顺序为<code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li>
</ol>
<h3 id="20-代码输出结果"><a href="#20-代码输出结果" class="headerlink" title="20. 代码输出结果"></a>20. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;);</span><br><span class="line">  await new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#x27;async1 success&#x27;);</span><br><span class="line">  return &#x27;async1 end&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;srcipt start&#x27;)</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line">console.log(&#x27;srcipt end&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是在<code>async1</code>中<code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是<code>pending</code>状态，所以在<code>await</code>之后的内容是不会执行的，包括<code>async1</code>后面的 <code>.then</code>。</p>
<h3 id="21-代码输出结果"><a href="#21-代码输出结果" class="headerlink" title="21. 代码输出结果"></a>21. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  console.log(&#x27;async1 start&#x27;);</span><br><span class="line">  await new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">    resolve(&#x27;promise1 resolve&#x27;)</span><br><span class="line">  &#125;).then(res =&gt; console.log(res))</span><br><span class="line">  console.log(&#x27;async1 success&#x27;);</span><br><span class="line">  return &#x27;async1 end&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;srcipt start&#x27;)</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line">console.log(&#x27;srcipt end&#x27;)</span><br></pre></td></tr></table></figure>

<p>这里是对上面一题进行了改造，加上了resolve。</p>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise1 resolve</span><br><span class="line">async1 success</span><br><span class="line">async1 end</span><br></pre></td></tr></table></figure>

<h3 id="22-代码输出结果"><a href="#22-代码输出结果" class="headerlink" title="22. 代码输出结果"></a>22. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">  console.log(&quot;async1 start&quot;);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&quot;async1 end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function async2() &#123;</span><br><span class="line">  console.log(&quot;async2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;script start&quot;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt; &#123;</span><br><span class="line">  console.log(&quot;promise1&quot;);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">  console.log(&quot;promise2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;script end&#x27;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p>代码执行过程如下： </p>
<ol>
<li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li>
<li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li>
<li>之后执行函数async1，首先打印出async1 start；</li>
<li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li>
<li>然后跳出async1和async2，遇到Promise，打印出promise1；</li>
<li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li>
<li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li>
<li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li>
</ol>
<h3 id="23-代码输出结果"><a href="#23-代码输出结果" class="headerlink" title="23. 代码输出结果"></a>23. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(&#x27;async1&#x27;);</span><br><span class="line">  return &#x27;async1 success&#x27;</span><br><span class="line">&#125;</span><br><span class="line">async function async2 () &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;async2&#x27;)</span><br><span class="line">    reject(&#x27;error&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async2</span><br><span class="line">Uncaught (in promise) error</span><br></pre></td></tr></table></figure>

<p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p>
<p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function async1 () &#123;</span><br><span class="line">  await Promise.reject(&#x27;error!!!&#x27;).catch(e =&gt; console.log(e))</span><br><span class="line">  console.log(&#x27;async1&#x27;);</span><br><span class="line">  return Promise.resolve(&#x27;async1 success&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(res =&gt; console.log(res))</span><br><span class="line">console.log(&#x27;script start&#x27;)</span><br></pre></td></tr></table></figure>

<p>这样的输出结果就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">error!!!</span><br><span class="line">async1</span><br><span class="line">async1 success</span><br></pre></td></tr></table></figure>

<h3 id="24-代码输出结果"><a href="#24-代码输出结果" class="headerlink" title="24. 代码输出结果"></a>24. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        console.log(7);</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(5);</span><br><span class="line">            resolve(6);</span><br><span class="line">            console.log(p)</span><br><span class="line">        &#125;, 0)</span><br><span class="line">        resolve(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(2);</span><br><span class="line">    p.then((arg) =&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then((arg) =&gt; &#123;</span><br><span class="line">    console.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">Promise&#123;&lt;resolved&gt;: 1&#125;</span><br></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li>
<li>遇到了定时器，将其加入宏任务队列；</li>
<li>执行Promise  p中的resolve，状态变为resolved，返回值为1；</li>
<li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li>
<li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li>
<li>执行外面的代码，打印出4；</li>
<li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li>
<li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以<code>resolve(6)</code>不会再执行；</li>
<li>最后<code>console.log(p)</code>打印出<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>；</li>
</ol>
<h3 id="25-代码输出结果"><a href="#25-代码输出结果" class="headerlink" title="25. 代码输出结果"></a>25. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const async1 = async () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;async1&#x27;);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;timer1&#x27;)</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">  await new Promise(resolve =&gt; &#123;</span><br><span class="line">    console.log(&#x27;promise1&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(&#x27;async1 end&#x27;)</span><br><span class="line">  return &#x27;async1 success&#x27;</span><br><span class="line">&#125; </span><br><span class="line">console.log(&#x27;script start&#x27;);</span><br><span class="line">async1().then(res =&gt; console.log(res));</span><br><span class="line">console.log(&#x27;script end&#x27;);</span><br><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(2)</span><br><span class="line">  .then(Promise.resolve(3))</span><br><span class="line">  .catch(4)</span><br><span class="line">  .then(res =&gt; console.log(res))</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&#x27;timer2&#x27;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">1</span><br><span class="line">timer2</span><br><span class="line">timer1</span><br></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行同步带吗，打印出script start；</li>
<li>遇到定时器timer1将其加入宏任务队列；</li>
<li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li>
<li>然后执行同步代码，打印出script end；</li>
<li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li>
<li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li>
</ol>
<h3 id="26-代码输出结果"><a href="#26-代码输出结果" class="headerlink" title="26. 代码输出结果"></a>26. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&#x27;resolve3&#x27;);</span><br><span class="line">    console.log(&#x27;timer1&#x27;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">  resolve(&#x27;resovle1&#x27;);</span><br><span class="line">  resolve(&#x27;resolve2&#x27;);</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">  console.log(res)  // resolve1</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(p1)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).finally(res =&gt; &#123;</span><br><span class="line">  console.log(&#x27;finally&#x27;, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行结果为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve1</span><br><span class="line">finally  undefined</span><br><span class="line">timer1</span><br><span class="line">Promise&#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-代码输出结果"><a href="#27-代码输出结果" class="headerlink" title="27. 代码输出结果"></a>27. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x27;1&#x27;);</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;3&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;4&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;5&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(function() &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#x27;7&#x27;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#x27;8&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#x27;9&#x27;);</span><br><span class="line">    process.nextTick(function() &#123;</span><br><span class="line">        console.log(&#x27;10&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function(resolve) &#123;</span><br><span class="line">        console.log(&#x27;11&#x27;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(function() &#123;</span><br><span class="line">        console.log(&#x27;12&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>（1）第一轮事件循环流程分析如下：</strong></p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>
<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为<code>setTimeout1</code>。</li>
<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为<code>process1</code>。</li>
<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为<code>then1</code>。</li>
<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody></table>
<p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了<code>process1</code>和<code>then1</code>两个微任务：</p>
<ul>
<li>执行<code>process1</code>，输出6。</li>
<li>执行<code>then1</code>，输出8。</li>
</ul>
<p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p>
<p><strong>（2）第二轮时间循环从</strong><code>**setTimeout1**</code><strong>宏任务开始：</strong></p>
<ul>
<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。</li>
<li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td>process2</td>
</tr>
<tr>
<td></td>
<td>then2</td>
</tr>
</tbody></table>
<p>第二轮事件循环宏任务结束，发现有<code>process2</code>和<code>then2</code>两个微任务可以执行：</p>
<ul>
<li>输出3。</li>
<li>输出5。</li>
</ul>
<p>第二轮事件循环结束，第二轮输出2，4，3，5。</p>
<p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p>
<ul>
<li>直接输出9。</li>
<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>
<li>直接执行<code>new Promise</code>，输出11。</li>
<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody></table>
<p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>：</p>
<ul>
<li>输出10。</li>
<li>输出12。</li>
</ul>
<p>第三轮事件循环结束，第三轮输出9，11，10，12。</p>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>
<h3 id="28-代码输出结果"><a href="#28-代码输出结果" class="headerlink" title="28. 代码输出结果"></a>28. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise(resolve =&gt;  &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">  resolve(4)</span><br><span class="line">&#125;).then(d =&gt; console.log(d))</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(5)</span><br><span class="line">  new Promise(resolve =&gt;  &#123;</span><br><span class="line">    resolve(6)</span><br><span class="line">  &#125;).then(d =&gt; console.log(d))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(7)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(8)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行script代码，打印出1；</li>
<li>遇到第一个定时器，加入到宏任务队列；</li>
<li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器，加入到宏任务队列；</li>
<li>遇到第三个定时器，加入到宏任务队列；</li>
<li>继续执行script代码，打印出8，第一轮执行结束；</li>
<li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li>
<li>开始执行宏任务队列，执行第一个定时器，打印出2；</li>
<li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li>
<li>执行微任务队列，打印出6；</li>
<li>执行宏任务队列中的最后一个定时器，打印出7。</li>
</ol>
<h3 id="29-代码输出结果"><a href="#29-代码输出结果" class="headerlink" title="29. 代码输出结果"></a>29. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">    </span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(4)</span><br><span class="line">  resolve(5)</span><br><span class="line">&#125;).then((data) =&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(7);</span><br></pre></td></tr></table></figure>

<p>代码输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行scrip代码，打印出1；</li>
<li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li>
<li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li>
<li>执行script代码，打印出7，至此第一轮执行完成；</li>
<li>指定微任务队列中的代码，打印出resolve的结果：5；</li>
<li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li>
<li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li>
<li>继续执行宏任务队列中的第二个定时器，打印出6。</li>
</ol>
<h3 id="30-代码输出结果"><a href="#30-代码输出结果" class="headerlink" title="30. 代码输出结果"></a>30. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;1&#x27;);</span><br><span class="line">    throw &#x27;Error&#x27;;</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;2&#x27;);</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;3&#x27;);</span><br><span class="line">    throw &#x27;Error&#x27;;</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;4&#x27;);</span><br><span class="line">&#125;).catch(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;5&#x27;);</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;6&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">5 </span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p>
<h3 id="31-代码输出结果"><a href="#31-代码输出结果" class="headerlink" title="31. 代码输出结果"></a>31. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 100);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  resolve();</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">  console.log(4);</span><br><span class="line">  new Promise((resove, reject) =&gt; &#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">    setTimeout(() =&gt;  &#123;</span><br><span class="line">      console.log(6);</span><br><span class="line">    &#125;, 10);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(7);</span><br><span class="line">console.log(8);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先遇到定时器，将其加入到宏任务队列；</li>
<li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li>
<li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li>
<li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li>
<li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li>
<li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li>
</ol>
<p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p>
<h2 id="二、this"><a href="#二、this" class="headerlink" title="二、this"></a>二、this</h2><h3 id="1-代码输出结果-1"><a href="#1-代码输出结果-1" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( this.a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doFoo() &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  doFoo: doFoo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = 2; </span><br><span class="line">obj.doFoo()</span><br></pre></td></tr></table></figure>

<p>输出结果：2 </p>
<p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p>
<h3 id="2-代码输出结果-1"><a href="#2-代码输出结果-1" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10</span><br><span class="line">var obj = &#123;</span><br><span class="line">  a: 20,</span><br><span class="line">  say: () =&gt; &#123;</span><br><span class="line">    console.log(this.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say() </span><br><span class="line"></span><br><span class="line">var anotherObj = &#123; a: 30 &#125; </span><br><span class="line">obj.say.apply(anotherObj) </span><br></pre></td></tr></table></figure>

<p>输出结果：10  10</p>
<p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p>
<p>但是，如果是普通函数，那么就会有完全不一样的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10  </span><br><span class="line">var obj = &#123;  </span><br><span class="line">  a: 20,  </span><br><span class="line">  say()&#123;</span><br><span class="line">    console.log(this.a)  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">obj.say()   </span><br><span class="line">var anotherObj=&#123;a:30&#125;   </span><br><span class="line">obj.say.apply(anotherObj)</span><br></pre></td></tr></table></figure>

<p>输出结果：20 30</p>
<p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p>
<h3 id="3-代码输出结果-1"><a href="#3-代码输出结果-1" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">a.call(null);</span><br></pre></td></tr></table></figure>

<p>打印结果：window对象</p>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">a.call(null); // null</span><br><span class="line">a.call(undefined); // undefined</span><br></pre></td></tr></table></figure>

<h3 id="4-代码输出结果-1"><a href="#4-代码输出结果-1" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; </span><br><span class="line">  name: &#x27;cuggz&#x27;, </span><br><span class="line">  fun: function()&#123; </span><br><span class="line">     console.log(this.name); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">obj.fun()     // cuggz</span><br><span class="line">new obj.fun() // undefined</span><br></pre></td></tr></table></figure>

<h3 id="6-代码输出结果-1"><a href="#6-代码输出结果-1" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">   say: function() &#123;</span><br><span class="line">     var f1 = () =&gt;  &#123;</span><br><span class="line">       console.log(&quot;1111&quot;, this);</span><br><span class="line">     &#125;</span><br><span class="line">     f1();</span><br><span class="line">   &#125;,</span><br><span class="line">   pro: &#123;</span><br><span class="line">     getPro:() =&gt;  &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var o = obj.say;</span><br><span class="line">o();</span><br><span class="line">obj.say();</span><br><span class="line">obj.pro.getPro();</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1111 window对象</span><br><span class="line">1111 obj对象</span><br><span class="line">window对象</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li>
<li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li>
<li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li>
</ol>
<h3 id="7-代码输出结果-1"><a href="#7-代码输出结果-1" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo: &quot;bar&quot;,</span><br><span class="line">    func: function() &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        console.log(this.foo);  </span><br><span class="line">        console.log(self.foo);  </span><br><span class="line">        (function() &#123;</span><br><span class="line">            console.log(this.foo);  </span><br><span class="line">            console.log(self.foo);  </span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func();</span><br></pre></td></tr></table></figure>

<p>输出结果：bar bar undefined bar</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先func是由myObject调用的，this指向myObject。又因为var self = this;所以self指向myObject。</li>
<li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li>
</ol>
<h3 id="8-代码输出问题"><a href="#8-代码输出问题" class="headerlink" title="8. 代码输出问题"></a>8. 代码输出问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">window.number = 2;</span><br><span class="line">var obj = &#123;</span><br><span class="line"> number: 3,</span><br><span class="line"> db1: (function()&#123;</span><br><span class="line">   console.log(this);</span><br><span class="line">   this.number *= 4;</span><br><span class="line">   return function()&#123;</span><br><span class="line">     console.log(this);</span><br><span class="line">     this.number *= 5;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">var db1 = obj.db1;</span><br><span class="line">db1();</span><br><span class="line">obj.db1();</span><br><span class="line">console.log(obj.number);     // 15</span><br><span class="line">console.log(window.number);  // 40</span><br></pre></td></tr></table></figure>

<p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p>
<ol>
<li>执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；</li>
<li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。</li>
</ol>
<h3 id="9-代码输出结果-1"><a href="#9-代码输出结果-1" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var length = 10;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var obj = &#123;</span><br><span class="line">  length: 5,</span><br><span class="line">  method: function(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">    arguments[0]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">obj.method(fn, 1);</span><br></pre></td></tr></table></figure>

<p>输出结果： 10 2 </p>
<p><strong>解析：</strong></p>
<ol>
<li>第一次执行fn()，this指向window对象，输出10。</li>
<li>第二次执行arguments<a href="">0</a>，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li>
</ol>
<h3 id="10-代码输出结果-1"><a href="#10-代码输出结果-1" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function printA()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a:2,</span><br><span class="line">  foo:printA,</span><br><span class="line">  bar:function()&#123;</span><br><span class="line">    printA();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo(); // 2</span><br><span class="line">obj.bar(); // 1</span><br><span class="line">var foo = obj.foo;</span><br><span class="line">foo(); // 1</span><br></pre></td></tr></table></figure>

<p>输出结果： 2 1 1 </p>
<p><strong>解析：</strong></p>
<ol>
<li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li>
<li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li>
<li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li>
</ol>
<h3 id="11-代码输出结果-1"><a href="#11-代码输出结果-1" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var x = 3;</span><br><span class="line">var y = 4;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 6,</span><br><span class="line">    getX: function() &#123;</span><br><span class="line">        var x = 5;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return this.x;</span><br><span class="line">        &#125;();</span><br><span class="line">    &#125;,</span><br><span class="line">    getY: function() &#123;</span><br><span class="line">        var y = 7;</span><br><span class="line">        return this.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(obj.getX()) // 3</span><br><span class="line">console.log(obj.getY()) // 6</span><br></pre></td></tr></table></figure>

<p>输出结果：3  6</p>
<p><strong>解析：</strong></p>
<ol>
<li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li>
<li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li>
</ol>
<h3 id="12-代码输出结果-1"><a href="#12-代码输出结果-1" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10; </span><br><span class="line">var obt = &#123; </span><br><span class="line">  a: 20, </span><br><span class="line">  fn: function()&#123; </span><br><span class="line">    var a = 30; </span><br><span class="line">    console.log(this.a)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">obt.fn();  // 20</span><br><span class="line">obt.fn.call(); // 10</span><br><span class="line">(obt.fn)(); // 20</span><br></pre></td></tr></table></figure>

<p>输出结果： 20  10  20 </p>
<p><strong>解析：</strong></p>
<ol>
<li> obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li>
<li> obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li>
<li> (obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；</li>
</ol>
<h3 id="13-代码输出结果-1"><a href="#13-代码输出结果-1" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a(xx)&#123;</span><br><span class="line">  this.x = xx;</span><br><span class="line">  return this</span><br><span class="line">&#125;;</span><br><span class="line">var x = a(5);</span><br><span class="line">var y = a(6);</span><br><span class="line"></span><br><span class="line">console.log(x.x)  // undefined</span><br><span class="line">console.log(y.x)  // 6</span><br></pre></td></tr></table></figure>

<p>输出结果： undefined  6</p>
<p><strong>解析：</strong></p>
<ol>
<li>最关键的就是var x = a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。<strong>所以 this.x = 5 就相当于：window.x = 5。</strong>之后 return this，也就是说 var x = a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li>
<li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li>
</ol>
<h3 id="14-代码输出结果-1"><a href="#14-代码输出结果-1" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">    this.a = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(2); </span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line"></span><br><span class="line">obj1.foo.call(obj2, 3);</span><br><span class="line">console.log(obj2.a); // 3</span><br><span class="line"></span><br><span class="line">var bar = new obj1.foo(4)</span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line">console.log(bar.a); // 4</span><br></pre></td></tr></table></figure>

<p>输出结果： 2  3  2  4</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li>
<li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li>
<li>obj1.a会打印出2；</li>
<li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li>
</ol>
<h3 id="15-代码输出结果-1"><a href="#15-代码输出结果-1" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(something)&#123;</span><br><span class="line">    this.a = something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">var bar = foo.bind(obj1);</span><br><span class="line">bar(2);</span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line"></span><br><span class="line">var baz = new bar(3);</span><br><span class="line">console.log(obj1.a); // 2</span><br><span class="line">console.log(baz.a); // 3</span><br></pre></td></tr></table></figure>

<p>输出结果： 2  2  3</p>
<p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：<strong>this绑定的优先级：****new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p>
<h2 id="三、作用域-amp-变量提升-amp-闭包"><a href="#三、作用域-amp-变量提升-amp-闭包" class="headerlink" title="三、作用域&amp;变量提升&amp;闭包"></a>三、作用域&amp;变量提升&amp;闭包</h2><h3 id="1-代码输出结果-2"><a href="#1-代码输出结果-2" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">   var x = y = 1;</span><br><span class="line">&#125;)();</span><br><span class="line">var z;</span><br><span class="line"></span><br><span class="line">console.log(y); // 1</span><br><span class="line">console.log(z); // undefined</span><br><span class="line">console.log(x); // Uncaught ReferenceError: x is not defined</span><br></pre></td></tr></table></figure>

<p>这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p>
<h3 id="2-代码输出结果-2"><a href="#2-代码输出结果-2" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a, b</span><br><span class="line">(function () &#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(b);</span><br><span class="line">   var a = (b = 3);</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(b);   </span><br><span class="line">&#125;)()</span><br><span class="line">console.log(a);</span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">undefined </span><br><span class="line">undefined </span><br><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">undefined </span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">undefined </span><br><span class="line">undefined </span><br><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">undefined </span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p>
<h3 id="3-代码输出结果-2"><a href="#3-代码输出结果-2" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var friendName = &#x27;World&#x27;;</span><br><span class="line">(function() &#123;</span><br><span class="line">  if (typeof friendName === &#x27;undefined&#x27;) &#123;</span><br><span class="line">    var friendName = &#x27;Jack&#x27;;</span><br><span class="line">    console.log(&#x27;Goodbye &#x27; + friendName);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#x27;Hello &#x27; + friendName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>输出结果：Goodbye Jack</p>
<p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;World!&#x27;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var name;</span><br><span class="line">    if (typeof name === &#x27;undefined&#x27;) &#123;</span><br><span class="line">        name = &#x27;Jack&#x27;;</span><br><span class="line">        console.log(&#x27;Goodbye &#x27; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#x27;Hello &#x27; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>这样，答案就一目了然了。</p>
<h3 id="4-代码输出结果-2"><a href="#4-代码输出结果-2" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">  console.log(&#x27;fn1&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var fn2</span><br><span class="line"> </span><br><span class="line">fn1()</span><br><span class="line">fn2()</span><br><span class="line"> </span><br><span class="line">fn2 = function() &#123;</span><br><span class="line">  console.log(&#x27;fn2&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>

<p>输出结果： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn1</span><br><span class="line">Uncaught TypeError: fn2 is not a function</span><br><span class="line">fn2</span><br></pre></td></tr></table></figure>

<p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p>
<h3 id="5-代码输出结果-1"><a href="#5-代码输出结果-1" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">    var temp = 10;</span><br><span class="line">    function b() &#123;</span><br><span class="line">        console.log(temp); // 10</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    var temp = 10;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(temp); // 报错 Uncaught ReferenceError: temp is not defined</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p>
<h3 id="6-代码输出结果-2"><a href="#6-代码输出结果-2" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=3;</span><br><span class="line">function c()&#123;</span><br><span class="line">   alert(a);</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line"> var a=4;</span><br><span class="line"> c();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p>
<h3 id="7-代码输出问题"><a href="#7-代码输出问题" class="headerlink" title="7.  代码输出问题"></a>7.  代码输出问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fun(n, o) &#123;</span><br><span class="line">  console.log(o)</span><br><span class="line">  return &#123;</span><br><span class="line">    fun: function(m)&#123;</span><br><span class="line">      return fun(m, n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);</span><br><span class="line">var b = fun(0).fun(1).fun(2).fun(3);</span><br><span class="line">var c = fun(0).fun(1);  c.fun(2);  c.fun(3);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undefined  0  0  0</span><br><span class="line">undefined  0  1  2</span><br><span class="line">undefined  0  1  1</span><br></pre></td></tr></table></figure>

<p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p>
<h3 id="8-代码输出结果-1"><a href="#8-代码输出结果-1" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = function() &#123;return true;&#125;;   </span><br><span class="line">g = function() &#123;return false;&#125;;   </span><br><span class="line">(function() &#123;   </span><br><span class="line">   if (g() &amp;&amp; [] == ![]) &#123;   </span><br><span class="line">      f = function f() &#123;return false;&#125;;   </span><br><span class="line">      function g() &#123;return true;&#125;   </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;)();   </span><br><span class="line">console.log(f());</span><br></pre></td></tr></table></figure>

<p>输出结果： false</p>
<p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p>
<p>第二个条件是[] == ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。</p>
<p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p>
<h2 id="四、原型-amp-继承"><a href="#四、原型-amp-继承" class="headerlink" title="四、原型&amp;继承"></a>四、原型&amp;继承</h2><h3 id="1-代码输出结果-3"><a href="#1-代码输出结果-3" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">var p2 = new Person(&#x27;king&#x27;);</span><br><span class="line">console.log(p2.__proto__) //Person.prototype</span><br><span class="line">console.log(p2.__proto__.__proto__) //Object.prototype</span><br><span class="line">console.log(p2.__proto__.__proto__.__proto__) // null</span><br><span class="line">console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错</span><br><span class="line">console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错</span><br><span class="line">console.log(p2.constructor)//Person</span><br><span class="line">console.log(p2.prototype)//undefined p2是实例，没有prototype属性</span><br><span class="line">console.log(Person.constructor)//Function 一个空函数</span><br><span class="line">console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性</span><br><span class="line">console.log(Person.prototype.constructor)//Person</span><br><span class="line">console.log(Person.prototype.__proto__)// Object.prototype</span><br><span class="line">console.log(Person.__proto__) //Function.prototype</span><br><span class="line">console.log(Function.prototype.__proto__)//Object.prototype</span><br><span class="line">console.log(Function.__proto__)//Function.prototype</span><br><span class="line">console.log(Object.__proto__)//Function.prototype</span><br><span class="line">console.log(Object.prototype.__proto__)//null</span><br></pre></td></tr></table></figure>

<p>这道义题目考察原型、原型链的基础，记住就可以了。</p>
<h3 id="2-代码输出结果-3"><a href="#2-代码输出结果-3" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// a</span><br><span class="line">function Foo () &#123;</span><br><span class="line"> getName = function () &#123;</span><br><span class="line">   console.log(1);</span><br><span class="line"> &#125;</span><br><span class="line"> return this;</span><br><span class="line">&#125;</span><br><span class="line">// b</span><br><span class="line">Foo.getName = function () &#123;</span><br><span class="line"> console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">// c</span><br><span class="line">Foo.prototype.getName = function () &#123;</span><br><span class="line"> console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">// d</span><br><span class="line">var getName = function () &#123;</span><br><span class="line"> console.log(4);</span><br><span class="line">&#125;</span><br><span class="line">// e</span><br><span class="line">function getName () &#123;</span><br><span class="line"> console.log(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName();           // 2</span><br><span class="line">getName();               // 4</span><br><span class="line">Foo().getName();         // 1</span><br><span class="line">getName();               // 1 </span><br><span class="line">new Foo.getName();       // 2</span><br><span class="line">new Foo().getName();     // 3</span><br><span class="line">new new Foo().getName(); // 3</span><br></pre></td></tr></table></figure>

<p>输出结果：2  4  1  1  2  3  3</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>Foo.getName()，</strong>Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li>
<li><strong>getName()，</strong>这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li>
<li> <strong>Foo().getName()，</strong>这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li>
<li><strong>getName()，</strong>上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li>
<li><strong>new Foo.getName()，</strong>这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li>
<li><strong>new Foo().getName()，</strong>这里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.<strong>protot</strong> === Foo.prototype，所以输出 3；</li>
<li><strong>new new Foo().getName()，</strong>这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li>
</ol>
<h3 id="3-代码输出结果-3"><a href="#3-代码输出结果-3" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var F = function() &#123;&#125;;</span><br><span class="line">Object.prototype.a = function() &#123;</span><br><span class="line">  console.log(&#x27;a&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.b = function() &#123;</span><br><span class="line">  console.log(&#x27;b&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">var f = new F();</span><br><span class="line">f.a();</span><br><span class="line">f.b();</span><br><span class="line">F.a();</span><br><span class="line">F.b()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">Uncaught TypeError: f.b is not a function</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a  ，而 f.b() 就报错了。</li>
<li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof  Object === true，F instanceof Function === true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li>
</ol>
<h3 id="4-代码输出结果-3"><a href="#4-代码输出结果-3" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    Foo.a = function()&#123;</span><br><span class="line">        console.log(1);</span><br><span class="line">    &#125;</span><br><span class="line">    this.a = function()&#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.a = function()&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.a = function()&#123;</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.a();</span><br><span class="line">let obj = new Foo();</span><br><span class="line">obj.a();</span><br><span class="line">Foo.a();</span><br></pre></td></tr></table></figure>

<p>输出结果：4 2 1</p>
<p><strong>解析：</strong></p>
<ol>
<li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li>
<li>let obj = new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li>
<li> obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li>
<li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li>
</ol>
<h3 id="5-代码输出结果-2"><a href="#5-代码输出结果-2" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Dog() &#123;</span><br><span class="line">  this.name = &#x27;puppy&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = () =&gt; &#123;</span><br><span class="line">  console.log(&#x27;woof!woof!&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const dog = new Dog()</span><br><span class="line">console.log(Dog.prototype.constructor === Dog &amp;&amp; dog.constructor === Dog &amp;&amp; dog instanceof Dog)</span><br></pre></td></tr></table></figure>

<p>输出结果：true</p>
<p><strong>解析：</strong></p>
<p>因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p>
<p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p>
<h3 id="6-代码输出结果-3"><a href="#6-代码输出结果-3" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var A = &#123;n: 4399&#125;;</span><br><span class="line">var B =  function()&#123;this.n = 9999&#125;;</span><br><span class="line">var C =  function()&#123;var n = 8888&#125;;</span><br><span class="line">B.prototype = A;</span><br><span class="line">C.prototype = A;</span><br><span class="line">var b = new B();</span><br><span class="line">var c = new C();</span><br><span class="line">A.n++</span><br><span class="line">console.log(b.n);</span><br><span class="line">console.log(c.n);</span><br></pre></td></tr></table></figure>

<p>输出结果：9999  4400</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b = new B()时，函数内部this.n=9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li>
<li>console.log(c.n)，同理，当执行var c = new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li>
</ol>
<h3 id="7-代码输出问题-1"><a href="#7-代码输出问题-1" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function A()&#123;</span><br><span class="line">&#125;</span><br><span class="line">function B(a)&#123;</span><br><span class="line">　　this.a = a;</span><br><span class="line">&#125;</span><br><span class="line">function C(a)&#123;</span><br><span class="line">　　if(a)&#123;</span><br><span class="line">this.a = a;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.a = 1;</span><br><span class="line">B.prototype.a = 1;</span><br><span class="line">C.prototype.a = 1;</span><br><span class="line"> </span><br><span class="line">console.log(new A().a);</span><br><span class="line">console.log(new B().a);</span><br><span class="line">console.log(new C(2).a);</span><br></pre></td></tr></table></figure>

<p>输出结果：1  undefined  2</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li>
<li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li>
<li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a = 2,故属性a的值为2。</li>
</ol>
<h3 id="8-代码输出问题-1"><a href="#8-代码输出问题-1" class="headerlink" title="8 代码输出问题"></a>8 代码输出问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.a = 1;</span><br><span class="line">    this.b = [1, 2, this.a];</span><br><span class="line">    this.c = &#123; demo: 5 &#125;;</span><br><span class="line">    this.show = function () &#123;</span><br><span class="line">        console.log(this.a , this.b , this.c.demo );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    this.a = 2;</span><br><span class="line">    this.change = function () &#123;</span><br><span class="line">        this.b.push(this.a);</span><br><span class="line">        this.a = this.b.length;</span><br><span class="line">        this.c.demo = this.a++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = new Parent();</span><br><span class="line">var parent = new Parent();</span><br><span class="line">var child1 = new Child();</span><br><span class="line">var child2 = new Child();</span><br><span class="line">child1.a = 11;</span><br><span class="line">child2.a = 12;</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line">parent.show();</span><br><span class="line">child1.show();</span><br><span class="line">child2.show();</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parent.show(); // 1  [1,2,1] 5</span><br><span class="line"></span><br><span class="line">child1.show(); // 11 [1,2,1] 5</span><br><span class="line">child2.show(); // 12 [1,2,1] 5</span><br><span class="line"></span><br><span class="line">parent.show(); // 1 [1,2,1] 5</span><br><span class="line"></span><br><span class="line">child1.show(); // 5 [1,2,1,11,12] 5</span><br><span class="line"></span><br><span class="line">child2.show(); // 6 [1,2,1,11,12] 5</span><br></pre></td></tr></table></figure>

<p>这道题目值得神帝，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p>
<p><strong>解析****：</strong></p>
<ol>
<li>parent.show()，可以直接获得所需的值，没啥好说的；</li>
<li>child1.show()，<code>Child</code>的构造函数原本是指向<code>Child</code>的，题目显式将<code>Child</code>类的原型对象指向了<code>Parent</code>类的一个实例，需要注意<code>Child.prototype</code>指向的是<code>Parent</code>的实例<code>parent</code>，而不是指向<code>Parent</code>这个类。</li>
<li>child2.show()，这个也没啥好说的；</li>
<li>parent.show()，<code>parent</code>是一个<code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是<code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响<code>parent</code>实例，所以输出结果不变；</li>
<li>child1.show()，<code>child1</code>执行了<code>change()</code>方法后，发生了怎样的变化呢?</li>
</ol>
<ul>
<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child1</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li>
<li><strong>this.a = this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child1.a</code>变为<strong>4</strong>;</li>
<li><strong>this.c.demo = this.a++，</strong>由于<code>child1</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，<code>this.a</code>值为<strong>4</strong>，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为<strong>4</strong>，而<code>this.a</code>随后自增为<strong>5(4 + 1 = 5)。</strong></li>
</ul>
<ol>
<li><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果。</li>
</ol>
<ul>
<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child2</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li>
<li><strong>this.a = this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child2.a</code>变为<strong>5</strong>;</li>
<li><strong>this.c.demo = this.a++，</strong>由于<code>child2</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，故执行结果为<code>Child.prototype.c.demo</code>的值变为<code>child2.a</code>的值<strong>5</strong>，而<code>child2.a</code>最终自增为<strong>6(5 + 1 = 6)。</strong></li>
</ul>
<h3 id="9-代码输出结果-2"><a href="#9-代码输出结果-2" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123;</span><br><span class="line">    this.property = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123;</span><br><span class="line">    return this.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function SubType()&#123;</span><br><span class="line">    this.subproperty = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.getSubValue = function ()&#123;</span><br><span class="line">    return this.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var instance = new SubType();</span><br><span class="line">console.log(instance.getSuperValue());</span><br></pre></td></tr></table></figure>

<p>输出结果：true</p>
<p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1620043144097-44798602-b916-406d-bc50-e003f27dece2.png" alt="image.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jungle</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/11/12%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/">http://example.com/2022/04/11/12 offer收割机之代码输出篇/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Jungle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA/">代码输出</a></div><div class="post_share"><div class="social-share" data-image="/../images/cover/fe-interview-all.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/15/13%20LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/"><img class="prev-cover" src="/../images/cover/fe-interview-all.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">13 offer收割机之LeetCode面试常考题</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/29/11%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/"><img class="next-cover" src="/../images/cover/fe-interview-all.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">11 offer收割机之手写代码篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/07/15/interview-exp01/" title="前端面试exp01"><img class="cover" src="/../images/cover/FE-Interview.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-15</div><div class="title">前端面试exp01</div></div></a></div><div><a href="/2021/09/23/interview-exp02/" title="前端面试exp02"><img class="cover" src="/../images/cover/FE-Interview.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-23</div><div class="title">前端面试exp02</div></div></a></div><div><a href="/2021/11/14/1 前端面试准备/" title="1 前端面试准备"><img class="cover" src="/../images/cover/fe-interview-all.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-14</div><div class="title">1 前端面试准备</div></div></a></div><div><a href="/2022/05/05/15 vue项目的性能优化/" title="15 offer收割机之Vue项目性能优化篇"><img class="cover" src="/../images/cover/fe-interview-all.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-05</div><div class="title">15 offer收割机之Vue项目性能优化篇</div></div></a></div><div><a href="/2021/12/20/3 offer收割机之HTML篇/" title="3 offer收割机之HTML篇"><img class="cover" src="/../images/cover/fe-interview-all.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-20</div><div class="title">3 offer收割机之HTML篇</div></div></a></div><div><a href="/2022/01/30/6 offer收割机之性能优化篇/" title="6 offer收割机之性能优化篇"><img class="cover" src="/../images/cover/fe-interview-all.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-30</div><div class="title">6 offer收割机之性能优化篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Jungle</div><div class="author-info__description">喜欢交友，爱好编程，欢迎大家与我一起交流，共同进步！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">110</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qsbit"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qsbit" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jungleemail@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=965499224&amp;site=qq&amp;menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="https://qsbit.gitee.io/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">You make me want to be a better man！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E6%9C%89%E6%97%B6%E9%97%B4%E6%88%96%E8%80%85%E6%A0%A1%E6%8B%9B%E8%A6%81%E5%81%9A%E7%AC%94%E8%AF%95%E7%9A%84%E5%90%8C%E5%AD%A6%E7%9C%8B%E4%B8%8B-%E7%A4%BE%E6%8B%9B%E5%9F%BA%E6%9C%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9C%8B%E7%9C%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">前言：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%82%E6%AD%A5-amp-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.</span> <span class="toc-text">一、异步&amp;事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.1.</span> <span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.2.</span> <span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.3.</span> <span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.4.</span> <span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.5.</span> <span class="toc-text">5. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.6.</span> <span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.7.</span> <span class="toc-text">7. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.8.</span> <span class="toc-text">8. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.9.</span> <span class="toc-text">9. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.10.</span> <span class="toc-text">10. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.11.</span> <span class="toc-text">11. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.12.</span> <span class="toc-text">12. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.13.</span> <span class="toc-text">13. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.14.</span> <span class="toc-text">14. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.15.</span> <span class="toc-text">15. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.16.</span> <span class="toc-text">16. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.17.</span> <span class="toc-text">17. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.18.</span> <span class="toc-text">18. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.19.</span> <span class="toc-text">19. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.20.</span> <span class="toc-text">20. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.21.</span> <span class="toc-text">21. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.22.</span> <span class="toc-text">22. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.23.</span> <span class="toc-text">23. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.24.</span> <span class="toc-text">24. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.25.</span> <span class="toc-text">25. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.26.</span> <span class="toc-text">26. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.27.</span> <span class="toc-text">27. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.28.</span> <span class="toc-text">28. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.29.</span> <span class="toc-text">29. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.30.</span> <span class="toc-text">30. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">2.31.</span> <span class="toc-text">31. 代码输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81this"><span class="toc-number">3.</span> <span class="toc-text">二、this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.1.</span> <span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.2.</span> <span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.3.</span> <span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.4.</span> <span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.5.</span> <span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.6.</span> <span class="toc-text">7. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.</span> <span class="toc-text">8. 代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.8.</span> <span class="toc-text">9. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.9.</span> <span class="toc-text">10. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.10.</span> <span class="toc-text">11. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.11.</span> <span class="toc-text">12. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.12.</span> <span class="toc-text">13. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.13.</span> <span class="toc-text">14. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">3.14.</span> <span class="toc-text">15. 代码输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F-amp-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-amp-%E9%97%AD%E5%8C%85"><span class="toc-number">4.</span> <span class="toc-text">三、作用域&amp;变量提升&amp;闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">4.1.</span> <span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">4.2.</span> <span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">4.3.</span> <span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">4.4.</span> <span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">4.5.</span> <span class="toc-text">5. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">4.6.</span> <span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">7.  代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-number">4.8.</span> <span class="toc-text">8. 代码输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%9E%8B-amp-%E7%BB%A7%E6%89%BF"><span class="toc-number">5.</span> <span class="toc-text">四、原型&amp;继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-number">5.1.</span> <span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-number">5.2.</span> <span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-number">5.3.</span> <span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-number">5.4.</span> <span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">5.5.</span> <span class="toc-text">5. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-number">5.6.</span> <span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98-1"><span class="toc-number">5.7.</span> <span class="toc-text">7. 代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98-1"><span class="toc-number">5.8.</span> <span class="toc-text">8 代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-number">5.9.</span> <span class="toc-text">9. 代码输出结果</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/01/practiceUp/" title="实践问题记录"><img src="/../images/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实践问题记录"/></a><div class="content"><a class="title" href="/2022/07/01/practiceUp/" title="实践问题记录">实践问题记录</a><time datetime="2022-07-01T01:30:18.000Z" title="发表于 2022-07-01 09:30:18">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/05/15%20vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="15 offer收割机之Vue项目性能优化篇"><img src="/../images/cover/fe-interview-all.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="15 offer收割机之Vue项目性能优化篇"/></a><div class="content"><a class="title" href="/2022/05/05/15%20vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="15 offer收割机之Vue项目性能优化篇">15 offer收割机之Vue项目性能优化篇</a><time datetime="2022-05-05T05:55:43.000Z" title="发表于 2022-05-05 13:55:43">2022-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/28/14%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BVue%E7%AF%87/" title="14 offer收割机之Vue篇"><img src="/../images/cover/fe-interview-all.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="14 offer收割机之Vue篇"/></a><div class="content"><a class="title" href="/2022/04/28/14%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BVue%E7%AF%87/" title="14 offer收割机之Vue篇">14 offer收割机之Vue篇</a><time datetime="2022-04-28T08:22:44.000Z" title="发表于 2022-04-28 16:22:44">2022-04-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/15/13%20LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/" title="13 offer收割机之LeetCode面试常考题"><img src="/../images/cover/fe-interview-all.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="13 offer收割机之LeetCode面试常考题"/></a><div class="content"><a class="title" href="/2022/04/15/13%20LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/" title="13 offer收割机之LeetCode面试常考题">13 offer收割机之LeetCode面试常考题</a><time datetime="2022-04-15T08:22:44.000Z" title="发表于 2022-04-15 16:22:44">2022-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/12%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/" title="12 offer收割机之代码输出篇"><img src="/../images/cover/fe-interview-all.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="12 offer收割机之代码输出篇"/></a><div class="content"><a class="title" href="/2022/04/11/12%20offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/" title="12 offer收割机之代码输出篇">12 offer收割机之代码输出篇</a><time datetime="2022-04-11T08:22:44.000Z" title="发表于 2022-04-11 16:22:44">2022-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Jungle</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://qsbit.github.io/">Blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script></div><script src="https://apip.weatherdt.com/simple/static/js/weather-simple-common.js?v=2.0"></script><script src="/js/weather.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>